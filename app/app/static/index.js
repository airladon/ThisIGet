(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("Fig", [], factory);
	else if(typeof exports === 'object')
		exports["Fig"] = factory();
	else
		root["Fig"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./js/tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _js_tools_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./js/tools/math */ "./src/js/tools/math.js");
/* harmony import */ var _js_diagram_Diagram__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./js/diagram/Diagram */ "./src/js/diagram/Diagram.js");
/* harmony import */ var _js_tools_color__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./js/tools/color */ "./src/js/tools/color.js");
/* harmony import */ var _js_tools_htmlGenerator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./js/tools/htmlGenerator */ "./src/js/tools/htmlGenerator.js");
/* harmony import */ var _js_tools_tools__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./js/tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _js_tools_styleSheets__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./js/tools/styleSheets */ "./src/js/tools/styleSheets.js");
/* harmony import */ var _js_diagram_DrawingObjects_Geometries_lines_lines__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./js/diagram/DrawingObjects/Geometries/lines/lines */ "./src/js/diagram/DrawingObjects/Geometries/lines/lines.js");
/* harmony import */ var _js_diagram_Element__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./js/diagram/Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _js_diagram_DrawContext2D__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./js/diagram/DrawContext2D */ "./src/js/diagram/DrawContext2D.js");
/* harmony import */ var _js_diagram_webgl_webgl__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./js/diagram/webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _js_diagram_DrawingObjects_DrawingObject__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./js/diagram/DrawingObjects/DrawingObject */ "./src/js/diagram/DrawingObjects/DrawingObject.js");
/* harmony import */ var _js_diagram_DrawingObjects_VertexObject_VertexObject__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./js/diagram/DrawingObjects/VertexObject/VertexObject */ "./src/js/diagram/DrawingObjects/VertexObject/VertexObject.js");
/* harmony import */ var _js_diagram_DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./js/diagram/DrawingObjects/TextObject/TextObject */ "./src/js/diagram/DrawingObjects/TextObject/TextObject.js");
/* harmony import */ var _js_diagram_DrawingObjects_HTMLObject_HTMLObject__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./js/diagram/DrawingObjects/HTMLObject/HTMLObject */ "./src/js/diagram/DrawingObjects/HTMLObject/HTMLObject.js");
/* harmony import */ var _js_diagram_DiagramElements_Equation_HTMLEquation__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./js/diagram/DiagramElements/Equation/HTMLEquation */ "./src/js/diagram/DiagramElements/Equation/HTMLEquation.js");
/* harmony import */ var _js_diagram_DiagramObjects_Angle__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./js/diagram/DiagramObjects/Angle */ "./src/js/diagram/DiagramObjects/Angle.js");
/* harmony import */ var _js_diagram_DiagramObjects_Line__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./js/diagram/DiagramObjects/Line */ "./src/js/diagram/DiagramObjects/Line.js");
/* harmony import */ var _js_diagram_DiagramObjects_PolyLine__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./js/diagram/DiagramObjects/PolyLine */ "./src/js/diagram/DiagramObjects/PolyLine.js");
/* harmony import */ var _js_diagram_DiagramObjects_EqnNavigator__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./js/diagram/DiagramObjects/EqnNavigator */ "./src/js/diagram/DiagramObjects/EqnNavigator.js");
/* harmony import */ var _js_diagram_DiagramObjects_EquationLabel__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./js/diagram/DiagramObjects/EquationLabel */ "./src/js/diagram/DiagramObjects/EquationLabel.js");
/* harmony import */ var _js_diagram_DiagramElements_Equation_Equation__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./js/diagram/DiagramElements/Equation/Equation */ "./src/js/diagram/DiagramElements/Equation/Equation.js");
/* harmony import */ var _js_diagram_DiagramElements_Equation_EquationForm__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./js/diagram/DiagramElements/Equation/EquationForm */ "./src/js/diagram/DiagramElements/Equation/EquationForm.js");
























/** Tools object that is so great
* @namespace tools
* @memberof module:Fig
* @property {object} math   - Math tools
* @property {object} g2     - 2D geometry tools
* @property {object} color  - Color tools
* @property {object} css    - CSS tools
*/
var tools = {
  math: _js_tools_math__WEBPACK_IMPORTED_MODULE_1__,
  g2: _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__,
  color: _js_tools_color__WEBPACK_IMPORTED_MODULE_3__,
  css: _js_tools_styleSheets__WEBPACK_IMPORTED_MODULE_6__,
  html: _js_tools_htmlGenerator__WEBPACK_IMPORTED_MODULE_4__,
  misc: _js_tools_tools__WEBPACK_IMPORTED_MODULE_5__,
  lines: _js_diagram_DrawingObjects_Geometries_lines_lines__WEBPACK_IMPORTED_MODULE_7__
};
/**
 * FigureOne entry point
 * @type {object}
 * @module Fig
 * @global
 * @property {class} {@link Diagram}      - Diagram Class
 */

var Fig = {
  tools: tools,
  Diagram: _js_diagram_Diagram__WEBPACK_IMPORTED_MODULE_2__["default"],
  //
  DiagramElement: _js_diagram_Element__WEBPACK_IMPORTED_MODULE_8__["DiagramElement"],
  DiagramElementCollection: _js_diagram_Element__WEBPACK_IMPORTED_MODULE_8__["DiagramElementCollection"],
  DiagramElementPrimitive: _js_diagram_Element__WEBPACK_IMPORTED_MODULE_8__["DiagramElementPrimitive"],
  DrawContext2D: _js_diagram_DrawContext2D__WEBPACK_IMPORTED_MODULE_9__["default"],
  WebGLInstance: _js_diagram_webgl_webgl__WEBPACK_IMPORTED_MODULE_10__["default"],
  //
  DrawingObject: _js_diagram_DrawingObjects_DrawingObject__WEBPACK_IMPORTED_MODULE_11__["default"],
  VertexObject: _js_diagram_DrawingObjects_VertexObject_VertexObject__WEBPACK_IMPORTED_MODULE_12__["default"],
  TextObject: _js_diagram_DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_13__["TextObject"],
  DiagramText: _js_diagram_DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_13__["DiagramText"],
  DiagramFont: _js_diagram_DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_13__["DiagramFont"],
  HTMLObject: _js_diagram_DrawingObjects_HTMLObject_HTMLObject__WEBPACK_IMPORTED_MODULE_14__["default"],
  //
  DiagramObjectAngle: _js_diagram_DiagramObjects_Angle__WEBPACK_IMPORTED_MODULE_16__["default"],
  DiagramObjectLine: _js_diagram_DiagramObjects_Line__WEBPACK_IMPORTED_MODULE_17__["default"],
  DiagramObjectPolyLine: _js_diagram_DiagramObjects_PolyLine__WEBPACK_IMPORTED_MODULE_18__["default"],
  EqnNavigator: _js_diagram_DiagramObjects_EqnNavigator__WEBPACK_IMPORTED_MODULE_19__["default"],
  EquationLabel: _js_diagram_DiagramObjects_EquationLabel__WEBPACK_IMPORTED_MODULE_20__["default"],
  //
  EquationForm: _js_diagram_DiagramElements_Equation_EquationForm__WEBPACK_IMPORTED_MODULE_22__["default"],
  Equation: _js_diagram_DiagramElements_Equation_Equation__WEBPACK_IMPORTED_MODULE_21__["Equation"],
  //
  HTMLEquation: _js_diagram_DiagramElements_Equation_HTMLEquation__WEBPACK_IMPORTED_MODULE_15__["default"],
  //
  Point: _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"],
  Line: _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"],
  Rect: _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"],
  Transform: _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"],
  TransformLimit: _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__["TransformLimit"],
  Translation: _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__["Translation"],
  Scale: _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__["Scale"],
  Rotation: _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rotation"],
  parsePoint: _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"]
};
/* harmony default export */ __webpack_exports__["default"] = (Fig);

/***/ }),

/***/ "./src/js/diagram/Animation/Animation.js":
/*!***********************************************!*\
  !*** ./src/js/diagram/Animation/Animation.js ***!
  \***********************************************/
/*! exports provided: PositionAnimationStep, AnimationBuilder, ParallelAnimationStep, SerialAnimationStep, TransformAnimationStep, AnimationStep, DelayStep, TriggerStep, inParallel, inSerial, trigger, delay, ColorAnimationStep, DissolveInAnimationStep, dissolveIn, DissolveOutAnimationStep, dissolveOut, CustomAnimationStep, custom, AnimationManager, RotationAnimationStep, ScaleAnimationStep, PulseAnimationStep, OpacityAnimationStep, DimAnimationStep, dim, UndimAnimationStep, undim */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _AnimationStep_ElementAnimationStep_PositionAnimationStep__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AnimationStep/ElementAnimationStep/PositionAnimationStep */ "./src/js/diagram/Animation/AnimationStep/ElementAnimationStep/PositionAnimationStep.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PositionAnimationStep", function() { return _AnimationStep_ElementAnimationStep_PositionAnimationStep__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _AnimationStep_ElementAnimationStep_ColorAnimationStep__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AnimationStep/ElementAnimationStep/ColorAnimationStep */ "./src/js/diagram/Animation/AnimationStep/ElementAnimationStep/ColorAnimationStep.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ColorAnimationStep", function() { return _AnimationStep_ElementAnimationStep_ColorAnimationStep__WEBPACK_IMPORTED_MODULE_1__["ColorAnimationStep"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DimAnimationStep", function() { return _AnimationStep_ElementAnimationStep_ColorAnimationStep__WEBPACK_IMPORTED_MODULE_1__["DimAnimationStep"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dim", function() { return _AnimationStep_ElementAnimationStep_ColorAnimationStep__WEBPACK_IMPORTED_MODULE_1__["dim"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "UndimAnimationStep", function() { return _AnimationStep_ElementAnimationStep_ColorAnimationStep__WEBPACK_IMPORTED_MODULE_1__["UndimAnimationStep"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "undim", function() { return _AnimationStep_ElementAnimationStep_ColorAnimationStep__WEBPACK_IMPORTED_MODULE_1__["undim"]; });

/* harmony import */ var _AnimationStep_ElementAnimationStep_OpacityAnimationStep__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AnimationStep/ElementAnimationStep/OpacityAnimationStep */ "./src/js/diagram/Animation/AnimationStep/ElementAnimationStep/OpacityAnimationStep.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DissolveInAnimationStep", function() { return _AnimationStep_ElementAnimationStep_OpacityAnimationStep__WEBPACK_IMPORTED_MODULE_2__["DissolveInAnimationStep"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dissolveIn", function() { return _AnimationStep_ElementAnimationStep_OpacityAnimationStep__WEBPACK_IMPORTED_MODULE_2__["dissolveIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DissolveOutAnimationStep", function() { return _AnimationStep_ElementAnimationStep_OpacityAnimationStep__WEBPACK_IMPORTED_MODULE_2__["DissolveOutAnimationStep"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dissolveOut", function() { return _AnimationStep_ElementAnimationStep_OpacityAnimationStep__WEBPACK_IMPORTED_MODULE_2__["dissolveOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "OpacityAnimationStep", function() { return _AnimationStep_ElementAnimationStep_OpacityAnimationStep__WEBPACK_IMPORTED_MODULE_2__["OpacityAnimationStep"]; });

/* harmony import */ var _AnimationStep_ElementAnimationStep_TransformAnimationStep__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AnimationStep/ElementAnimationStep/TransformAnimationStep */ "./src/js/diagram/Animation/AnimationStep/ElementAnimationStep/TransformAnimationStep.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TransformAnimationStep", function() { return _AnimationStep_ElementAnimationStep_TransformAnimationStep__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _AnimationStep_ElementAnimationStep_RotationAnimationStep__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AnimationStep/ElementAnimationStep/RotationAnimationStep */ "./src/js/diagram/Animation/AnimationStep/ElementAnimationStep/RotationAnimationStep.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RotationAnimationStep", function() { return _AnimationStep_ElementAnimationStep_RotationAnimationStep__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _AnimationStep_ElementAnimationStep_ScaleAnimationStep__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./AnimationStep/ElementAnimationStep/ScaleAnimationStep */ "./src/js/diagram/Animation/AnimationStep/ElementAnimationStep/ScaleAnimationStep.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ScaleAnimationStep", function() { return _AnimationStep_ElementAnimationStep_ScaleAnimationStep__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _AnimationStep_ElementAnimationStep_PulseAnimationStep__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./AnimationStep/ElementAnimationStep/PulseAnimationStep */ "./src/js/diagram/Animation/AnimationStep/ElementAnimationStep/PulseAnimationStep.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PulseAnimationStep", function() { return _AnimationStep_ElementAnimationStep_PulseAnimationStep__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _AnimationStep_TriggerStep__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./AnimationStep/TriggerStep */ "./src/js/diagram/Animation/AnimationStep/TriggerStep.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TriggerStep", function() { return _AnimationStep_TriggerStep__WEBPACK_IMPORTED_MODULE_7__["TriggerStep"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "trigger", function() { return _AnimationStep_TriggerStep__WEBPACK_IMPORTED_MODULE_7__["trigger"]; });

/* harmony import */ var _AnimationStep_CustomStep__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./AnimationStep/CustomStep */ "./src/js/diagram/Animation/AnimationStep/CustomStep.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CustomAnimationStep", function() { return _AnimationStep_CustomStep__WEBPACK_IMPORTED_MODULE_8__["CustomAnimationStep"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "custom", function() { return _AnimationStep_CustomStep__WEBPACK_IMPORTED_MODULE_8__["custom"]; });

/* harmony import */ var _AnimationStep_ParallelAnimationStep__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./AnimationStep/ParallelAnimationStep */ "./src/js/diagram/Animation/AnimationStep/ParallelAnimationStep.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ParallelAnimationStep", function() { return _AnimationStep_ParallelAnimationStep__WEBPACK_IMPORTED_MODULE_9__["ParallelAnimationStep"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "inParallel", function() { return _AnimationStep_ParallelAnimationStep__WEBPACK_IMPORTED_MODULE_9__["inParallel"]; });

/* harmony import */ var _AnimationStep_SerialAnimationStep__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./AnimationStep/SerialAnimationStep */ "./src/js/diagram/Animation/AnimationStep/SerialAnimationStep.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SerialAnimationStep", function() { return _AnimationStep_SerialAnimationStep__WEBPACK_IMPORTED_MODULE_10__["SerialAnimationStep"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "inSerial", function() { return _AnimationStep_SerialAnimationStep__WEBPACK_IMPORTED_MODULE_10__["inSerial"]; });

/* harmony import */ var _AnimationStep_DelayStep__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./AnimationStep/DelayStep */ "./src/js/diagram/Animation/AnimationStep/DelayStep.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DelayStep", function() { return _AnimationStep_DelayStep__WEBPACK_IMPORTED_MODULE_11__["DelayStep"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "delay", function() { return _AnimationStep_DelayStep__WEBPACK_IMPORTED_MODULE_11__["delay"]; });

/* harmony import */ var _AnimationStep__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./AnimationStep */ "./src/js/diagram/Animation/AnimationStep.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AnimationStep", function() { return _AnimationStep__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _AnimationManager__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./AnimationManager */ "./src/js/diagram/Animation/AnimationManager.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AnimationManager", function() { return _AnimationManager__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _AnimationBuilder__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./AnimationBuilder */ "./src/js/diagram/Animation/AnimationBuilder.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AnimationBuilder", function() { return _AnimationBuilder__WEBPACK_IMPORTED_MODULE_14__["default"]; });














// eslint-disable-next-line import/no-cycle

// eslint-disable-next-line import/no-cycle



/***/ }),

/***/ "./src/js/diagram/Animation/AnimationBuilder.js":
/*!******************************************************!*\
  !*** ./src/js/diagram/Animation/AnimationBuilder.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AnimationBuilder; });
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _Animation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Animation */ "./src/js/diagram/Animation/Animation.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

// import * as tools from '../../tools/math';
// eslint-disable-next-line import/no-cycle

// import PositionAnimationStep from './AnimationStep/ElementAnimationStep/PositionAnimationStep';
// import SerialAnimationStep from './AnimationStep/SerialAnimationStep';
// eslint-disable-next-line import/no-cycle



var AnimationBuilder =
/*#__PURE__*/
function (_animation$SerialAnim) {
  _inherits(AnimationBuilder, _animation$SerialAnim);

  function AnimationBuilder() {
    var _this;

    var elementOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, AnimationBuilder);

    var defaultOptions = {};
    var options;

    for (var _len = arguments.length, optionsIn = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      optionsIn[_key - 1] = arguments[_key];
    }

    if (elementOrOptionsIn instanceof _Element__WEBPACK_IMPORTED_MODULE_0__["DiagramElement"]) {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));
      options.element = elementOrOptionsIn;
    } else {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions, elementOrOptionsIn].concat(optionsIn));
    }

    _this = _possibleConstructorReturn(this, _getPrototypeOf(AnimationBuilder).call(this, options));
    _this.element = options.element;
    return _possibleConstructorReturn(_this, _assertThisInitialized(_this));
  }

  _createClass(AnimationBuilder, [{
    key: "custom",
    value: function custom() {
      for (var _len2 = arguments.length, optionsIn = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        optionsIn[_key2] = arguments[_key2];
      }

      this.then(_construct(_Animation__WEBPACK_IMPORTED_MODULE_1__["CustomAnimationStep"], optionsIn));
      return this;
    }
  }, {
    key: "rotation",
    value: function rotation() {
      if (this.element != null) {
        var defaultOptions = {
          element: this.element
        };

        for (var _len3 = arguments.length, optionsIn = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          optionsIn[_key3] = arguments[_key3];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));
        this.then(new _Animation__WEBPACK_IMPORTED_MODULE_1__["RotationAnimationStep"](options));
      }

      return this;
    }
  }, {
    key: "position",
    value: function position() {
      if (this.element != null) {
        var defaultOptions = {
          element: this.element
        };

        for (var _len4 = arguments.length, optionsIn = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          optionsIn[_key4] = arguments[_key4];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));
        this.then(new _Animation__WEBPACK_IMPORTED_MODULE_1__["PositionAnimationStep"](options));
      }

      return this;
    }
  }, {
    key: "scale",
    value: function scale() {
      if (this.element != null) {
        var defaultOptions = {
          element: this.element
        };

        for (var _len5 = arguments.length, optionsIn = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          optionsIn[_key5] = arguments[_key5];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));
        this.then(new _Animation__WEBPACK_IMPORTED_MODULE_1__["ScaleAnimationStep"](options));
      }

      return this;
    } // moveTo(...optionsIn: Array<TypePositionAnimationStepInputOptions>) {
    //   return this.moveToPosition(...optionsIn);
    // }
    // positionTo(...optionsIn: Array<TypePositionAnimationStepInputOptions>) {
    //   return this.moveToPosition(...optionsIn);
    // }

  }, {
    key: "transform",
    value: function transform() {
      if (this.element != null) {
        var defaultOptions = {
          element: this.element
        };

        for (var _len6 = arguments.length, optionsIn = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
          optionsIn[_key6] = arguments[_key6];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));
        this.then(new _Animation__WEBPACK_IMPORTED_MODULE_1__["TransformAnimationStep"](options));
      }

      return this;
    }
  }, {
    key: "scenario",
    value: function scenario() {
      if (this.element != null) {
        var defaultOptions = {
          element: this.element
        };

        for (var _len7 = arguments.length, optionsIn = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
          optionsIn[_key7] = arguments[_key7];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));
        this.then(options.element.anim.scenario(options));
      }

      return this;
    }
  }, {
    key: "scenarios",
    value: function scenarios() {
      if (this.element != null) {
        var defaultOptions = {
          element: this.element
        };

        for (var _len8 = arguments.length, optionsIn = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
          optionsIn[_key8] = arguments[_key8];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));
        this.then(options.element.anim.scenarios(options));
      }

      return this;
    }
  }, {
    key: "color",
    value: function color() {
      if (this.element != null) {
        var defaultOptions = {
          element: this.element
        };

        for (var _len9 = arguments.length, optionsIn = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
          optionsIn[_key9] = arguments[_key9];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));
        this.then(new _Animation__WEBPACK_IMPORTED_MODULE_1__["ColorAnimationStep"](options));
      }

      return this;
    }
  }, {
    key: "opacity",
    value: function opacity() {
      if (this.element != null) {
        var defaultOptions = {
          element: this.element
        };

        for (var _len10 = arguments.length, optionsIn = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
          optionsIn[_key10] = arguments[_key10];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));
        this.then(new _Animation__WEBPACK_IMPORTED_MODULE_1__["OpacityAnimationStep"](options));
      }

      return this;
    }
  }, {
    key: "dissolveOut",
    value: function dissolveOut() {
      var timeOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var defaultOptions = {
        element: this.element
      };
      var options;

      for (var _len11 = arguments.length, args = new Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {
        args[_key11 - 1] = arguments[_key11];
      }

      if (typeof timeOrOptionsIn === 'number') {
        options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions, {
          duration: timeOrOptionsIn
        }].concat(args));
      } else {
        options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions, timeOrOptionsIn].concat(args));
      }

      this.then(_Animation__WEBPACK_IMPORTED_MODULE_1__["dissolveOut"](options));
      return this;
    }
  }, {
    key: "dissolveIn",
    value: function dissolveIn() {
      var timeOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var defaultOptions = {
        element: this.element
      };
      var options;

      for (var _len12 = arguments.length, args = new Array(_len12 > 1 ? _len12 - 1 : 0), _key12 = 1; _key12 < _len12; _key12++) {
        args[_key12 - 1] = arguments[_key12];
      }

      if (typeof timeOrOptionsIn === 'number') {
        options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions, {
          duration: timeOrOptionsIn
        }].concat(args));
      } else {
        options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions, timeOrOptionsIn].concat(args));
      }

      this.then(_Animation__WEBPACK_IMPORTED_MODULE_1__["dissolveIn"](options));
      return this;
    }
  }, {
    key: "dim",
    value: function dim() {
      var timeOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var defaultOptions = {
        element: this.element
      };
      var options;

      for (var _len13 = arguments.length, args = new Array(_len13 > 1 ? _len13 - 1 : 0), _key13 = 1; _key13 < _len13; _key13++) {
        args[_key13 - 1] = arguments[_key13];
      }

      if (typeof timeOrOptionsIn === 'number') {
        options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions, {
          duration: timeOrOptionsIn
        }].concat(args));
      } else {
        options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions, timeOrOptionsIn].concat(args));
      }

      this.then(_Animation__WEBPACK_IMPORTED_MODULE_1__["dim"](options));
      return this;
    }
  }, {
    key: "undim",
    value: function undim() {
      var timeOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var defaultOptions = {
        element: this.element
      };
      var options;

      for (var _len14 = arguments.length, args = new Array(_len14 > 1 ? _len14 - 1 : 0), _key14 = 1; _key14 < _len14; _key14++) {
        args[_key14 - 1] = arguments[_key14];
      }

      if (typeof timeOrOptionsIn === 'number') {
        options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions, {
          duration: timeOrOptionsIn
        }].concat(args));
      } else {
        options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions, timeOrOptionsIn].concat(args));
      }

      this.then(_Animation__WEBPACK_IMPORTED_MODULE_1__["undim"](options));
      return this;
    }
  }, {
    key: "delay",
    value: function delay() {
      var numOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      for (var _len15 = arguments.length, args = new Array(_len15 > 1 ? _len15 - 1 : 0), _key15 = 1; _key15 < _len15; _key15++) {
        args[_key15 - 1] = arguments[_key15];
      }

      this.then(_Animation__WEBPACK_IMPORTED_MODULE_1__["delay"].apply(_Animation__WEBPACK_IMPORTED_MODULE_1__, [numOrOptionsIn].concat(args)));
      return this;
    }
  }, {
    key: "trigger",
    value: function trigger() {
      var triggerOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      for (var _len16 = arguments.length, optionsIn = new Array(_len16 > 1 ? _len16 - 1 : 0), _key16 = 1; _key16 < _len16; _key16++) {
        optionsIn[_key16 - 1] = arguments[_key16];
      }

      this.then(_Animation__WEBPACK_IMPORTED_MODULE_1__["trigger"].apply(_Animation__WEBPACK_IMPORTED_MODULE_1__, [triggerOrOptionsIn].concat(optionsIn)));
      return this;
    }
  }, {
    key: "inParallel",
    value: function inParallel() {
      var stepsOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      for (var _len17 = arguments.length, optionsIn = new Array(_len17 > 1 ? _len17 - 1 : 0), _key17 = 1; _key17 < _len17; _key17++) {
        optionsIn[_key17 - 1] = arguments[_key17];
      }

      this.then(_Animation__WEBPACK_IMPORTED_MODULE_1__["inParallel"].apply(_Animation__WEBPACK_IMPORTED_MODULE_1__, [stepsOrOptionsIn].concat(optionsIn)));
      return this;
    }
  }, {
    key: "inSerial",
    value: function inSerial() {
      var stepsOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      for (var _len18 = arguments.length, optionsIn = new Array(_len18 > 1 ? _len18 - 1 : 0), _key18 = 1; _key18 < _len18; _key18++) {
        optionsIn[_key18 - 1] = arguments[_key18];
      }

      this.then(_Animation__WEBPACK_IMPORTED_MODULE_1__["inSerial"].apply(_Animation__WEBPACK_IMPORTED_MODULE_1__, [stepsOrOptionsIn].concat(optionsIn)));
      return this;
    }
  }, {
    key: "pulse",
    value: function pulse() {
      var defaultOptions = {
        element: this.element
      };

      for (var _len19 = arguments.length, optionsIn = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {
        optionsIn[_key19] = arguments[_key19];
      }

      var options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));
      this.then(new _Animation__WEBPACK_IMPORTED_MODULE_1__["PulseAnimationStep"](options));
      return this;
    }
  }, {
    key: "reset",
    value: function reset() {
      this.steps = [];
      this.state = 'idle';
    } // whenFinished(callback: (boolean) => void) {
    //   super.whenFinished(callback);
    //   return this;
    // }

  }, {
    key: "_dup",
    value: function _dup() {
      var newBuilder = new AnimationBuilder();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["duplicateFromTo"])(this, newBuilder, ['element']);
      newBuilder.element = this.element;
      return newBuilder;
    }
  }]);

  return AnimationBuilder;
}(_Animation__WEBPACK_IMPORTED_MODULE_1__["SerialAnimationStep"]);



/***/ }),

/***/ "./src/js/diagram/Animation/AnimationManager.js":
/*!******************************************************!*\
  !*** ./src/js/diagram/Animation/AnimationManager.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AnimationManager; });
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _Animation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Animation */ "./src/js/diagram/Animation/Animation.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// import * as tools from '../../tools/math';
// eslint-disable-next-line import/no-cycle
 // import type { TypeSerialAnimationStepInputOptions } from './AnimationStep/SerialAnimationStep';
// import type {
//   TypePositionAnimationStepInputOptions, TypeParallelAnimationStepInputOptions,
//   TypeDelayStepInputOptions, TypeTriggerStepInputOptions,
//   TypeColorAnimationStepInputOptions, TypeCustomAnimationStepInputOptions,
// } from './Animation';
// eslint-disable-next-line import/no-cycle




var AnimationManager =
/*#__PURE__*/
function () {
  function AnimationManager() {
    var elementOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, AnimationManager);

    var defaultOptions = {};
    var options;

    for (var _len = arguments.length, optionsIn = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      optionsIn[_key - 1] = arguments[_key];
    }

    if (elementOrOptionsIn instanceof _Element__WEBPACK_IMPORTED_MODULE_0__["DiagramElement"]) {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));
      options.element = elementOrOptionsIn;
    } else {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions, elementOrOptionsIn].concat(optionsIn));
    }

    this.element = options.element;
    this.animations = [];
    this.state = 'idle'; // $FlowFixMe

    this.options = {
      translation: {}
    };
    return this;
  }

  _createClass(AnimationManager, [{
    key: "willStartAnimating",
    value: function willStartAnimating() {
      if (this.state === 'animating') {
        return true;
      }

      var isAnimating = false;
      this.animations.forEach(function (animation) {
        if (animation.state === 'waitingToStart' || animation.state === 'animating') {
          isAnimating = true;
        }
      });
      return isAnimating;
    }
  }, {
    key: "nextFrame",
    value: function nextFrame(now) {
      // console.log('animation manager', now)
      var animationsToRemove = [];
      var remaining = null;
      var isAnimating = false;
      this.animations.forEach(function (animation, index) {
        var animationIsAnimating = false;

        if (animation.state === 'waitingToStart' || animation.state === 'animating') {
          var stepRemaining = animation.nextFrame(now);

          if (remaining === null) {
            remaining = stepRemaining;
          }

          if (stepRemaining < remaining) {
            remaining = stepRemaining;
          }

          animationIsAnimating = true;
        }

        if (animation.state === 'finished' && animation.removeOnFinish) {
          animationIsAnimating = false;
          animationsToRemove.push(index);
        }

        if (animationIsAnimating) {
          isAnimating = true;
        }
      });

      if (isAnimating) {
        this.state = 'animating';
      } else {
        this.state = 'idle';
      }

      for (var i = animationsToRemove.length - 1; i >= 0; i -= 1) {
        this.animations.splice(animationsToRemove[i], 1);
      } // if (initialState !== 'animating' && this.state === 'animating') {
      //   if (this.element != null) {
      //     this.element.unrender();
      //   }
      // }


      return remaining;
    }
  }, {
    key: "cleanAnimations",
    value: function cleanAnimations() {
      var animationsToRemove = [];
      var isAnimating = false;

      for (var i = 0; i < this.animations.length; i += 1) {
        var animation = this.animations[i];

        if (animation.state === 'finished' && animation.removeOnFinish) {
          animationsToRemove.push(i);
        } else {
          isAnimating = true;
        }
      }

      for (var _i = animationsToRemove.length - 1; _i >= 0; _i -= 1) {
        this.animations.splice(animationsToRemove[_i], 1);
      }

      if (isAnimating) {
        this.state = 'animating';
      } else {
        this.state = 'idle';
      }
    } // Cancel all primary animations with the name
    // animations will be cleaned up on next frame

  }, {
    key: "cancel",
    value: function cancel(name) {
      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (name == null) {
        this.cancelAll(force);
      } else {
        for (var i = 0; i < this.animations.length; i += 1) {
          var animation = this.animations[i];

          if (animation.name === name) {
            animation.cancel(force);
          }
        }

        this.cleanAnimations();
      }
    }
  }, {
    key: "cancelAll",
    value: function cancelAll() {
      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      for (var i = 0; i < this.animations.length; i += 1) {
        this.animations[i].cancel(force);
      }

      this.cleanAnimations();
    }
  }, {
    key: "start",
    value: function start(name) {
      if (name == null) {
        this.startAll();
      } else {
        for (var i = 0; i < this.animations.length; i += 1) {
          var animation = this.animations[i];

          if (animation.name === name) {
            if (animation.state !== 'animating') {
              animation.start();
              animation.finishIfZeroDuration();

              if (animation.state === 'animating') {
                this.state = 'animating';
              }
            }
          }
        }
      }
    }
  }, {
    key: "startAll",
    value: function startAll() {
      for (var i = 0; i < this.animations.length; i += 1) {
        var animation = this.animations[i];

        if (animation.state !== 'animating') {
          animation.start();
          animation.finishIfZeroDuration();

          if (animation.state === 'animating') {
            this.state = 'animating';
          }
        }
      }
    }
  }, {
    key: "addTo",
    value: function addTo(name) {
      for (var i = 0; i < this.animations.length; i += 1) {
        var animation = this.animations[i];

        if (animation.name === name) {
          return animation;
        }
      }

      return this["new"](name);
    }
  }, {
    key: "new",
    value: function _new(nameOrStep) {
      if (typeof nameOrStep === 'string' || nameOrStep == null) {
        var options = {};

        if (this.element != null) {
          options.element = this.element;
        }

        if (nameOrStep != null) {
          options.name = nameOrStep;
        }

        var animation = new _Animation__WEBPACK_IMPORTED_MODULE_1__["AnimationBuilder"](options);
        this.animations.push(animation);
        return animation;
      }

      if (nameOrStep != null) {
        this.animations.push(nameOrStep);
      }

      return nameOrStep;
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var newManager = new AnimationManager();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["duplicateFromTo"])(this, newManager, ['element']);
      newManager.element = this.element;
      return newManager;
    }
  }]);

  return AnimationManager;
}();



/***/ }),

/***/ "./src/js/diagram/Animation/AnimationStep.js":
/*!***************************************************!*\
  !*** ./src/js/diagram/Animation/AnimationStep.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AnimationStep; });
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// import {
//   Transform, Point,
//   Rotation, getDeltaAngle, getMaxTimeFromVelocity,
// } from '../tools/g2';
// import * as tools from '../tools/math';
// import type { pathOptionsType } from '../tools/g2';
// eslint-disable-next-line import/no-cycle
// import { DiagramElement } from './Element';


var AnimationStep =
/*#__PURE__*/
function () {
  // animations: Array<AnimationStep>;
  function AnimationStep() {
    var optionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, AnimationStep);

    var defaultOptions = {
      onFinish: null,
      completeOnCancel: null,
      removeOnFinish: true,
      name: Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["generateRandomString"])(),
      duration: 0,
      delay: 0,
      beforeFrame: null,
      afterFrame: null
    };
    var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"])({}, defaultOptions, optionsIn);
    this.onFinish = options.onFinish;
    this.completeOnCancel = options.completeOnCancel;
    this.duration = options.duration;
    this.startTime = -1;
    this.state = 'idle';
    this.name = options.name;
    this.afterFrame = options.afterFrame;
    this.beforeFrame = options.beforeFrame;
    this.startDelay = options.delay; // This is only for it this step is a primary path in an Animation Manager

    this.removeOnFinish = options.removeOnFinish; // Each animation frame will typically calculate a percent complete,
    // which is based on the duration, and from the percent complete calculate
    // the position of the current animation.
    // However, if you want to start an animation not from 0 percent, then this
    // value can be used. When startTimeOffset != 0, then the first frame
    // will be calculated at this.progression(startTimeOffset). The animation
    // will still go to 1, but will be reduced in duration by startTimeOffset.
    // When progressions aren't linear, then this time is non-trival.

    this.startTimeOffset = 0;
    return this;
  } // returns remaining time if this step completes
  // Return of 0 means this step is still going


  _createClass(AnimationStep, [{
    key: "nextFrame",
    value: function nextFrame(now) {
      if (this.startTime === -1) {
        this.startTime = now - this.startTimeOffset;
      }

      var deltaTime = now - this.startTime;
      var remainingTime = -(this.duration + this.startDelay - deltaTime);

      if (deltaTime >= this.startDelay) {
        var deltaTimeAfterDelay = deltaTime - this.startDelay;

        if (deltaTimeAfterDelay >= this.duration) {
          remainingTime = deltaTimeAfterDelay - this.duration;
          deltaTimeAfterDelay = this.duration;
        }

        if (this.beforeFrame) {
          this.beforeFrame(deltaTimeAfterDelay / this.duration);
        }

        this.setFrame(deltaTimeAfterDelay);

        if (this.afterFrame) {
          this.afterFrame(deltaTimeAfterDelay / this.duration);
        }

        if (remainingTime >= 0) {
          this.finish();
        }
      }

      return remainingTime;
    } // eslint-disable-next-line class-methods-use-this, no-unused-vars

  }, {
    key: "setFrame",
    value: function setFrame(deltaTime) {}
  }, {
    key: "startWaiting",
    value: function startWaiting() {
      this.state = 'waitingToStart';
    } // eslint-disable-next-line class-methods-use-this, no-unused-vars

  }, {
    key: "start",
    value: function start() {
      var startTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;
      this.startTime = startTime;
      this.state = 'animating';
    }
  }, {
    key: "finishIfZeroDuration",
    value: function finishIfZeroDuration() {
      if (this.duration === 0 && this.startDelay === 0) {
        this.finish();
      }
    } // eslint-disable-next-line class-methods-use-this, no-unused-vars

  }, {
    key: "setToEnd",
    value: function setToEnd() {} // eslint-disable-next-line class-methods-use-this, no-unused-vars

  }, {
    key: "finish",
    value: function finish() {
      var cancelled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      // this.startTime = -2;
      // this.onFinish(false);
      if (this.state === 'idle' || this.state === 'finished') {
        return;
      }

      var oldState = this.state;
      this.state = 'finished';

      if (cancelled) {
        if (force === 'complete') {
          if (oldState === 'waitingToStart') {
            this.start();
          }

          this.setToEnd();
        } else if (force == null && this.completeOnCancel === true) {
          if (oldState === 'waitingToStart') {
            this.start();
          }

          this.setToEnd();
        } else if (oldState === 'waitingToStart') {
          this.cancelledWithNoComplete();
        }
      }

      if (cancelled === false) {
        if (oldState === 'waitingToStart') {
          this.start();
        }

        this.setToEnd();
      }

      if (this.onFinish != null) {
        this.onFinish(cancelled);
      }
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "cancelledWithNoComplete",
    value: function cancelledWithNoComplete() {}
  }, {
    key: "cancel",
    value: function cancel() {
      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      this.finish(true, force);
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var step = new AnimationStep();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["duplicateFromTo"])(this, step);
      return step;
    }
  }, {
    key: "whenFinished",
    value: function whenFinished(callback) {
      this.onFinish = callback;
      return this;
    }
  }, {
    key: "ifCanceledThenComplete",
    value: function ifCanceledThenComplete() {
      this.completeOnCancel = true;
      return this;
    }
  }, {
    key: "ifCanceledThenStop",
    value: function ifCanceledThenStop() {
      this.completeOnCancel = false;
      return this;
    }
  }]);

  return AnimationStep;
}();



/***/ }),

/***/ "./src/js/diagram/Animation/AnimationStep/CustomStep.js":
/*!**************************************************************!*\
  !*** ./src/js/diagram/Animation/AnimationStep/CustomStep.js ***!
  \**************************************************************/
/*! exports provided: CustomAnimationStep, custom */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CustomAnimationStep", function() { return CustomAnimationStep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "custom", function() { return custom; });
/* harmony import */ var _tools_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/math */ "./src/js/tools/math.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _AnimationStep__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../AnimationStep */ "./src/js/diagram/Animation/AnimationStep.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }




var CustomAnimationStep =
/*#__PURE__*/
function (_AnimationStep) {
  _inherits(CustomAnimationStep, _AnimationStep);

  function CustomAnimationStep() {
    var _this;

    _classCallCheck(this, CustomAnimationStep);

    for (var _len = arguments.length, optionsIn = new Array(_len), _key = 0; _key < _len; _key++) {
      optionsIn[_key] = arguments[_key];
    }

    var AnimationStepOptionsIn = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}].concat(optionsIn));
    _this = _possibleConstructorReturn(this, _getPrototypeOf(CustomAnimationStep).call(this, AnimationStepOptionsIn));
    var defaultPositionOptions = {
      callback: null,
      startPercent: 0,
      progression: 'linear'
    };
    var options = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, defaultPositionOptions].concat(optionsIn));

    if (options.progression === 'linear') {
      _this.progression = _tools_math__WEBPACK_IMPORTED_MODULE_0__["linear"];
    } else if (options.progression === 'easein') {
      _this.progression = _tools_math__WEBPACK_IMPORTED_MODULE_0__["easein"];
    } else if (options.progression === 'easeout') {
      _this.progression = _tools_math__WEBPACK_IMPORTED_MODULE_0__["easeout"];
    } else if (options.progression === 'easeinout') {
      _this.progression = _tools_math__WEBPACK_IMPORTED_MODULE_0__["easeinout"];
    } else {
      _this.progression = options.progression;
    }

    _this.callback = options.callback;
    _this.startPercent = options.startPercent;

    if (typeof _this.progression === 'function') {
      _this.startTimeOffset = _this.progression(options.startPercent, true) * options.duration;
    }

    _this.duration = options.duration;
    return _this;
  }

  _createClass(CustomAnimationStep, [{
    key: "setFrame",
    value: function setFrame(deltaTime) {
      var percentTime = deltaTime / this.duration;
      var percentComplete = this.progression(percentTime);

      if (this.callback != null) {
        this.callback(percentComplete);
      }
    }
  }, {
    key: "setToEnd",
    value: function setToEnd() {
      if (this.callback != null) {
        this.callback(1);
      }
    } // finish(cancelled: boolean = false, force: ?'complete' | 'noComplete' = null) {
    //   if (this.state === 'idle') {
    //     return;
    //   }
    //   super.finish(cancelled, force);
    //   const setToEnd = () => {
    //     if (this.callback != null) {
    //       this.callback(1);
    //     }
    //   };
    //   if (cancelled && force === 'complete') {
    //     setToEnd();
    //   }
    //   if (cancelled && force == null && this.completeOnCancel === true) {
    //     setToEnd();
    //   }
    //   if (cancelled === false) {
    //     setToEnd();
    //   }
    //   if (this.onFinish != null) {
    //     this.onFinish(cancelled);
    //   }
    // }

  }, {
    key: "_dup",
    value: function _dup() {
      var step = new CustomAnimationStep();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["duplicateFromTo"])(this, step);
      return step;
    }
  }]);

  return CustomAnimationStep;
}(_AnimationStep__WEBPACK_IMPORTED_MODULE_2__["default"]);
function custom() {
  for (var _len2 = arguments.length, optionsIn = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    optionsIn[_key2] = arguments[_key2];
  }

  return _construct(CustomAnimationStep, optionsIn);
}

/***/ }),

/***/ "./src/js/diagram/Animation/AnimationStep/DelayStep.js":
/*!*************************************************************!*\
  !*** ./src/js/diagram/Animation/AnimationStep/DelayStep.js ***!
  \*************************************************************/
/*! exports provided: DelayStep, delay */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DelayStep", function() { return DelayStep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "delay", function() { return delay; });
/* harmony import */ var _AnimationStep__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AnimationStep */ "./src/js/diagram/Animation/AnimationStep.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tools/tools */ "./src/js/tools/tools.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

// import * as tools from '../../tools/math';
// import { DiagramElement } from '../Element';


// Animations get started from a parent, but finish themselves
var DelayStep =
/*#__PURE__*/
function (_AnimationStep) {
  _inherits(DelayStep, _AnimationStep);

  function DelayStep() {
    var numOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, DelayStep);

    var options = {};
    var defaultOptions = {
      duration: 0
    };

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    if (typeof numOrOptionsIn === 'number') {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, defaultOptions, {
        duration: numOrOptionsIn
      }].concat(args));
    } else {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, defaultOptions, numOrOptionsIn].concat(args));
    }

    return _possibleConstructorReturn(this, _getPrototypeOf(DelayStep).call(this, options)); // this.duration = options.duration;
  }

  _createClass(DelayStep, [{
    key: "_dup",
    value: function _dup() {
      var dup = new DelayStep();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["duplicateFromTo"])(this, dup);
      return dup;
    }
  }]);

  return DelayStep;
}(_AnimationStep__WEBPACK_IMPORTED_MODULE_0__["default"]);
function delay() {
  var numOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }

  return _construct(DelayStep, [numOrOptionsIn].concat(args));
}

/***/ }),

/***/ "./src/js/diagram/Animation/AnimationStep/ElementAnimationStep.js":
/*!************************************************************************!*\
  !*** ./src/js/diagram/Animation/AnimationStep/ElementAnimationStep.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ElementAnimationStep; });
/* harmony import */ var _tools_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/math */ "./src/js/tools/math.js");
/* harmony import */ var _AnimationStep__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../AnimationStep */ "./src/js/diagram/Animation/AnimationStep.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../tools/tools */ "./src/js/tools/tools.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

 // import { DiagramElement } from '../../Element';




var ElementAnimationStep =
/*#__PURE__*/
function (_AnimationStep) {
  _inherits(ElementAnimationStep, _AnimationStep);

  function ElementAnimationStep() {
    var _this;

    var optionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, ElementAnimationStep);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ElementAnimationStep).call(this, optionsIn));
    var defaultProgression = 'easeinout';

    if (optionsIn.type === 'color' || optionsIn.type === 'custom') {
      defaultProgression = 'linear';
    }

    var defaultOptions = {
      element: null,
      type: 'custom',
      progression: defaultProgression,
      duration: 0
    };
    var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, defaultOptions, optionsIn);
    _this.element = options.element;
    _this.type = options.type;
    _this.onFinish = options.onFinish;
    _this.duration = options.duration;

    if (options.progression === 'linear') {
      _this.progression = _tools_math__WEBPACK_IMPORTED_MODULE_0__["linear"];
    } else if (options.progression === 'easein') {
      _this.progression = _tools_math__WEBPACK_IMPORTED_MODULE_0__["easein"];
    } else if (options.progression === 'easeout') {
      _this.progression = _tools_math__WEBPACK_IMPORTED_MODULE_0__["easeout"];
    } else if (options.progression === 'easeinout') {
      _this.progression = _tools_math__WEBPACK_IMPORTED_MODULE_0__["easeinout"];
    } else {
      _this.progression = options.progression;
    }

    return _this;
  }

  _createClass(ElementAnimationStep, [{
    key: "_dup",
    value: function _dup() {
      var step = new ElementAnimationStep();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["duplicateFromTo"])(this, step, ['element']);
      step.element = this.element;
      return step;
    }
  }]);

  return ElementAnimationStep;
}(_AnimationStep__WEBPACK_IMPORTED_MODULE_1__["default"]);



/***/ }),

/***/ "./src/js/diagram/Animation/AnimationStep/ElementAnimationStep/ColorAnimationStep.js":
/*!*******************************************************************************************!*\
  !*** ./src/js/diagram/Animation/AnimationStep/ElementAnimationStep/ColorAnimationStep.js ***!
  \*******************************************************************************************/
/*! exports provided: ColorAnimationStep, DimAnimationStep, dim, UndimAnimationStep, undim */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorAnimationStep", function() { return ColorAnimationStep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DimAnimationStep", function() { return DimAnimationStep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dim", function() { return dim; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UndimAnimationStep", function() { return UndimAnimationStep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "undim", function() { return undim; });
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _ElementAnimationStep__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ElementAnimationStep */ "./src/js/diagram/Animation/AnimationStep/ElementAnimationStep.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

// import {
//   Transform, Point, getMaxTimeFromVelocity,
// } from '../../../../tools/g2';



var addColors = function addColors(color1, color2) {
  return color1.map(function (c, index) {
    return Math.min(c + color2[index], 1);
  });
};

var subtractColors = function subtractColors(color1, color2) {
  return color1.map(function (c, index) {
    return c - color2[index];
  });
};

var ColorAnimationStep =
/*#__PURE__*/
function (_ElementAnimationStep) {
  _inherits(ColorAnimationStep, _ElementAnimationStep);

  function ColorAnimationStep() {
    var _this;

    _classCallCheck(this, ColorAnimationStep);

    for (var _len = arguments.length, optionsIn = new Array(_len), _key = 0; _key < _len; _key++) {
      optionsIn[_key] = arguments[_key];
    }

    var ElementAnimationStepOptionsIn = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}].concat(optionsIn, [{
      type: 'color'
    }]));
    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["deleteKeys"])(ElementAnimationStepOptionsIn, ['start', 'delta', 'target', 'dissolve']);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(ColorAnimationStep).call(this, ElementAnimationStepOptionsIn));
    var defaultPositionOptions = {
      start: null,
      target: null,
      delta: null,
      dissolve: null
    };
    var options = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}, defaultPositionOptions].concat(optionsIn)); // $FlowFixMe

    _this.color = {};
    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["copyKeysFromTo"])(options, _this.color, ['start', 'delta', 'target', 'dissolve']);

    if (_this.color.target === 'dim') {
      if (_this.element != null) {
        _this.color.target = _this.element.dimColor.slice();
      }

      _this.color.setDefault = false;
    } else if (_this.color.target === 'undim') {
      if (_this.element != null) {
        _this.color.target = _this.element.defaultColor.slice();
      }

      _this.color.setDefault = false;
    } else {
      _this.color.setDefault = true;
    }

    return _this;
  } // On start, calculate the duration, target and delta if not already present.
  // This is done here in case the start is defined as null meaning it is
  // going to start from present transform.
  // Setting a duration to 0 will effectively skip this animation step


  _createClass(ColorAnimationStep, [{
    key: "start",
    value: function start(startTime) {
      var element = this.element;

      if (element != null) {
        _get(_getPrototypeOf(ColorAnimationStep.prototype), "start", this).call(this, startTime);

        if (this.color.start == null) {
          this.color.start = element.color.slice();
        }

        if (this.color.delta == null && this.color.target == null) {
          this.color.target = this.color.start.slice();
        } else if (this.color.delta != null) {
          this.color.target = addColors(this.color.start, this.color.delta);
        }

        this.color.whenComplete = this.color.target.slice();

        if (this.color.dissolve === 'out') {
          this.color.target[3] = 0.001;
        }

        if (this.color.dissolve === 'in') {
          this.color.start[3] = 0.001;
          element.setColor(this.color.start, this.color.setDefault);
          element.showAll();
        }

        this.color.delta = subtractColors(this.color.target, this.color.start);
      } else {
        this.duration = 0;
      }
    }
  }, {
    key: "setFrame",
    value: function setFrame(deltaTime) {
      var _this2 = this;

      var percentTime = deltaTime / this.duration;
      var percentComplete = this.progression(percentTime);
      var p = percentComplete;
      var next = this.color.start.map(function (c, index) {
        var newColor = c + _this2.color.delta[index] * p;

        if (newColor > 1) {
          newColor = 1;
        }

        if (newColor < 0) {
          newColor = 0;
        }

        return newColor;
      });

      if (this.element != null) {
        this.element.setColor(next, this.color.setDefault);
      }
    }
  }, {
    key: "setToEnd",
    value: function setToEnd() {
      var element = this.element;

      if (element != null) {
        // console.log(this.name, this.color.whenComplete)
        element.setColor(this.color.whenComplete, this.color.setDefault);

        if (this.color.dissolve === 'out') {
          element.hide();
        }
      }
    } // finish(cancelled: boolean = false, force: ?'complete' | 'noComplete' = null) {
    //   if (this.state === 'idle') {
    //     return;
    //   }
    //   super.finish(cancelled, force);
    //   const setToEnd = () => {
    //     const { element } = this;
    //     if (element != null) {
    //       element.setColor(this.color.whenComplete);
    //       if (this.color.dissolve === 'out') {
    //         element.hide();
    //       }
    //     }
    //   };
    //   if (cancelled && force === 'complete') {
    //     setToEnd();
    //   }
    //   if (cancelled && force == null && this.completeOnCancel === true) {
    //     setToEnd();
    //   }
    //   if (cancelled === false) {
    //     setToEnd();
    //   }
    //   if (this.onFinish != null) {
    //     this.onFinish(cancelled);
    //   }
    // }

  }, {
    key: "_dup",
    value: function _dup() {
      var step = new ColorAnimationStep();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["duplicateFromTo"])(this, step, ['element']);
      step.element = this.element;
      return step;
    }
  }]);

  return ColorAnimationStep;
}(_ElementAnimationStep__WEBPACK_IMPORTED_MODULE_1__["default"]);
var DimAnimationStep =
/*#__PURE__*/
function (_ColorAnimationStep) {
  _inherits(DimAnimationStep, _ColorAnimationStep);

  function DimAnimationStep() {
    var timeOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, DimAnimationStep);

    var options = {};
    var defaultOptions = {
      duration: 1,
      target: 'dim',
      completeOnCancel: true
    };

    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    if (typeof timeOrOptionsIn === 'number') {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}, defaultOptions, {
        duration: timeOrOptionsIn
      }].concat(args));
    } else {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}, defaultOptions, timeOrOptionsIn].concat(args));
    }

    return _possibleConstructorReturn(this, _getPrototypeOf(DimAnimationStep).call(this, options));
  }

  return DimAnimationStep;
}(ColorAnimationStep);
function dim() {
  var timeOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    args[_key3 - 1] = arguments[_key3];
  }

  return _construct(DimAnimationStep, [timeOrOptionsIn].concat(args));
}
var UndimAnimationStep =
/*#__PURE__*/
function (_ColorAnimationStep2) {
  _inherits(UndimAnimationStep, _ColorAnimationStep2);

  function UndimAnimationStep() {
    var timeOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, UndimAnimationStep);

    var options = {};
    var defaultOptions = {
      duration: 1,
      target: 'undim',
      completeOnCancel: true
    };

    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
      args[_key4 - 1] = arguments[_key4];
    }

    if (typeof timeOrOptionsIn === 'number') {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}, defaultOptions, {
        duration: timeOrOptionsIn
      }].concat(args));
    } else {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}, defaultOptions, timeOrOptionsIn].concat(args));
    }

    return _possibleConstructorReturn(this, _getPrototypeOf(UndimAnimationStep).call(this, options));
  }

  return UndimAnimationStep;
}(ColorAnimationStep);
function undim() {
  var timeOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
    args[_key5 - 1] = arguments[_key5];
  }

  return _construct(UndimAnimationStep, [timeOrOptionsIn].concat(args));
} // export class DissolveInAnimationStep extends ColorAnimationStep {
//   constructor(
//     timeOrOptionsIn: number | TypeElementAnimationStepInputOptions = {},
//     ...args: Array<TypeElementAnimationStepInputOptions>
//   ) {
//     let options = {};
//     const defaultOptions = { duration: 1, dissolve: 'in', completeOnCancel: true };
//     if (typeof timeOrOptionsIn === 'number') {
//       options = joinObjects({}, defaultOptions, { duration: timeOrOptionsIn }, ...args);
//     } else {
//       options = joinObjects({}, defaultOptions, timeOrOptionsIn, ...args);
//     }
//     super(options);
//   }
// }
// export function dissolveIn(
//   timeOrOptionsIn: number | TypeColorAnimationStepInputOptions = {},
//   ...args: Array<TypeColorAnimationStepInputOptions>
// ) {
//   return new DissolveInAnimationStep(timeOrOptionsIn, ...args);
// }
// export class DissolveOutAnimationStep extends ColorAnimationStep {
//   constructor(
//     timeOrOptionsIn: number | TypeElementAnimationStepInputOptions = {},
//     ...args: Array<TypeElementAnimationStepInputOptions>
//   ) {
//     let options = {};
//     const defaultOptions = { duration: 1, dissolve: 'out', completeOnCancel: true };
//     if (typeof timeOrOptionsIn === 'number') {
//       options = joinObjects({}, defaultOptions, { duration: timeOrOptionsIn }, ...args);
//     } else {
//       options = joinObjects({}, defaultOptions, timeOrOptionsIn, ...args);
//     }
//     super(options);
//   }
// }
// export function dissolveOut(
//   timeOrOptionsIn: number | TypeColorAnimationStepInputOptions = {},
//   ...args: Array<TypeColorAnimationStepInputOptions>
// ) {
//   return new DissolveOutAnimationStep(timeOrOptionsIn, ...args);
// }

/***/ }),

/***/ "./src/js/diagram/Animation/AnimationStep/ElementAnimationStep/OpacityAnimationStep.js":
/*!*********************************************************************************************!*\
  !*** ./src/js/diagram/Animation/AnimationStep/ElementAnimationStep/OpacityAnimationStep.js ***!
  \*********************************************************************************************/
/*! exports provided: OpacityAnimationStep, DissolveInAnimationStep, dissolveIn, DissolveOutAnimationStep, dissolveOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OpacityAnimationStep", function() { return OpacityAnimationStep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DissolveInAnimationStep", function() { return DissolveInAnimationStep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dissolveIn", function() { return dissolveIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DissolveOutAnimationStep", function() { return DissolveOutAnimationStep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dissolveOut", function() { return dissolveOut; });
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _ElementAnimationStep__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ElementAnimationStep */ "./src/js/diagram/Animation/AnimationStep/ElementAnimationStep.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

// import {
//   Transform, Point, getMaxTimeFromVelocity,
// } from '../../../../tools/g2';


var OpacityAnimationStep =
/*#__PURE__*/
function (_ElementAnimationStep) {
  _inherits(OpacityAnimationStep, _ElementAnimationStep);

  function OpacityAnimationStep() {
    var _this;

    _classCallCheck(this, OpacityAnimationStep);

    for (var _len = arguments.length, optionsIn = new Array(_len), _key = 0; _key < _len; _key++) {
      optionsIn[_key] = arguments[_key];
    }

    var ElementAnimationStepOptionsIn = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}].concat(optionsIn, [{
      type: 'color'
    }]));
    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["deleteKeys"])(ElementAnimationStepOptionsIn, ['start', 'delta', 'target', 'dissolve']);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(OpacityAnimationStep).call(this, ElementAnimationStepOptionsIn));
    var defaultPositionOptions = {
      start: null,
      target: null,
      delta: null,
      dissolve: null
    };
    var options = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}, defaultPositionOptions].concat(optionsIn)); // $FlowFixMe

    _this.opacity = {};
    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["copyKeysFromTo"])(options, _this.opacity, ['start', 'delta', 'target', 'dissolve']);
    return _this;
  } // On start, calculate the duration, target and delta if not already present.
  // This is done here in case the start is defined as null meaning it is
  // going to start from present transform.
  // Setting a duration to 0 will effectively skip this animation step


  _createClass(OpacityAnimationStep, [{
    key: "start",
    value: function start(startTime) {
      var element = this.element;

      if (element != null) {
        _get(_getPrototypeOf(OpacityAnimationStep.prototype), "start", this).call(this, startTime);

        if (this.opacity.start == null) {
          // eslint-disable-next-line prefer-destructuring
          this.opacity.start = element.opacity;
        }

        if (this.opacity.delta == null && this.opacity.target == null) {
          this.opacity.target = this.opacity.start;
        } else if (this.opacity.delta != null) {
          this.opacity.target = this.opacity.start + this.opacity.delta;
        }

        this.opacity.whenComplete = this.opacity.target;

        if (this.opacity.dissolve === 'out') {
          // this.opacity.start = 1;
          this.opacity.target = 0.001;
          this.opacity.whenComplete = 1;
          element.setOpacity(this.opacity.start); // this.opacity.target = 0.001;
        }

        if (this.opacity.dissolve === 'in') {
          this.opacity.start = 0.001;
          this.opacity.target = 1;
          this.opacity.whenComplete = 1;
          element.showAll();
          element.setOpacity(this.opacity.start);
        }

        this.opacity.delta = this.opacity.target - this.opacity.start;
      } else {
        this.duration = 0;
      }
    }
  }, {
    key: "cancelledWithNoComplete",
    value: function cancelledWithNoComplete() {
      var element = this.element;

      if (element != null) {
        if (element.opacity === 0.001) {
          element.hide();
          element.opacity = 1;
        }
      }
    }
  }, {
    key: "setFrame",
    value: function setFrame(deltaTime) {
      var percentTime = deltaTime / this.duration;
      var percentComplete = this.progression(percentTime);
      var p = percentComplete;
      var next = this.opacity.start + this.opacity.delta * p;

      if (next > 1) {
        next = 1;
      }

      if (next < 0) {
        next = 0;
      }

      if (this.element != null) {
        this.element.setOpacity(next);
      }
    } // cancelledWithNoComplete() {
    //   const { element } = this;
    //   console.log('cancel with no complete')
    //   if (element != null) {
    //     if (this.color.fullOpacity) {
    //       element.setColor([...element.color.slice(0, 3), 1]);
    //     }
    //   }
    // }

  }, {
    key: "setToEnd",
    value: function setToEnd() {
      var element = this.element;

      if (element != null) {
        // console.log(this.name, this.color.whenComplete)
        element.setOpacity(this.opacity.whenComplete);

        if (this.opacity.dissolve === 'out') {
          element.hide();
        }
      }
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var step = new OpacityAnimationStep();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["duplicateFromTo"])(this, step, ['element']);
      step.element = this.element;
      return step;
    }
  }]);

  return OpacityAnimationStep;
}(_ElementAnimationStep__WEBPACK_IMPORTED_MODULE_1__["default"]);
var DissolveInAnimationStep =
/*#__PURE__*/
function (_OpacityAnimationStep) {
  _inherits(DissolveInAnimationStep, _OpacityAnimationStep);

  function DissolveInAnimationStep() {
    var timeOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, DissolveInAnimationStep);

    var options = {};
    var defaultOptions = {
      duration: 1,
      dissolve: 'in',
      completeOnCancel: true
    };

    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    if (typeof timeOrOptionsIn === 'number') {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}, defaultOptions, {
        duration: timeOrOptionsIn
      }].concat(args));
    } else {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}, defaultOptions, timeOrOptionsIn].concat(args));
    }

    return _possibleConstructorReturn(this, _getPrototypeOf(DissolveInAnimationStep).call(this, options));
  }

  return DissolveInAnimationStep;
}(OpacityAnimationStep);
function dissolveIn() {
  var timeOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    args[_key3 - 1] = arguments[_key3];
  }

  return _construct(DissolveInAnimationStep, [timeOrOptionsIn].concat(args));
}
var DissolveOutAnimationStep =
/*#__PURE__*/
function (_OpacityAnimationStep2) {
  _inherits(DissolveOutAnimationStep, _OpacityAnimationStep2);

  function DissolveOutAnimationStep() {
    var timeOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, DissolveOutAnimationStep);

    var options = {};
    var defaultOptions = {
      duration: 1,
      dissolve: 'out',
      completeOnCancel: true
    };

    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
      args[_key4 - 1] = arguments[_key4];
    }

    if (typeof timeOrOptionsIn === 'number') {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}, defaultOptions, {
        duration: timeOrOptionsIn
      }].concat(args));
    } else {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}, defaultOptions, timeOrOptionsIn].concat(args));
    }

    return _possibleConstructorReturn(this, _getPrototypeOf(DissolveOutAnimationStep).call(this, options));
  }

  return DissolveOutAnimationStep;
}(OpacityAnimationStep);
function dissolveOut() {
  var timeOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
    args[_key5 - 1] = arguments[_key5];
  }

  return _construct(DissolveOutAnimationStep, [timeOrOptionsIn].concat(args));
}

/***/ }),

/***/ "./src/js/diagram/Animation/AnimationStep/ElementAnimationStep/PositionAnimationStep.js":
/*!**********************************************************************************************!*\
  !*** ./src/js/diagram/Animation/AnimationStep/ElementAnimationStep/PositionAnimationStep.js ***!
  \**********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PositionAnimationStep; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _ElementAnimationStep__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ElementAnimationStep */ "./src/js/diagram/Animation/AnimationStep/ElementAnimationStep.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





var PositionAnimationStep =
/*#__PURE__*/
function (_ElementAnimationStep) {
  _inherits(PositionAnimationStep, _ElementAnimationStep);

  function PositionAnimationStep() {
    var _this;

    _classCallCheck(this, PositionAnimationStep);

    for (var _len = arguments.length, optionsIn = new Array(_len), _key = 0; _key < _len; _key++) {
      optionsIn[_key] = arguments[_key];
    }

    var ElementAnimationStepOptionsIn = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, {
      type: 'position'
    }].concat(optionsIn));
    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["deleteKeys"])(ElementAnimationStepOptionsIn, ['start', 'delta', 'target', 'translationStyle', 'translationOptions', 'velocity', 'maxTime']);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(PositionAnimationStep).call(this, ElementAnimationStepOptionsIn));
    var defaultPositionOptions = {
      start: null,
      target: null,
      delta: null,
      translationStyle: 'linear',
      translationOptions: {
        rot: 1,
        magnitude: 0.5,
        offset: 0.5,
        controlPoint: null,
        direction: '',
        maxTime: null
      },
      velocity: null
    };

    if (_this.element && _this.element.animations.options.tranlsation) {
      var translationOptions = _this.element.animations.options.tranlsation;

      if (translationOptions.style != null) {
        // $FlowFixMe - this is messy, but deal with it
        defaultPositionOptions.style = translationOptions.style;
      }

      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultPositionOptions.translationOptions, translationOptions);
    }

    var options = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, defaultPositionOptions].concat(optionsIn));

    if (options.start != null) {
      options.start = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(options.start);
    }

    if (options.target != null) {
      options.target = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(options.target);
    }

    if (options.delta != null) {
      options.delta = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(options.delta);
    } // $FlowFixMe


    _this.position = {
      translationOptions: {}
    };
    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["copyKeysFromTo"])(options, _this.position, ['start', 'delta', 'target', 'translationStyle', 'velocity', 'maxTime']);
    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["duplicateFromTo"])(options.translationOptions, _this.position.translationOptions);
    return _this;
  } // On start, calculate the duration, target and delta if not already present.
  // This is done here in case the start is defined as null meaning it is
  // going to start from present transform.
  // Setting a duration to 0 will effectively skip this animation step


  _createClass(PositionAnimationStep, [{
    key: "start",
    value: function start(startTime) {
      _get(_getPrototypeOf(PositionAnimationStep.prototype), "start", this).call(this, startTime);

      if (this.position.start === null) {
        if (this.element != null) {
          this.position.start = this.element.getPosition();
        } else {
          this.duration = 0;
          return;
        }
      } // if delta is null, then calculate it from start and target


      if (this.position.delta == null && this.position.target != null && this.position.start != null) {
        var delta = this.position.target.sub(this.position.start);
        this.position.delta = delta;
      } else if (this.position.delta != null && this.position.start != null) {
        this.position.target = this.position.start.add(this.position.delta);
      } else {
        this.duration = 0;
      } // If Velocity is defined, then use it to calculate duration


      var _this$position = this.position,
          target = _this$position.target,
          start = _this$position.start,
          velocity = _this$position.velocity;

      if (velocity != null && start != null && target != null) {
        var velocityToUse = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(velocity);
        this.duration = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getMaxTimeFromVelocity"])(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().translate(start), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().translate(target), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().translate(velocityToUse));
      }

      if (this.position.maxTime != null) {
        if (this.duration > this.position.maxTime) {
          this.duration = this.position.maxTime;
        }
      }
    }
  }, {
    key: "setFrame",
    value: function setFrame(deltaTime) {
      var percentTime = deltaTime / this.duration;
      var percentComplete = this.progression(percentTime);
      var p = percentComplete;

      if (this.position.delta != null && this.position.start != null) {
        var next = this.position.start.toDelta(this.position.delta, p, this.position.translationStyle, this.position.translationOptions);

        if (this.element != null) {
          this.element.setPosition(next);
        }
      }
    }
  }, {
    key: "setToEnd",
    value: function setToEnd() {
      if (this.element != null) {
        this.element.setPosition(this.position.target);
      }
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var step = new PositionAnimationStep();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["duplicateFromTo"])(this, step, ['element']);
      step.element = this.element;
      return step;
    }
  }]);

  return PositionAnimationStep;
}(_ElementAnimationStep__WEBPACK_IMPORTED_MODULE_2__["default"]);



/***/ }),

/***/ "./src/js/diagram/Animation/AnimationStep/ElementAnimationStep/PulseAnimationStep.js":
/*!*******************************************************************************************!*\
  !*** ./src/js/diagram/Animation/AnimationStep/ElementAnimationStep/PulseAnimationStep.js ***!
  \*******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PulseAnimationStep; });
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _ElementAnimationStep__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ElementAnimationStep */ "./src/js/diagram/Animation/AnimationStep/ElementAnimationStep.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }




var PulseAnimationStep =
/*#__PURE__*/
function (_ElementAnimationStep) {
  _inherits(PulseAnimationStep, _ElementAnimationStep);

  function PulseAnimationStep() {
    var _this;

    _classCallCheck(this, PulseAnimationStep);

    // const ElementAnimationStepOptionsIn =
    //   joinObjects({}, { type: 'pulse' }, ...optionsIn);
    // super(ElementAnimationStepOptionsIn);
    var defaultOptions = {
      scale: 1.5,
      numLines: 1,
      type: 'pulse',
      duration: 1,
      frequency: 0,
      stopAfterDuration: true
    };

    for (var _len = arguments.length, optionsIn = new Array(_len), _key = 0; _key < _len; _key++) {
      optionsIn[_key] = arguments[_key];
    }

    var options = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));
    _this = _possibleConstructorReturn(this, _getPrototypeOf(PulseAnimationStep).call(this, options));
    _this.scale = options.scale;
    _this.numLines = options.numLines;
    _this.duration = options.duration;
    _this.frequency = options.frequency;
    _this.stopAfterDuration = options.stopAfterDuration;
    return _this;
  } // On start, calculate the duration, target and delta if not already present.
  // This is done here in case the start is defined as null meaning it is
  // going to start from present transform.
  // Setting a duration to 0 will effectively skip this animation step


  _createClass(PulseAnimationStep, [{
    key: "start",
    value: function start(startTime) {
      _get(_getPrototypeOf(PulseAnimationStep.prototype), "start", this).call(this, startTime);

      var element = this.element;

      if (element != null) {
        if (this.numLines === 1) {
          element.pulseScaleNow(this.duration, this.scale, this.frequency);
        } else {
          element.pulseThickNow(this.duration, this.scale, this.numLines);
        }
      }
    } // setFrame(deltaTime: number) {
    // }

  }, {
    key: "setToEnd",
    value: function setToEnd() {
      if (this.element != null) {
        if (this.stopAfterDuration) {
          this.element.stopPulsing(true);
        }
      }
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var step = new PulseAnimationStep();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["duplicateFromTo"])(this, step, ['element']);
      step.element = this.element;
      return step;
    }
  }]);

  return PulseAnimationStep;
}(_ElementAnimationStep__WEBPACK_IMPORTED_MODULE_1__["default"]);



/***/ }),

/***/ "./src/js/diagram/Animation/AnimationStep/ElementAnimationStep/RotationAnimationStep.js":
/*!**********************************************************************************************!*\
  !*** ./src/js/diagram/Animation/AnimationStep/ElementAnimationStep/RotationAnimationStep.js ***!
  \**********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RotationAnimationStep; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _ElementAnimationStep__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ElementAnimationStep */ "./src/js/diagram/Animation/AnimationStep/ElementAnimationStep.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





// A transform animation unit manages a transform animation on an element.
//
// The start transform can either be defined initially, or null. Null means
// the start transform is whatever the current element transform is when the
// unit is started with start().
//
// The transform target is defined with either the target or delta properties.
// Target is used to predefine the target.
// Delta is used to calculate the target when the unit is started with start()
//
var RotationAnimationStep =
/*#__PURE__*/
function (_ElementAnimationStep) {
  _inherits(RotationAnimationStep, _ElementAnimationStep);

  function RotationAnimationStep() {
    var _this;

    _classCallCheck(this, RotationAnimationStep);

    for (var _len = arguments.length, optionsIn = new Array(_len), _key = 0; _key < _len; _key++) {
      optionsIn[_key] = arguments[_key];
    }

    var ElementAnimationStepOptionsIn = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, {
      type: 'rotation'
    }].concat(optionsIn));
    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["deleteKeys"])(ElementAnimationStepOptionsIn, ['start', 'delta', 'target', 'direction', 'velocity', 'clipTo', 'maxTime']);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(RotationAnimationStep).call(this, ElementAnimationStepOptionsIn));
    var defaultTransformOptions = {
      start: null,
      target: null,
      delta: null,
      direction: 0,
      velocity: null,
      clipTo: null,
      maxTime: null
    };
    var options = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, defaultTransformOptions].concat(optionsIn)); // $FlowFixMe

    _this.rotation = {};
    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["copyKeysFromTo"])(options, _this.rotation, ['start', 'delta', 'target', 'velocity', 'direction', 'clipTo', 'maxTime']);
    return _this;
  } // On start, calculate the duration, target and delta if not already present.
  // This is done here in case the start is defined as null meaning it is
  // going to start from present transform.
  // Setting a duration to 0 will effectively skip this animation step


  _createClass(RotationAnimationStep, [{
    key: "start",
    value: function start(startTime) {
      _get(_getPrototypeOf(RotationAnimationStep.prototype), "start", this).call(this, startTime);

      if (this.rotation.start === null) {
        if (this.element != null) {
          this.rotation.start = this.element.transform.r() || 0;
        } else {
          this.duration = 0;
          return;
        }
      } // if delta is null, then calculate it from start and target


      if (this.rotation.delta == null && this.rotation.target != null) {
        var delta = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getDeltaAngle"])(this.rotation.start, this.rotation.target, this.rotation.direction);
        this.rotation.delta = delta;
      } else if (this.rotation.delta != null) {
        this.rotation.target = this.rotation.start + this.rotation.delta;
      } else {
        this.duration = 0;
      } // If Velocity is defined, then use it to calculate duration


      var velocity = this.rotation.velocity;

      if (velocity != null) {
        this.duration = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getMaxTimeFromVelocity"])(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().rotate(this.rotation.start), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().rotate(this.rotation.target), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().rotate(velocity), this.rotation.direction);
      }

      if (this.rotation.maxTime != null) {
        if (this.duration > this.rotation.maxTime) {
          this.duration = this.rotation.maxTime;
        }
      }
    }
  }, {
    key: "setFrame",
    value: function setFrame(deltaTime) {
      var percentTime = deltaTime / this.duration;
      var percentComplete = this.progression(percentTime);
      var p = percentComplete;
      var nextR = this.rotation.start + this.rotation.delta * p;
      nextR = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["clipAngle"])(nextR, this.rotation.clipTo);
      var element = this.element;

      if (element != null) {
        element.setRotation(nextR);
      }
    }
  }, {
    key: "setToEnd",
    value: function setToEnd() {
      var element = this.element;

      if (element != null) {
        element.transform.updateRotation(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["clipAngle"])(this.rotation.target, this.rotation.clipTo));
        element.setTransformCallback(element.transform);
      }
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var step = new RotationAnimationStep();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["duplicateFromTo"])(this, step, ['element']);
      step.element = this.element;
      return step;
    }
  }]);

  return RotationAnimationStep;
}(_ElementAnimationStep__WEBPACK_IMPORTED_MODULE_2__["default"]);



/***/ }),

/***/ "./src/js/diagram/Animation/AnimationStep/ElementAnimationStep/ScaleAnimationStep.js":
/*!*******************************************************************************************!*\
  !*** ./src/js/diagram/Animation/AnimationStep/ElementAnimationStep/ScaleAnimationStep.js ***!
  \*******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ScaleAnimationStep; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _ElementAnimationStep__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ElementAnimationStep */ "./src/js/diagram/Animation/AnimationStep/ElementAnimationStep.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





var ScaleAnimationStep =
/*#__PURE__*/
function (_ElementAnimationStep) {
  _inherits(ScaleAnimationStep, _ElementAnimationStep);

  function ScaleAnimationStep() {
    var _this;

    _classCallCheck(this, ScaleAnimationStep);

    for (var _len = arguments.length, optionsIn = new Array(_len), _key = 0; _key < _len; _key++) {
      optionsIn[_key] = arguments[_key];
    }

    var ElementAnimationStepOptionsIn = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, {
      type: 'position'
    }].concat(optionsIn));
    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["deleteKeys"])(ElementAnimationStepOptionsIn, ['start', 'delta', 'target', 'velocity', 'maxTime']);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(ScaleAnimationStep).call(this, ElementAnimationStepOptionsIn));
    var defaultPositionOptions = {
      start: null,
      target: null,
      delta: null,
      velocity: null,
      maxTime: null
    };
    var options = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, defaultPositionOptions].concat(optionsIn)); // $FlowFixMe

    _this.scale = {};

    if (options.start != null) {
      options.start = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(options.start);
    }

    if (options.target != null) {
      options.target = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(options.target);
    }

    if (options.delta != null) {
      options.delta = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(options.delta);
    }

    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["copyKeysFromTo"])(options, _this.scale, ['start', 'delta', 'target', 'translationStyle', 'velocity', 'maxTime']);
    return _this;
  } // On start, calculate the duration, target and delta if not already present.
  // This is done here in case the start is defined as null meaning it is
  // going to start from present transform.
  // Setting a duration to 0 will effectively skip this animation step


  _createClass(ScaleAnimationStep, [{
    key: "start",
    value: function start(startTime) {
      _get(_getPrototypeOf(ScaleAnimationStep.prototype), "start", this).call(this, startTime);

      if (this.scale.start === null) {
        if (this.element != null) {
          this.scale.start = this.element.getScale();
        } else {
          this.duration = 0;
          return;
        }
      } // if delta is null, then calculate it from start and target


      if (this.scale.delta == null && this.scale.target != null && this.scale.start != null) {
        var delta = this.scale.target.sub(this.scale.start);
        this.scale.delta = delta;
      } else if (this.scale.delta != null && this.scale.start != null) {
        this.scale.target = this.scale.start.add(this.scale.delta);
      } else {
        this.duration = 0;
      } // If Velocity is defined, then use it to calculate duration


      var _this$scale = this.scale,
          target = _this$scale.target,
          start = _this$scale.start,
          velocity = _this$scale.velocity;

      if (velocity != null && target != null && start != null) {
        var velocityToUse = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(velocity); // if (typeof velocity === 'number') {
        //   velocityToUse = new Point(velocity, velocity);
        // }

        this.duration = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getMaxTimeFromVelocity"])(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(start), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(target), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(velocityToUse));
      }

      if (this.scale.maxTime != null) {
        if (this.duration > this.scale.maxTime) {
          this.duration = this.scale.maxTime;
        }
      }
    }
  }, {
    key: "setFrame",
    value: function setFrame(deltaTime) {
      var percentTime = deltaTime / this.duration;
      var percentComplete = this.progression(percentTime);
      var p = percentComplete;

      if (this.scale.start != null && this.scale.delta != null) {
        var next = this.scale.start.toDelta(this.scale.delta, p);

        if (this.element != null) {
          this.element.setScale(next);
        }
      }
    }
  }, {
    key: "setToEnd",
    value: function setToEnd() {
      if (this.element != null) {
        this.element.setScale(this.scale.target);
      }
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var step = new ScaleAnimationStep();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["duplicateFromTo"])(this, step, ['element']);
      step.element = this.element;
      return step;
    }
  }]);

  return ScaleAnimationStep;
}(_ElementAnimationStep__WEBPACK_IMPORTED_MODULE_2__["default"]);



/***/ }),

/***/ "./src/js/diagram/Animation/AnimationStep/ElementAnimationStep/TransformAnimationStep.js":
/*!***********************************************************************************************!*\
  !*** ./src/js/diagram/Animation/AnimationStep/ElementAnimationStep/TransformAnimationStep.js ***!
  \***********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TransformAnimationStep; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _ElementAnimationStep__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ElementAnimationStep */ "./src/js/diagram/Animation/AnimationStep/ElementAnimationStep.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





// A transform animation unit manages a transform animation on an element.
//
// The start transform can either be defined initially, or null. Null means
// the start transform is whatever the current element transform is when the
// unit is started with start().
//
// The transform target is defined with either the target or delta properties.
// Target is used to predefine the target.
// Delta is used to calculate the target when the unit is started with start()
//
var TransformAnimationStep =
/*#__PURE__*/
function (_ElementAnimationStep) {
  _inherits(TransformAnimationStep, _ElementAnimationStep);

  function TransformAnimationStep() {
    var _this;

    _classCallCheck(this, TransformAnimationStep);

    for (var _len = arguments.length, optionsIn = new Array(_len), _key = 0; _key < _len; _key++) {
      optionsIn[_key] = arguments[_key];
    }

    var ElementAnimationStepOptionsIn = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, {
      type: 'transform'
    }].concat(optionsIn));
    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["deleteKeys"])(ElementAnimationStepOptionsIn, ['start', 'delta', 'target', 'rotDirection', 'translationStyle', 'translationOptions', 'velocity', 'clipRotationTo', 'maxTime']);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(TransformAnimationStep).call(this, ElementAnimationStepOptionsIn));
    var defaultTransformOptions = {
      start: null,
      target: null,
      delta: null,
      translationStyle: 'linear',
      rotDirection: 0,
      translationOptions: {
        rot: 1,
        magnitude: 0.5,
        offset: 0.5,
        controlPoint: null,
        direction: ''
      },
      velocity: null,
      clipRotationTo: null,
      maxTime: null
    };

    if (_this.element && _this.element.animations.options.translation) {
      var translationOptions = _this.element.animations.options.translation;

      if (translationOptions.style != null) {
        defaultTransformOptions.translationStyle = translationOptions.style;
      }

      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultTransformOptions.translationOptions, translationOptions);
    }

    var options = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, defaultTransformOptions].concat(optionsIn)); // $FlowFixMe

    _this.transform = {
      translationOptions: {}
    };
    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["copyKeysFromTo"])(options, _this.transform, ['start', 'delta', 'target', 'translationStyle', 'velocity', 'rotDirection', 'clipRotationTo', 'maxTime']);
    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["duplicateFromTo"])(options.translationOptions, _this.transform.translationOptions);
    return _this;
  } // On start, calculate the duration, target and delta if not already present.
  // This is done here in case the start is defined as null meaning it is
  // going to start from present transform.
  // Setting a duration to 0 will effectively skip this animation step


  _createClass(TransformAnimationStep, [{
    key: "start",
    value: function start(startTime) {
      var _this2 = this;

      _get(_getPrototypeOf(TransformAnimationStep.prototype), "start", this).call(this, startTime);

      if (this.transform.start === null) {
        if (this.element != null) {
          this.transform.start = this.element.transform._dup();
        } else {
          this.duration = 0;
          return;
        }
      } // if delta is null, then calculate it from start and target


      if (this.transform.delta == null && this.transform.target != null) {
        var delta = this.transform.target.sub(this.transform.start);
        delta.order.forEach(function (deltaStep, index) {
          var startStep = _this2.transform.start.order[index];
          var targetStep = _this2.transform.target.order[index];

          if (deltaStep instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rotation"] && startStep instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rotation"] && targetStep instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rotation"]) {
            var rotDiff = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getDeltaAngle"])(startStep.r, targetStep.r, _this2.transform.rotDirection); // eslint-disable-next-line no-param-reassign

            deltaStep.r = rotDiff;
          }
        });
        this.transform.delta = delta;
      } else if (this.transform.delta != null) {
        this.transform.target = this.transform.start.add(this.transform.delta);
      } else {
        this.duration = 0;
      } // If Velocity is defined, then use it to calculate duration


      if (this.transform.velocity != null) {
        this.duration = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getMaxTimeFromVelocity"])(this.transform.start, this.transform.target, this.transform.velocity, this.transform.rotDirection);
      }

      if (this.transform.maxTime != null) {
        if (this.duration > this.transform.maxTime) {
          this.duration = this.transform.maxTime;
        }
      }
    }
  }, {
    key: "setFrame",
    value: function setFrame(deltaTime) {
      // const start = phase.startTransform._dup();
      // const delta = phase.deltaTransform._dup();
      var percentTime = deltaTime / this.duration;
      var percentComplete = this.progression(percentTime);
      var p = percentComplete; // let next = delta._dup().constant(p);
      // next = start.add(delta.mul(next));

      var next = this.transform.start.toDelta(this.transform.delta, p, this.transform.translationStyle, this.transform.translationOptions);

      if (this.transform.clipRotationTo !== null) {
        next.clipRotation(this.transform.clipRotationTo);
      }

      if (this.element != null) {
        this.element.setTransform(next);
      }
    }
  }, {
    key: "setToEnd",
    value: function setToEnd() {
      if (this.element != null) {
        this.element.setTransform(this.transform.target);
      }
    } // finish(cancelled: boolean = false, force: ?'complete' | 'noComplete' = null) {
    //   if (this.state === 'idle') {
    //     return;
    //   }
    //   super.finish(cancelled, force);
    //   const setToEnd = () => {
    //     if (this.element != null) {
    //       this.element.setTransform(this.transform.target);
    //     }
    //   };
    //   if (cancelled && force === 'complete') {
    //     setToEnd();
    //   }
    //   if (cancelled && force == null && this.completeOnCancel === true) {
    //     setToEnd();
    //   }
    //   if (cancelled === false) {
    //     setToEnd();
    //   }
    //   if (this.onFinish != null) {
    //     this.onFinish(cancelled);
    //   }
    // }

  }, {
    key: "_dup",
    value: function _dup() {
      var step = new TransformAnimationStep();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["duplicateFromTo"])(this, step, ['element']);
      step.element = this.element;
      return step;
    }
  }]);

  return TransformAnimationStep;
}(_ElementAnimationStep__WEBPACK_IMPORTED_MODULE_2__["default"]);



/***/ }),

/***/ "./src/js/diagram/Animation/AnimationStep/ParallelAnimationStep.js":
/*!*************************************************************************!*\
  !*** ./src/js/diagram/Animation/AnimationStep/ParallelAnimationStep.js ***!
  \*************************************************************************/
/*! exports provided: ParallelAnimationStep, inParallel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParallelAnimationStep", function() { return ParallelAnimationStep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inParallel", function() { return inParallel; });
/* harmony import */ var _AnimationStep__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AnimationStep */ "./src/js/diagram/Animation/AnimationStep.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tools/tools */ "./src/js/tools/tools.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

// import * as tools from '../../tools/math';
// import { DiagramElement } from '../Element';


// Animations get started from a parent, but finish themselves
var ParallelAnimationStep =
/*#__PURE__*/
function (_AnimationStep) {
  _inherits(ParallelAnimationStep, _AnimationStep);

  function ParallelAnimationStep() {
    var _this;

    var stepsOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, ParallelAnimationStep);

    var defaultOptions = {
      steps: []
    };
    var options;

    for (var _len = arguments.length, optionsIn = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      optionsIn[_key - 1] = arguments[_key];
    }

    if (Array.isArray(stepsOrOptionsIn)) {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));
      options.steps = stepsOrOptionsIn;
    } else {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, defaultOptions, stepsOrOptionsIn].concat(optionsIn));
    }

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ParallelAnimationStep).call(this, options));
    _this.steps = [];

    if (!Array.isArray(options.steps) && options.steps != null) {
      _this.steps = [options.steps];
    } else if (options.steps != null) {
      _this.steps = options.steps;
    }

    return _this;
  }

  _createClass(ParallelAnimationStep, [{
    key: "with",
    value: function _with(step) {
      this.steps.push(step);
      return this;
    }
  }, {
    key: "nextFrame",
    value: function nextFrame(now) {
      var remaining = null;

      if (this.beforeFrame != null) {
        this.beforeFrame(now - this.startTime);
      }

      this.steps.forEach(function (step) {
        if (step.state === 'animating' || step.state === 'waitingToStart') {
          var stepRemaining = step.nextFrame(now); // console.log(step.element.uid, stepRemaining)

          if (remaining === null) {
            remaining = stepRemaining;
          }

          if (stepRemaining < remaining) {
            remaining = stepRemaining;
          }
        }
      });

      if (this.afterFrame != null) {
        this.afterFrame(now - this.startTime);
      }

      if (remaining === null) {
        remaining = 0;
      }

      if (remaining >= 0) {
        this.finish();
      }

      return remaining;
    }
  }, {
    key: "finishIfZeroDuration",
    value: function finishIfZeroDuration() {
      var state = 'finished';
      this.steps.forEach(function (step) {
        if (step.state !== 'finished') {
          state = 'animating';
        }
      });

      if (state === 'finished') {
        this.finish();
      }
    }
  }, {
    key: "startWaiting",
    value: function startWaiting() {
      _get(_getPrototypeOf(ParallelAnimationStep.prototype), "startWaiting", this).call(this);

      this.steps.forEach(function (step) {
        step.startWaiting();
      });
    }
  }, {
    key: "start",
    value: function start(startTime) {
      this.startWaiting();

      _get(_getPrototypeOf(ParallelAnimationStep.prototype), "start", this).call(this, startTime);

      this.steps.forEach(function (step) {
        step.start(startTime);
        step.finishIfZeroDuration();
      });
    }
  }, {
    key: "finish",
    value: function finish() {
      var cancelled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (this.state === 'idle' || this.state === 'finished') {
        return;
      } // super.finish(cancelled, force);


      this.state = 'finished';
      var forceToUse = null;

      if (this.completeOnCancel === true) {
        forceToUse = 'complete';
      }

      if (this.completeOnCancel === false) {
        forceToUse = 'noComplete';
      }

      if (force != null) {
        forceToUse = force;
      }

      this.steps.forEach(function (step) {
        if (step.state !== 'idle' && step.state !== 'finished') {
          step.finish(cancelled, forceToUse);
        }
      });

      if (this.onFinish != null) {
        this.onFinish(cancelled);
      }
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var step = new ParallelAnimationStep();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["duplicateFromTo"])(this, step);
      return step;
    }
  }]);

  return ParallelAnimationStep;
}(_AnimationStep__WEBPACK_IMPORTED_MODULE_0__["default"]);
function inParallel() {
  var stepsOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  for (var _len2 = arguments.length, optionsIn = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    optionsIn[_key2 - 1] = arguments[_key2];
  }

  return _construct(ParallelAnimationStep, [stepsOrOptionsIn].concat(optionsIn));
}

/***/ }),

/***/ "./src/js/diagram/Animation/AnimationStep/SerialAnimationStep.js":
/*!***********************************************************************!*\
  !*** ./src/js/diagram/Animation/AnimationStep/SerialAnimationStep.js ***!
  \***********************************************************************/
/*! exports provided: SerialAnimationStep, inSerial */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SerialAnimationStep", function() { return SerialAnimationStep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inSerial", function() { return inSerial; });
/* harmony import */ var _AnimationStep__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AnimationStep */ "./src/js/diagram/Animation/AnimationStep.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tools/tools */ "./src/js/tools/tools.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

// import * as tools from '../../tools/math';
// import { DiagramElement } from '../Element';


var SerialAnimationStep =
/*#__PURE__*/
function (_AnimationStep) {
  _inherits(SerialAnimationStep, _AnimationStep);

  function SerialAnimationStep() {
    var _this;

    var stepsOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, SerialAnimationStep);

    var defaultOptions = {
      steps: []
    };
    var options;

    for (var _len = arguments.length, optionsIn = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      optionsIn[_key - 1] = arguments[_key];
    }

    if (Array.isArray(stepsOrOptionsIn)) {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));
      options.steps = stepsOrOptionsIn;
    } else {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, defaultOptions, stepsOrOptionsIn].concat(optionsIn));
    }

    _this = _possibleConstructorReturn(this, _getPrototypeOf(SerialAnimationStep).call(this, options));
    _this.index = 0;
    _this.steps = [];

    if (!Array.isArray(options.steps) && options.steps != null) {
      _this.steps = [options.steps];
    } else if (options.steps != null) {
      _this.steps = options.steps;
    }

    return _this;
  } // constructor(optionsIn: TypeSerialAnimationStepInputOptions = {}) {
  //   super(optionsIn);
  //   this.index = 0;
  //   const defaultOptions = {};
  //   const options = joinObjects({}, defaultOptions, optionsIn);
  //   this.steps = [];
  //   if (!Array.isArray(options.steps) && options.steps != null) {
  //     this.steps = [options.steps];
  //   } else if (options.steps != null) {
  //     this.steps = options.steps;
  //   }
  //   return this;
  // }


  _createClass(SerialAnimationStep, [{
    key: "then",
    value: function then(step) {
      this.steps.push(step);
      return this;
    }
  }, {
    key: "startWaiting",
    value: function startWaiting() {
      _get(_getPrototypeOf(SerialAnimationStep.prototype), "startWaiting", this).call(this);

      this.steps.forEach(function (step) {
        step.startWaiting();
      });
    }
  }, {
    key: "start",
    value: function start(startTime) {
      if (this.state !== 'animating') {
        this.startWaiting();

        _get(_getPrototypeOf(SerialAnimationStep.prototype), "start", this).call(this, startTime);

        this.index = 0;

        if (this.steps.length > 0) {
          this.steps[0].start(startTime);
          this.steps[0].finishIfZeroDuration();
        }
      }

      this.finishIfZeroDuration();
    }
  }, {
    key: "finishIfZeroDuration",
    value: function finishIfZeroDuration() {
      var i = 0;
      var step = this.steps[0];

      while (i < this.steps.length && step.state === 'finished') {
        i += 1;

        if (i < this.steps.length) {
          this.index = i;
          step = this.steps[i];
          step.start(this.steps[i - 1].startTime);
          step.finishIfZeroDuration();
        }
      }

      if (i === this.steps.length) {
        this.finish();
      }
    }
  }, {
    key: "nextFrame",
    value: function nextFrame(now) {
      var remaining = -1;

      if (this.beforeFrame != null) {
        this.beforeFrame(now - this.startTime);
      }

      if (this.index <= this.steps.length - 1) {
        remaining = this.steps[this.index].nextFrame(now);

        if (this.afterFrame != null) {
          this.afterFrame(now - this.startTime);
        } // console.log('serial', now, this.index, remaining)


        if (remaining >= 0) {
          if (this.index === this.steps.length - 1) {
            this.finish();
            return remaining;
          }

          this.index += 1;
          this.steps[this.index].start(now - remaining);
          return this.nextFrame(now);
        }
      }

      return remaining;
    }
  }, {
    key: "finish",
    value: function finish() {
      var cancelled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (this.state === 'idle' || this.state === 'finished') {
        return;
      } // super.finish(cancelled, force);


      this.state = 'finished';
      var forceToUse = null;

      if (this.completeOnCancel === true) {
        forceToUse = 'complete';
      }

      if (this.completeOnCancel === false) {
        forceToUse = 'noComplete';
      }

      if (force != null) {
        forceToUse = force;
      }

      this.steps.forEach(function (step) {
        if (step.state !== 'idle' && step.state !== 'finished') {
          step.finish(cancelled, forceToUse);
        }
      });

      if (this.onFinish != null) {
        this.onFinish(cancelled);
      }
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var step = new SerialAnimationStep();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["duplicateFromTo"])(this, step);
      return step;
    }
  }]);

  return SerialAnimationStep;
}(_AnimationStep__WEBPACK_IMPORTED_MODULE_0__["default"]);
function inSerial() {
  var stepsOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  for (var _len2 = arguments.length, optionsIn = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    optionsIn[_key2 - 1] = arguments[_key2];
  }

  return _construct(SerialAnimationStep, [stepsOrOptionsIn].concat(optionsIn));
}

/***/ }),

/***/ "./src/js/diagram/Animation/AnimationStep/TriggerStep.js":
/*!***************************************************************!*\
  !*** ./src/js/diagram/Animation/AnimationStep/TriggerStep.js ***!
  \***************************************************************/
/*! exports provided: TriggerStep, trigger */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TriggerStep", function() { return TriggerStep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trigger", function() { return trigger; });
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _AnimationStep__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../AnimationStep */ "./src/js/diagram/Animation/AnimationStep.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }



var TriggerStep =
/*#__PURE__*/
function (_AnimationStep) {
  _inherits(TriggerStep, _AnimationStep);

  function TriggerStep() {
    var _this;

    var triggerOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, TriggerStep);

    var defaultOptions = {
      payload: null,
      duration: 0
    };
    var options;

    for (var _len = arguments.length, optionsIn = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      optionsIn[_key - 1] = arguments[_key];
    }

    if (typeof triggerOrOptionsIn === 'function') {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));
      options.callback = triggerOrOptionsIn;
    } else {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}, defaultOptions, triggerOrOptionsIn].concat(optionsIn));
    }

    _this = _possibleConstructorReturn(this, _getPrototypeOf(TriggerStep).call(this, options));
    _this.callback = options.callback;
    _this.payload = options.payload;
    _this.duration = options.duration;
    return _this;
  }

  _createClass(TriggerStep, [{
    key: "setFrame",
    value: function setFrame() {
      if (this.callback != null) {
        this.callback(this.payload);
        this.callback = null;
      }
    }
  }, {
    key: "setToEnd",
    value: function setToEnd() {
      if (this.callback != null) {
        this.callback(this.payload);
        this.callback = null;
      }
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var step = new TriggerStep();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["duplicateFromTo"])(this, step, ['element']);
      return step;
    }
  }]);

  return TriggerStep;
}(_AnimationStep__WEBPACK_IMPORTED_MODULE_1__["default"]);
function trigger() {
  var triggerOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  for (var _len2 = arguments.length, optionsIn = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    optionsIn[_key2 - 1] = arguments[_key2];
  }

  return _construct(TriggerStep, [triggerOrOptionsIn].concat(optionsIn));
}

/***/ }),

/***/ "./src/js/diagram/Diagram.js":
/*!***********************************!*\
  !*** ./src/js/diagram/Diagram.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _webgl_GlobalAnimation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./webgl/GlobalAnimation */ "./src/js/diagram/webgl/GlobalAnimation.js");
/* harmony import */ var _Gesture__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Gesture */ "./src/js/diagram/Gesture.js");
/* harmony import */ var _DrawContext2D__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./DrawContext2D */ "./src/js/diagram/DrawContext2D.js");
/* harmony import */ var _DiagramPrimitives_DiagramPrimitives__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./DiagramPrimitives/DiagramPrimitives */ "./src/js/diagram/DiagramPrimitives/DiagramPrimitives.js");
/* harmony import */ var _DiagramEquation_DiagramEquation__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./DiagramEquation/DiagramEquation */ "./src/js/diagram/DiagramEquation/DiagramEquation.js");
/* harmony import */ var _DiagramObjects_DiagramObjects__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./DiagramObjects/DiagramObjects */ "./src/js/diagram/DiagramObjects/DiagramObjects.js");
/* harmony import */ var _DiagramAddElements_addElements__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./DiagramAddElements/addElements */ "./src/js/diagram/DiagramAddElements/addElements.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

 // import getShaders from './webgl/shaders';




 // eslint-disable-next-line import/no-cycle








// There are several coordinate spaces that need to be considered for a
// diagram.
//
// In the simplest diagram, there will be in hierarchy:
//  - GL Canvas
//    - Diagram
//      - Element Collection
//        - Element Primitive
//          - Drawing Object (e.g. shape, text) from primative vertices
//
// A shape is defined in Drawing Object space.
// It is then transformed by the element primative
// It is then transformed by the element colleciton
// It is then transformed by the diagram
// it is then transformed into GL Space
//
// Diagram elements can also be rendered to an image in a HTML 2D canvas
// element. To do so, pass in:
//    - Diagram Element (primative or collection) to render
//    - HTML element (which is a 2D canvas)
//    - Window of diagram to render
//    - Window scaling (how does the window fit within the HTML Element)
//      - fit: diagram units will be scaled so that diagram window limits
//             aspect ratio fits within the element aspect ratio
//      - 1em: diagram units will be scaled so 0.2 diagram units (default font
//             size) looks like 1em of the html element font size in pixels
//      - 10px: diagram units will be scaled so that the max diagram window
//              limit will be the pixel count
//      - strech: diagram units will be scaled so that the diagram window
//                limits will be stretched to fit the html element width
//                and height
// Then the process is:
//    - html element size in pixels and aspect ratio found
//    - html element size in gl coordinates found
//  /**
//   * @typedef DiagramOptions
//   * @type {object}
//   * @property {string} [htmlId = 'figureOneContainer'] - div id of diagram container.
//   * @property {Rect} [limits = Rect(-1, -1, 2, 2)] - limits of diagram.
//   */

/**
  * Diagram Class
  * @param {TypeDiagramOptions} options
 */
var Diagram =
/*#__PURE__*/
function () {
  /** id of DIV that diagram is tied to */
  // canvasHigh: HTMLCanvasElement;
  // textCanvasHigh: HTMLCanvasElement;
  // draw2DHigh: DrawContext2D;
  // webglHigh: WebGLInstance;
  // gestureElement: HTMLElement;
  // shapesHigh: Object;
  // equationHigh: Object;
  // objectsHigh: DiagramObjects;
  // layout: Object;
  // oldScrollY: number;
  // used for drawing debug only
  // updateFontSize: string;
  function Diagram(options) {
    _classCallCheck(this, Diagram);

    var defaultOptions = {
      htmlId: 'figureOneContainer',
      limits: new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Rect"](-1, -1, 2, 2),
      // backgroundColor: [1, 1, 1, 1],
      fontScale: 1 // updateFontSize: '',

    };
    this.scrolled = false; // this.oldScrollY = 0;

    var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, defaultOptions, options);
    var htmlId = optionsToUse.htmlId,
        limits = optionsToUse.limits;
    this.htmlId = htmlId; // this.layout = layout;

    if (typeof htmlId === 'string') {
      var container = document.getElementById(htmlId);

      if (container instanceof HTMLElement) {
        this.container = container;
        var children = container.children;

        for (var i = 0; i < children.length; i += 1) {
          var child = children[i];

          if (child instanceof HTMLCanvasElement && child.classList.contains('figureone__gl')) {
            this.canvasLow = child;
          }

          if (child instanceof HTMLCanvasElement && child.classList.contains('figureone__gl__offscreen')) {
            this.canvasOffscreen = child;
          }

          if (child instanceof HTMLCanvasElement && child.classList.contains('figureone__text')) {
            this.textCanvasLow = child;
          }

          if (child instanceof HTMLCanvasElement && child.classList.contains('figureone__text__offscreen')) {
            this.textCanvasOffscreen = child;
          }

          if (child.classList.contains('figureone__html')) {
            this.htmlCanvas = child;
          }
        }

        if (this.canvasLow == null) {
          this.canvasLow = document.createElement('canvas');
          this.canvasLow.classList.add('figureone__gl', 'figureone__canvas');
          container.appendChild(this.canvasLow);
        }

        if (this.textCanvasLow == null) {
          this.textCanvasLow = document.createElement('canvas');
          this.textCanvasLow.classList.add('figureone__text', 'figureone__canvas');
          container.appendChild(this.textCanvasLow);
        }

        if (this.htmlCanvas == null) {
          this.htmlCanvas = document.createElement('div');
          this.htmlCanvas.classList.add('figureone__html', 'figureone__canvas');
          container.appendChild(this.htmlCanvas);
        }

        var canvasStyle = document.createElement('style');
        canvasStyle.type = 'text/css';
        container.classList.add('figureone__container');
        canvasStyle.innerHTML = "\n          .figureone__container {\n            position: relative;\n            pointer-events: none;\n          }\n          .figureone__canvas {\n            width: 100%;\n            height: 100%;\n            position: absolute;\n          }\n          .figureone__html {\n            pointer-events: auto;\n          }\n        ";
        document.getElementsByTagName('head')[0].appendChild(canvasStyle);
        this.backgroundColor = [1, 1, 1, 1];
        var webglLow = new _webgl_webgl__WEBPACK_IMPORTED_MODULE_0__["default"](this.canvasLow, this.backgroundColor);
        this.webglLow = webglLow;

        if (this.canvasOffscreen) {
          var webglOffscreen = new _webgl_webgl__WEBPACK_IMPORTED_MODULE_0__["default"](this.canvasOffscreen, this.backgroundColor);
          this.webglOffscreen = webglOffscreen;
        }

        this.draw2DLow = new _DrawContext2D__WEBPACK_IMPORTED_MODULE_6__["default"](this.textCanvasLow);

        if (this.textCanvasOffscreen) {
          var draw2DOffscreen = new _DrawContext2D__WEBPACK_IMPORTED_MODULE_6__["default"](this.textCanvasOffscreen);
          this.draw2DOffscreen = draw2DOffscreen;
        } // this.draw2DHigh = new DrawContext2D(this.textCanvasHigh);

      }
    }

    if (optionsToUse.gestureCanvas != null) {
      var gestureCanvas = document.getElementById(optionsToUse.gestureCanvas);

      if (gestureCanvas != null) {
        this.gestureCanvas = gestureCanvas;
      }
    }

    if (this.gestureCanvas == null) {
      this.gestureCanvas = this.htmlCanvas;
    }

    if (this instanceof Diagram) {
      this.gesture = new _Gesture__WEBPACK_IMPORTED_MODULE_5__["default"](this);
    }

    this.fontScale = optionsToUse.fontScale;
    this.updateLimits(limits);
    this.drawQueued = false;
    this.lastDrawTime = 0;
    this.inTransition = false;
    this.beingMovedElements = [];
    this.beingTouchedElements = [];
    this.moveTopElementOnly = true;
    this.globalAnimation = new _webgl_GlobalAnimation__WEBPACK_IMPORTED_MODULE_4__["default"]();
    this.shapesLow = this.getShapes(); // this.shapesHigh = this.getShapes(true);

    this.shapes = this.shapesLow;
    this.primitive = this.shapes;
    this.equationLow = this.getEquations(); // this.equationHigh = this.getEquations(true);

    this.equation = this.equationLow;
    this.objectsLow = this.getObjects(); // this.objectsHigh = this.getObjects(true);

    this.objects = this.objectsLow;
    this.createDiagramElements();

    if (this.elements.name === '') {
      this.elements.name = 'diagramRoot';
    } // this.updateFontSize = optionsToUse.updateFontSize;


    window.addEventListener('resize', this.resize.bind(this));
    this.sizeHtmlText();
    this.initialize();
    this.isTouchDevice = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["isTouchDevice"])();
    this.animateNextFrame(true, 'first frame');

    if (optionsToUse.elements) {
      // eslint-disable-next-line new-cap
      this.elements = new optionsToUse.elements(this);
      this.elements.diagramLimits = this.limits;
    }

    this.waitForFrames = 0;
    this.scrollingFast = false;
    this.scrollTimeoutId = null;
    this.drawTimeoutId = null;
    this.oldScroll = window.pageYOffset;
    this.drawAnimationFrames = 0;
  }

  _createClass(Diagram, [{
    key: "scrollEvent",
    value: function scrollEvent() {
      this.scrolled = true;
      this.animateNextFrame(false, 'scroll event');
    }
  }, {
    key: "enableScrolling",
    value: function enableScrolling() {
      document.addEventListener('scroll', this.scrollEvent.bind(this), false);
    }
  }, {
    key: "disableScrolling",
    value: function disableScrolling() {
      document.removeEventListener('scroll', this.scrollEvent.bind(this), false);
    }
    /**
     * Add elements to diagram
     * @param {Array<TypeAddElementObject>} elementsToAdd - array of element definitions
     * @param {DiagramElementCollection} [collection = this.elements] - the
     * collection to add elements to
     * @param {string} [addElementsKey = 'addElements'] - key to add elements
     *
     * @example
     * diagram.addElements([
     *   { name: 'shape1', method: 'polygon', options: { position: [0, 0] } },
     *   { name: 'shape2', method: 'polygon', options: { position: [1, 1] } },
     * ]);
     */

  }, {
    key: "addElements",
    value: function addElements(elementsToAdd) {
      var collection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.elements;
      var addElementsKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'addElements';

      Object(_DiagramAddElements_addElements__WEBPACK_IMPORTED_MODULE_10__["default"])(this.shapes, this.equation, this.objects, collection, elementsToAdd, addElementsKey);
    }
  }, {
    key: "addElement",
    value: function addElement(layout) {
      var rootCollection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.elements;
      var addElementsKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'addElements';

      Object(_DiagramAddElements_addElements__WEBPACK_IMPORTED_MODULE_10__["default"])(this.shapes, this.equation, this.objects, rootCollection, [layout], addElementsKey);
    }
  }, {
    key: "getElement",
    value: function getElement(elementName) {
      return this.elements.getElement(elementName);
    }
  }, {
    key: "setTouchable",
    value: function setTouchable() {
      var touchable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      if (touchable) {
        this.elements.hasTouchableElements = true;
      } else {
        this.elements.hasTouchableElements = false;
      }
    }
  }, {
    key: "getShapes",
    value: function getShapes() {
      var webgl = [this.webglLow];

      if (this.webglOffscreen) {
        webgl.push(this.webglOffscreen);
      }

      var draw2D = [this.draw2DLow];

      if (this.draw2DOffscreen) {
        draw2D.push(this.draw2DOffscreen);
      } // if (high) {
      //   webgl = this.webglHigh;
      //   draw2D = this.draw2DHigh;
      // }


      return new _DiagramPrimitives_DiagramPrimitives__WEBPACK_IMPORTED_MODULE_7__["default"](webgl, draw2D, // this.draw2DFigures,
      this.htmlCanvas, this.limits, this.spaceTransforms, this.animateNextFrame.bind(this, true, 'getShapes'));
    }
  }, {
    key: "getEquations",
    value: function getEquations() {
      var shapes = this.shapesLow; // if (high) {
      //   shapes = this.shapesHigh;
      // }

      return new _DiagramEquation_DiagramEquation__WEBPACK_IMPORTED_MODULE_8__["default"](shapes, this.animateNextFrame.bind(this, true, 'equations'));
    }
  }, {
    key: "getObjects",
    value: function getObjects() {
      var shapes = this.shapesLow;
      var equation = this.equationLow; // if (high) {
      //   shapes = this.shapesHigh;
      //   equation = this.equationHigh;
      // }

      return new _DiagramObjects_DiagramObjects__WEBPACK_IMPORTED_MODULE_9__["default"](shapes, equation, this.isTouchDevice, this.animateNextFrame.bind(this, true, 'objects'));
    }
  }, {
    key: "sizeHtmlText",
    value: function sizeHtmlText() {
      var containerRect = this.container.getBoundingClientRect();
      var size = containerRect.width / 35;
      var test = document.getElementById("".concat(this.htmlId, "_measure"));

      if (test != null) {
        test.style.fontSize = "".concat(size, "px");
        var width = test.clientWidth + 1;
        var ratio = width / containerRect.width;

        if (containerRect.width < 500) {
          size = Math.floor(0.84 / ratio * size * 10000) / 10000;
        } else {
          size = Math.floor(0.85 / ratio * size * 10000) / 10000;
        }
      }

      this.htmlCanvas.style.fontSize = "".concat(size, "px");
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.gesture.destroy();
      this.webglLow.gl.getExtension('WEBGL_lose_context').loseContext(); // this.webglHigh.gl.getExtension('WEBGL_lose_context').loseContext();
    }
  }, {
    key: "setSpaceTransforms",
    value: function setSpaceTransforms() {
      var glSpace = {
        x: {
          bottomLeft: -1,
          width: 2
        },
        y: {
          bottomLeft: -1,
          height: 2
        }
      };
      var diagramSpace = {
        x: {
          bottomLeft: this.limits.left,
          width: this.limits.width
        },
        y: {
          bottomLeft: this.limits.bottom,
          height: this.limits.height
        }
      };
      var canvasRect = this.canvasLow.getBoundingClientRect();
      var pixelSpace = {
        x: {
          bottomLeft: 0,
          width: canvasRect.width
        },
        y: {
          bottomLeft: canvasRect.height,
          height: -canvasRect.height
        }
      };
      var percentSpace = {
        x: {
          bottomLeft: 0,
          width: 1
        },
        y: {
          bottomLeft: 1,
          height: -1
        }
      };
      this.spaceTransforms = {
        diagramToGL: Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["spaceToSpaceTransform"])(diagramSpace, glSpace, 'Diagram'),
        glToDiagram: Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["spaceToSpaceTransform"])(glSpace, diagramSpace),
        pixelToDiagram: Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["spaceToSpaceTransform"])(pixelSpace, diagramSpace),
        diagramToPixel: Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["spaceToSpaceTransform"])(diagramSpace, pixelSpace),
        pixelToGL: Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["spaceToSpaceTransform"])(pixelSpace, glSpace),
        glToPixel: Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["spaceToSpaceTransform"])(glSpace, pixelSpace),
        diagramToCSSPercent: Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["spaceToSpaceTransform"])(diagramSpace, percentSpace)
      };
    }
  }, {
    key: "initialize",
    value: function initialize() {
      this.setFirstTransform();
      this.animateNextFrame();
    }
  }, {
    key: "setFirstTransform",
    value: function setFirstTransform() {
      this.elements.setFirstTransform(this.spaceTransforms.diagramToGL);
    }
  }, {
    key: "updateLimits",
    value: function updateLimits(limits) {
      this.limits = limits._dup();
      this.setSpaceTransforms();
    } // Renders all tied elements in the first level of diagram elements

  }, {
    key: "renderAllElementsToTiedCanvases",
    value: function renderAllElementsToTiedCanvases() {
      var _this = this;

      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.canvasOffscreen == null) {
        return;
      }

      var needClear = false;
      Object.keys(this.elements.elements).forEach(function (name) {
        var element = _this.elements.elements[name];

        if (element.isShown && (element.isRenderedAsImage === false || force) && element.tieToHTML.element != null) {
          element.isRenderedAsImage = true;

          _this.renderElementToTiedCanvas(name);

          needClear = true;
        }
      });

      if (needClear) {
        this.drawQueued = true;
        this.clearContext();
        this.draw2DLow.ctx.clearRect(0, 0, this.textCanvasLow.width, this.textCanvasLow.height);
        this.draw(-1); // this.animateNextFrame(true, 'clear frame');
        // this.draw(-1);
        // this.clickearContext();
      }
    }
  }, {
    key: "renderElementToTiedCanvas",
    value: function renderElementToTiedCanvas(elementName) {
      var _this2 = this;

      // record visibility of top level elements in diagram
      var currentVisibility = {};
      Object.keys(this.elements.elements).forEach(function (name) {
        var element = _this2.elements.elements[name];
        currentVisibility[name] = element.isShown;
      }); // Hide all elements

      Object.keys(this.elements.elements).forEach(function (name) {
        _this2.elements.elements[name].hide();
      }); // Show the element to render

      var elementToRender = this.elements.elements[elementName];
      elementToRender.show(); // Move it to the origin to render

      var oldPosition = elementToRender.getPosition();
      var oldScale = elementToRender.getScale();
      var htmlCanvas = document.getElementById(elementToRender.tieToHTML.element);

      if (htmlCanvas instanceof HTMLElement) {
        this.canvasOffscreen.style.width = "".concat(htmlCanvas.clientWidth, "px");
        this.canvasOffscreen.style.height = "".concat(htmlCanvas.clientHeight, "px");
        this.textCanvasOffscreen.style.width = "".concat(htmlCanvas.clientWidth, "px");
        this.textCanvasOffscreen.style.height = "".concat(htmlCanvas.clientHeight, "px");
        this.webglOffscreen.resize();
        this.draw2DOffscreen.resize();
      }

      elementToRender.updateHTMLElementTie(this.canvasOffscreen); // Need to reset position as updateHTMLElementTie doesn't set correct
      // position as it uses a diagram pixels space transform that is only
      // relavant to the first gl canvas.

      var scale = elementToRender.getScale();
      elementToRender.setPosition(0 - scale.x * (elementToRender.tieToHTML.window.left + elementToRender.tieToHTML.window.width / 2), 0 - scale.y * (elementToRender.tieToHTML.window.bottom + elementToRender.tieToHTML.window.height / 2)); // elementToRender.setPosition(0, 0);
      // Stop animations and render

      elementToRender.isRenderedAsImage = false;
      elementToRender.stop(true, true);
      this.renderToCanvas(elementToRender.tieToHTML.element);
      elementToRender.isRenderedAsImage = true; // elementToRender.setRenderedOnNextDraw();
      // reset position

      elementToRender.setPosition(oldPosition);
      elementToRender.setScale(oldScale); // show all elements that were shown previously (except element that was just rendered)

      Object.keys(this.elements.elements).forEach(function (name) {
        var element = _this2.elements.elements[name];

        if (currentVisibility[name] === true) {
          element.show();
        } else {
          element.hide();
        }
      });
    } // This method will render the gl and 2d contexts to a canvas

  }, {
    key: "renderToCanvas",
    value: function renderToCanvas() {
      var htmlCanvasElementOrId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var htmlCanvas = htmlCanvasElementOrId;

      if (typeof htmlCanvasElementOrId === 'string') {
        htmlCanvas = document.getElementById(htmlCanvasElementOrId);
      }

      if (!(htmlCanvas instanceof HTMLElement)) {
        return;
      }

      this.drawQueued = true;
      this.draw(-1, 1);
      var w = document.getElementById("".concat(htmlCanvasElementOrId, "_webgl"));

      if (w instanceof HTMLImageElement) {
        w.src = this.webglOffscreen.gl.canvas.toDataURL('image/png', 0.5);
        w.style.display = 'block';
      }

      var d = document.getElementById("".concat(htmlCanvasElementOrId, "_2d"));

      if (d instanceof HTMLImageElement) {
        d.src = this.draw2DOffscreen.canvas.toDataURL('image/png', 0.5);
        d.style.display = 'block';
      }

      this.clearContext(1);
    }
  }, {
    key: "unrenderAll",
    value: function unrenderAll() {
      // console.log('unrender all', Object.keys(this.elements.drawOrder).length)
      for (var i = 0; i < this.elements.drawOrder.length; i += 1) {
        var element = this.elements.elements[this.elements.drawOrder[i]];
        element.unrender();
      }
    } // resize should only be called if the viewport size has changed.

  }, {
    key: "resize",
    value: function resize() {
      var skipHTMLTie = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      this.webglLow.resize();
      this.draw2DLow.resize();
      this.setSpaceTransforms();

      if (this.elements != null) {
        this.elements.updateLimits(this.limits, this.spaceTransforms);
      }

      this.sizeHtmlText(); // this.elements.resizeHtmlObject();
      // this.updateHTMLElementTie();

      if (skipHTMLTie) {
        this.elements.resize();
      } else {
        this.elements.resize(this.canvasLow);
      }

      if (this.oldWidth !== this.canvasLow.clientWidth) {
        // this.unrenderAll();
        // console.log('updating width')
        this.renderAllElementsToTiedCanvases();
        this.oldWidth = this.canvasLow.clientWidth;
      }

      this.animateNextFrame(true, 'resize');
      this.drawAnimationFrames = 2; // this.renderAllElementsToTiedCanvases(true);
    }
  }, {
    key: "updateHTMLElementTie",
    value: function updateHTMLElementTie() {
      if (this.elements != null) {
        this.elements.updateHTMLElementTie(this.canvasLow);
      }
    } // Handle touch down, or mouse click events within the canvas.
    // The default behavior is to be able to move objects that are touched
    // and dragged, then when they are released, for them to move freely before
    // coming to a stop.

  }, {
    key: "touchDownHandler",
    value: function touchDownHandler(clientPoint) {
      if (this.inTransition) {
        return false;
      } // Get the touched point in clip space


      var pixelPoint = this.clientToPixel(clientPoint); // console.log(pixelPoint)

      var glPoint = pixelPoint.transformBy(this.spaceTransforms.pixelToGL.matrix()); // console.log(glPoint.transformBy(this.glToDiagramSpaceTransform.matrix()))
      // const clipPoint = this.clientToClip(clientPoint);
      // Get all the diagram elements that were touched at this point (element
      // must have isTouchable = true to be considered)

      this.beingTouchedElements = this.elements.getTouched(glPoint);

      if (this.moveTopElementOnly) {
        if (this.beingTouchedElements.length > 0) {
          this.beingTouchedElements[0].click();
        }
      } else {
        this.beingTouchedElements.forEach(function (e) {
          return e.click();
        });
      } // Make a list of, and start moving elements that are being moved
      // (element must be touched and have isMovable = true to be in list)


      this.beingMovedElements = [];

      for (var i = 0; i < this.beingTouchedElements.length; i += 1) {
        var element = this.beingTouchedElements[i];

        if (element.isMovable) {
          this.beingMovedElements.push(element);
          element.startBeingMoved();
        }
      }

      if (this.beingMovedElements.length > 0) {
        this.animateNextFrame(true, 'touch down handler');
      }

      if (this.beingTouchedElements.length > 0) {
        return true;
      }

      return false;
    } // Handle touch up, or mouse click up events in the canvas. When an UP even
    // happens, the default behavior is to let any elements being moved to move
    // freely until they decelerate to 0.

  }, {
    key: "touchUpHandler",
    value: function touchUpHandler() {
      // console.log("before", this.elements._circle.transform.t())
      // console.log(this.beingMovedElements)
      for (var i = 0; i < this.beingMovedElements.length; i += 1) {
        var element = this.beingMovedElements[i];

        if (element.state.isBeingMoved) {
          element.stopBeingMoved();
          element.startMovingFreely();
        }
      }

      this.beingMovedElements = [];
      this.beingTouchedElements = []; // console.log("after", this.elements._circle.transform.t())
    }
  }, {
    key: "rotateElement",
    value: function rotateElement(element, previousClientPoint, currentClientPoint) {
      var centerDiagramSpace = element.getPosition('diagram');

      if (centerDiagramSpace == null) {
        centerDiagramSpace = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, 0);
      }

      var center = centerDiagramSpace.transformBy(this.spaceTransforms.diagramToPixel.matrix());
      var previousPixelPoint = this.clientToPixel(previousClientPoint);
      var currentPixelPoint = this.clientToPixel(currentClientPoint); // const previousDiagramPoint =
      //   previousPixelPoint.transformBy(this.pixelToDiagramSpaceTransform.matrix());
      // const currentDiagramPoint =
      //   currentPixelPoint.transformBy(this.pixelToDiagramSpaceTransform.matrix());
      // const currentAngle = Math.atan2(
      //   currentDiagramPoint.y - center.y,
      //   currentDiagramPoint.x - center.x,
      // );
      // const previousAngle = Math.atan2(
      //   previousDiagramPoint.y - center.y,
      //   previousDiagramPoint.x - center.x,
      // );

      var currentAngle = Math.atan2(currentPixelPoint.y - center.y, currentPixelPoint.x - center.x);
      var previousAngle = Math.atan2(previousPixelPoint.y - center.y, previousPixelPoint.x - center.x);
      var diffAngle = -Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["minAngleDiff"])(previousAngle, currentAngle);

      var transform = element.transform._dup();

      var rot = transform.r();

      if (rot == null) {
        rot = 0;
      }

      var newAngle = rot - diffAngle; // if (newAngle < 0) {
      //   newAngle += 2 * Math.PI;
      // }
      // if (newAngle > 2 * Math.PI) {
      //   newAngle -= 2 * Math.PI;
      // }

      transform.updateRotation(newAngle);
      element.moved(transform._dup());
    }
  }, {
    key: "translateElement",
    value: function translateElement(element, previousClientPoint, currentClientPoint) {
      var previousPixelPoint = this.clientToPixel(previousClientPoint);
      var currentPixelPoint = this.clientToPixel(currentClientPoint);
      var previousDiagramPoint = previousPixelPoint.transformBy(this.spaceTransforms.pixelToDiagram.matrix());
      var currentDiagramPoint = currentPixelPoint.transformBy(this.spaceTransforms.pixelToDiagram.matrix());
      var m = element.diagramSpaceToVertexSpaceTransformMatrix();
      var currentVertexSpacePoint = currentDiagramPoint.transformBy(m);
      var previousVertexSpacePoint = previousDiagramPoint.transformBy(m); // const delta = currentDiagramPoint.sub(previousDiagramPoint);

      var elementSpaceDelta = currentVertexSpacePoint.sub(previousVertexSpacePoint); // console.log(delta, elementSpaceDelta)

      var currentTransform = element.transform._dup();

      var currentTranslation = currentTransform.t();

      if (currentTranslation != null) {
        var newTranslation = currentTranslation.add(elementSpaceDelta);
        currentTransform.updateTranslation(newTranslation);
        element.moved(currentTransform);
      }
    }
  }, {
    key: "scaleElement",
    value: function scaleElement(element, previousClientPoint, currentClientPoint) {
      var type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
      var previousPixelPoint = this.clientToPixel(previousClientPoint);
      var currentPixelPoint = this.clientToPixel(currentClientPoint); // const previousDiagramPoint =
      //   previousPixelPoint.transformBy(this.pixelToDiagramSpaceTransform.matrix());
      // const currentDiagramPoint =
      //   currentPixelPoint.transformBy(this.pixelToDiagramSpaceTransform.matrix());
      // const previousMag = previousDiagramPoint.sub(center).distance();
      // const currentMag = currentDiagramPoint.sub(center).distance();

      var center = element.getPosition('diagram').transformBy(this.spaceTransforms.diagramToPixel.matrix());
      var previousMag = previousPixelPoint.sub(center).distance();
      var currentMag = currentPixelPoint.sub(center).distance();
      var currentScale = element.transform.s();

      if (currentScale != null) {
        var currentTransform = element.transform._dup();

        var newScaleX = currentScale.x * currentMag / previousMag;
        var newScaleY = currentScale.y * currentMag / previousMag;

        if (type === 'x') {
          currentTransform.updateScale(newScaleX, 1);
        } else if (type === 'y') {
          currentTransform.updateScale(1, newScaleY);
        } else {
          currentTransform.updateScale(newScaleX, newScaleY);
        }

        element.moved(currentTransform);
      }
    } // Handle touch/mouse move events in the canvas. These events will only be
    // sent if the initial touch down happened in the canvas.
    // The default behavior is to drag (move) any objects that were touched in
    // the down event to the new location.
    // This function should return true if the move event should NOT be processed
    // by the system. For example, on a touch device, a touch and drag would
    // normally scroll the screen. Typically, you would want to move the diagram
    // element and not the screen, so a true would be returned.

  }, {
    key: "touchMoveHandler",
    value: function touchMoveHandler(previousClientPoint, currentClientPoint) {
      if (this.inTransition) {
        return false;
      }

      if (this.beingMovedElements.length === 0) {
        return false;
      }

      var previousPixelPoint = this.clientToPixel(previousClientPoint); // const currentPixelPoint = this.clientToPixel(currentClientPoint);

      var previousGLPoint = previousPixelPoint.transformBy(this.spaceTransforms.pixelToGL.matrix()); // Go through each element being moved, get the current translation

      for (var i = 0; i < this.beingMovedElements.length; i += 1) {
        var element = this.beingMovedElements[i];

        if (element !== this.elements) {
          if (element.isBeingTouched(previousGLPoint) || element.move.canBeMovedAfterLosingTouch) {
            var elementToMove = element.move.element == null ? element : element.move.element;

            if (elementToMove.state.isBeingMoved === false) {
              elementToMove.startBeingMoved();
            }

            if (this.beingMovedElements.indexOf(elementToMove) === -1) {
              this.beingMovedElements.push(elementToMove);
            }

            if (element.move.type === 'rotation') {
              this.rotateElement(elementToMove, previousClientPoint, currentClientPoint);
            } else if (element.move.type === 'scale') {
              this.scaleElement(elementToMove, previousClientPoint, currentClientPoint);
            } else if (element.move.type === 'scaleX') {
              this.scaleElement(elementToMove, previousClientPoint, currentClientPoint, 'x');
            } else if (element.move.type === 'scaleY') {
              this.scaleElement(elementToMove, previousClientPoint, currentClientPoint, 'y');
            } else {
              this.translateElement(elementToMove, previousClientPoint, currentClientPoint);
            }
          }
        }

        if (this.moveTopElementOnly) {
          i = this.beingMovedElements.length;
        }
      }

      this.animateNextFrame(true, 'touch move handler');
      return true;
    }
  }, {
    key: "stop",
    value: function stop() {
      var cancelled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var forceSetToEndOfPlan = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      this.elements.stop(cancelled, forceSetToEndOfPlan);
    } // To add elements to a diagram, either this method can be overridden,
    // or the `add` method can be used.

  }, {
    key: "createDiagramElements",
    value: function createDiagramElements() {
      // this.elements = new DiagramElementCollection();
      this.elements = this.primitive.collection();
      this.elements.diagramLimits = this.limits;
    }
  }, {
    key: "add",
    value: function add(name, diagramElement) {
      this.elements.add(name, diagramElement);
    }
  }, {
    key: "setElementsToCollection",
    value: function setElementsToCollection(collection) {
      this.elements = collection;
      this.setFirstTransform();
    }
  }, {
    key: "clearContext",
    value: function clearContext() {
      var canvasIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      if (canvasIndex === 0) {
        this.webglLow.gl.clearColor(0, 0, 0, 0);
        this.webglLow.gl.clear(this.webglLow.gl.COLOR_BUFFER_BIT);
      } else {
        this.webglOffscreen.gl.clearColor(0, 0, 0, 0);
        this.webglOffscreen.gl.clear(this.webglLow.gl.COLOR_BUFFER_BIT);
      } // this.webglHigh.gl.clearColor(0, 0, 0, 0);
      // this.webglHigh.gl.clear(this.webglHigh.gl.COLOR_BUFFER_BIT);


      this.elements.clear(canvasIndex);
    } // scroll() {
    //   if (this.scrollingFast === false) {
    //     this.webglLow.gl.canvas.style.top = '-10000px';
    //     this.renderAllElementsToTiedCanvases();
    //     this.scrollingFast = true;
    //     if (this.scrollTimeoutId) {
    //       clearTimeout(this.scrollTimeoutId);
    //       this.scrollTimeoutId = null;
    //     }
    //     this.scrollTimeoutId = setTimeout(this.centerDrawingLens.bind(this, true), 100);
    //   }
    // }

  }, {
    key: "drawNow",
    value: function drawNow() {
      var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;
      this.drawQueued = true;
      this.draw(time);
    }
  }, {
    key: "draw",
    value: function draw(nowIn) {
      var canvasIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var now = nowIn;

      if (nowIn === -1) {
        now = this.lastDrawTime;
      } // console.log((now - this.lastDrawTime) * 1000);


      this.lastDrawTime = now;

      if (this.scrolled === true) {
        this.scrolled = false;

        if (Math.abs(window.pageYOffset - this.oldScroll) > this.webglLow.gl.canvas.clientHeight / 4) {
          // if (this.webglLow.gl.canvas.style.top !== '-10000px') {
          //   this.webglLow.gl.canvas.style.top = '-10000px';
          //   this.waitForFrames = 1;
          // }
          // if (this.waitForFrames > 0) {
          //   this.waitForFrames -= 1;
          // } else {
          this.renderAllElementsToTiedCanvases(); // }

          this.scrollingFast = true;

          if (this.scrollTimeoutId) {
            clearTimeout(this.scrollTimeoutId);
            this.scrollTimeoutId = null;
          }

          this.scrollTimeoutId = setTimeout(this.centerDrawingLens.bind(this, true), 100);
        }
      } // If only a scroll event called draw, then quit before drawing


      if (this.drawQueued === false) {
        return;
      }

      this.drawQueued = false;
      this.clearContext(canvasIndex); // console.log('really drawing')

      this.elements.draw(this.spaceTransforms.diagramToGL, now, canvasIndex); // console.log('really done')

      if (this.elements.isMoving()) {
        this.animateNextFrame(true, 'is moving');
      }

      if (this.drawAnimationFrames > 0) {
        this.drawAnimationFrames -= 1;
        this.animateNextFrame(true, 'queued frames');
      } // if (this.drawTimeoutId) {
      //   clearTimeout(this.drawTimeoutId);
      //   this.drawTimeoutId = null;
      // }
      // this.drawTimeoutId = setTimeout(this.renderToImages.bind(this), 100);

    } // renderToImages() {
    //   // console.log('visibility1')
    //   this.drawTimeoutId = null;
    //   // if (this.webglLow.gl.canvas.style.top !== '-10000px') {
    //   //   this.webglLow.gl.canvas.style.top = '-10000px';
    //   //   this.waitForFrames = 1;
    //   // }
    //   this.renderAllElementsToTiedCanvases();
    //   // this.centerDrawingLens();
    //   // this.webglLow.gl.canvas.style.visibility = 'visible';
    // }

  }, {
    key: "centerDrawingLens",
    value: function centerDrawingLens() {
      var fromTimeOut = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (fromTimeOut) {
        this.scrollingFast = false;
      }

      var viewPortHeight = window.innerHeight || 0;

      if (document.documentElement != null) {
        viewPortHeight = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
      }

      var newTop = window.pageYOffset + viewPortHeight / 2 - this.webglLow.gl.canvas.clientHeight / 2;

      if (newTop < 0) {
        newTop = 0;
      }

      var newTopInPx = "".concat(newTop, "px");

      if (this.webglLow.gl.canvas.style.top !== newTopInPx) {
        this.webglLow.gl.canvas.style.top = "".concat(newTop, "px");
        this.draw2DLow.canvas.style.top = "".concat(newTop, "px");
        this.updateHTMLElementTie();
      }

      this.oldScroll = window.pageYOffset;
    }
  }, {
    key: "animateNextFrame",
    value: function animateNextFrame() {
      var draw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var fromWhere = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      this.fromWhere = fromWhere;

      if (!this.drawQueued) {
        if (draw) {
          this.drawQueued = true;
        }

        this.globalAnimation.queueNextFrame(this.draw.bind(this));
      }
    }
  }, {
    key: "isAnimating",
    value: function isAnimating() {
      return this.elements.isMoving();
    }
  }, {
    key: "clientToPixel",
    value: function clientToPixel(clientLocation) {
      var canvas = this.canvasLow.getBoundingClientRect();
      return new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](clientLocation.x - canvas.left, clientLocation.y - canvas.top);
    }
  }]);

  return Diagram;
}();

/* harmony default export */ __webpack_exports__["default"] = (Diagram);

/***/ }),

/***/ "./src/js/diagram/DiagramAddElements/addElements.js":
/*!**********************************************************!*\
  !*** ./src/js/diagram/DiagramAddElements/addElements.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _DiagramPrimitives_DiagramPrimitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../DiagramPrimitives/DiagramPrimitives */ "./src/js/diagram/DiagramPrimitives/DiagramPrimitives.js");
/* harmony import */ var _DiagramObjects_DiagramObjects__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../DiagramObjects/DiagramObjects */ "./src/js/diagram/DiagramObjects/DiagramObjects.js");
/* harmony import */ var _DiagramEquation_DiagramEquation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../DiagramEquation/DiagramEquation */ "./src/js/diagram/DiagramEquation/DiagramEquation.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }






function addElements(shapes, equation, objects, rootCollection, layout, addElementsKey) {
  var getPath = function getPath(e, remainingPath) {
    if (!(remainingPath[0] in e)) {
      return null;
    }

    if (remainingPath.length === 1) {
      // $FlowFixMe
      return e[remainingPath[0]];
    } // $FlowFixMe


    return getPath(e[remainingPath[0]], remainingPath.slice(1));
  };

  var getMethod = function getMethod(method) {
    var methods = {
      collection: shapes.collection.bind(shapes),
      polyline: objects.polyline.bind(objects),
      // polylineCorners: shapes.polylineCorners.bind(shapes),
      polygon: shapes.polygon.bind(shapes),
      arrow: shapes.arrow.bind(shapes),
      fan: shapes.fan.bind(shapes),
      text: shapes.text.bind(shapes),
      textGL: shapes.textGL.bind(shapes),
      textHTML: shapes.htmlText.bind(shapes),
      htmlImage: shapes.htmlImage.bind(shapes),
      axes: shapes.axes.bind(shapes),
      radialLines: shapes.radialLines.bind(shapes),
      rectangle: shapes.rectangle.bind(shapes),
      grid: shapes.grid.bind(shapes),
      dashedLine: shapes.dashedLine.bind(shapes),
      parallelMarks: shapes.parallelMarks.bind(shapes),
      marks: shapes.marks.bind(shapes),
      box: shapes.box.bind(shapes),
      //
      line: objects.line.bind(objects),
      angle: objects.angle.bind(objects),
      //
      addEquation: equation.addEquation.bind(equation),
      equation: equation.equation.bind(equation),
      addNavigator: equation.addNavigator.bind(equation)
    };

    if (method in methods) {
      return methods[method];
    }

    var diagram = {
      shapes: shapes,
      objects: objects,
      equation: equation
    };
    var splitMethod = method.split('.');
    var methodToUse = getPath(diagram, splitMethod);

    if (methodToUse == null) {
      // throw new Error(`Diagram addElements ERROR: Cannot find method ${method}`);
      return null;
    }

    methodToUse = methodToUse.bind(getPath(diagram, splitMethod.slice(0, -1)));
    return methodToUse;
  };

  if (Array.isArray(layout)) {
    layout.forEach(function (elementDefinition, index) {
      // Extract the parameters from the layout object
      if (elementDefinition == null) {
        throw Error("Add elements index ".concat(index, " does not exist in layout"));
      }

      var nameToUse = elementDefinition.name;
      var pathToUse = elementDefinition.path;
      var optionsToUse = elementDefinition.options;
      var addElementsToUse = elementDefinition[addElementsKey];
      var methodPathToUse = elementDefinition.method;
      var elementModsToUse = elementDefinition.mods;
      var firstScenario = elementDefinition.scenario;
      var collectionPath;

      if (pathToUse == null || pathToUse === '') {
        collectionPath = rootCollection;
      } else {
        // const path = pathToUse.split('/');
        // collectionPath = getPath(rootCollection, path);
        collectionPath = rootCollection.getElement(pathToUse);
      } // Check for critical errors


      if (nameToUse == null || nameToUse === '') {
        // $FlowFixMe
        throw new Error("Diagram addElement ERROR  at index ".concat(index, " in collection ").concat(rootCollection.name, ": missing name property in ").concat(elementDefinition));
      }

      if (methodPathToUse == null || methodPathToUse === '') {
        // $FlowFixMe
        throw new Error("Diagram addElement ERROR  at index ".concat(index, " in collection ").concat(rootCollection.name, ": missing method property in ").concat(elementDefinition));
      }

      if (!(collectionPath instanceof _Element__WEBPACK_IMPORTED_MODULE_0__["DiagramElementCollection"])) {
        // $FlowFixMe
        throw new Error("Diagram addElement ERROR at index ".concat(index, " in collection ").concat(rootCollection.name, ": missing or incorrect path property in ").concat(elementDefinition));
      }

      var methodPath = methodPathToUse.split('/');
      var method = getMethod(methodPathToUse);

      if (typeof method !== 'function') {
        return;
      }

      if (typeof method !== 'function') {
        throw new Error("Layout addElement at index ".concat(index, " in collection ").concat(rootCollection.name, ": incorrect method property"));
      }

      var element;

      if (methodPath.slice(-1)[0].startsWith('add')) {
        element = method(collectionPath, nameToUse, optionsToUse);

        if (element == null) {
          return;
        }
      } else {
        if (Array.isArray(optionsToUse)) {
          element = method.apply(void 0, _toConsumableArray(optionsToUse));
        } else {
          element = method(optionsToUse);
        }

        if (element == null) {
          return;
        }

        if (collectionPath instanceof _Element__WEBPACK_IMPORTED_MODULE_0__["DiagramElementCollection"]) {
          collectionPath.add(nameToUse, element);
        }
      }

      if (elementModsToUse != null && elementModsToUse !== {}) {
        element.setProperties(elementModsToUse);
      } // element.setProperties(elementDefinition, [
      //   'mods', 'name', 'method', 'scenario', 'addElementsKey', 'options', 'path',
      // ]);


      if (firstScenario != null && firstScenario in element.scenarios) {
        element.setScenario(firstScenario);
      }

      if ("_".concat(nameToUse) in rootCollection && addElementsToUse != null && addElementsToUse !== {}) {
        addElements(shapes, equation, objects, // $FlowFixMe
        rootCollection["_".concat(nameToUse)], addElementsToUse, addElementsKey);
      }
    });
  }
}

/* harmony default export */ __webpack_exports__["default"] = (addElements);

/***/ }),

/***/ "./src/js/diagram/DiagramElements/Arrow.js":
/*!*************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Arrow.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Arrow; });
/* harmony import */ var _DrawingObjects_VertexObject_VertexArrow__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../DrawingObjects/VertexObject/VertexArrow */ "./src/js/diagram/DrawingObjects/VertexObject/VertexArrow.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");




function Arrow(webgl) {
  var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var legWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.5;
  var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
  var legHeight = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;
  var tip = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"](0, 0);
  var rotation = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
  var color = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : [1, 1, 1, 1];
  var transformOrLocation = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"](0, 0);
  var diagramLimits = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Rect"](-1, -1, 2, 2);
  var vertexLine = new _DrawingObjects_VertexObject_VertexArrow__WEBPACK_IMPORTED_MODULE_0__["default"](webgl, width, legWidth, height, legHeight, tip, rotation);
  var transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Transform"]();

  if (transformOrLocation instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"]) {
    transform = transform.translate(transformOrLocation.x, transformOrLocation.y);
  } else {
    transform = transformOrLocation._dup();
  }

  return new _Element__WEBPACK_IMPORTED_MODULE_1__["DiagramElementPrimitive"](vertexLine, transform, color, diagramLimits);
}

/***/ }),

/***/ "./src/js/diagram/DiagramElements/Box.js":
/*!***********************************************!*\
  !*** ./src/js/diagram/DiagramElements/Box.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Box; });
/* harmony import */ var _DrawingObjects_VertexObject_VertexBox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../DrawingObjects/VertexObject/VertexBox */ "./src/js/diagram/DrawingObjects/VertexObject/VertexBox.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");




function Box(webgl, width, height, lineWidth, fill, color, transformOrLocation, diagramLimits) {
  var vertexRectangle = new _DrawingObjects_VertexObject_VertexBox__WEBPACK_IMPORTED_MODULE_0__["default"](webgl, width, height, lineWidth, fill);
  var transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Transform"]();

  if (transformOrLocation instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"]) {
    transform = transform.translate(transformOrLocation.x, transformOrLocation.y);
  } else {
    transform = transformOrLocation._dup();
  }

  var element = new _Element__WEBPACK_IMPORTED_MODULE_1__["DiagramElementPrimitive"](vertexRectangle, transform, color, diagramLimits); // $FlowFixMe

  element.surround = function (parent, children) {
    var spaceIn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var drawingSpace = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'diagram';
    var elements = [parent];

    if (children != null && children !== '') {
      elements = parent.getElements(children);
    }

    if (elements.length === 0) {
      return;
    }

    var space = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_2__["getPoint"])(spaceIn);
    var maxBounds = elements[0].getBoundingRect(drawingSpace);

    for (var i = 1; i < elements.length; i += 1) {
      var bounds = elements[i].getBoundingRect(drawingSpace);

      if (bounds.left < maxBounds.left) {
        maxBounds.left = bounds.left;
      }

      if (bounds.bottom < maxBounds.bottom) {
        maxBounds.bottom = bounds.bottom;
      }

      if (bounds.right - maxBounds.left > maxBounds.width) {
        maxBounds.width = bounds.right - maxBounds.left;
      }

      if (bounds.top - maxBounds.bottom > maxBounds.height) {
        maxBounds.height = bounds.top - maxBounds.bottom;
      }
    }

    maxBounds.left -= space.x;
    maxBounds.bottom -= space.y;
    maxBounds.height += 2 * space.x;
    maxBounds.width += 2 * space.y;
    maxBounds.right = maxBounds.left + maxBounds.width;
    maxBounds.top = maxBounds.bottom + maxBounds.height; // $FlowFixMe

    element.drawingObject.updateBox(maxBounds.width, maxBounds.height);
    element.setPosition(maxBounds.left + maxBounds.width / 2, maxBounds.bottom + maxBounds.height / 2);
  };

  return element;
}

/***/ }),

/***/ "./src/js/diagram/DiagramElements/DashedLine.js":
/*!******************************************************!*\
  !*** ./src/js/diagram/DiagramElements/DashedLine.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _DrawingObjects_VertexObject_VertexDashedLine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../DrawingObjects/VertexObject/VertexDashedLine */ "./src/js/diagram/DrawingObjects/VertexObject/VertexDashedLine.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");





function DashedLine(webgl, start, length, width, rotation, dashStyle, color, transformOrLocation, diagramLimits) {
  var vertexLine = new _DrawingObjects_VertexObject_VertexDashedLine__WEBPACK_IMPORTED_MODULE_0__["default"](webgl, start, length, width, rotation, dashStyle);
  var transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Transform"]();

  if (transformOrLocation instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"]) {
    transform = transform.translate(transformOrLocation.x, transformOrLocation.y);
  } else {
    transform = transformOrLocation._dup();
  }

  return new _Element__WEBPACK_IMPORTED_MODULE_1__["DiagramElementPrimitive"](vertexLine, transform, color, diagramLimits);
}

/* harmony default export */ __webpack_exports__["default"] = (DashedLine);

/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/Elements/BaseAnnotationFunction.js":
/*!************************************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/Elements/BaseAnnotationFunction.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BaseAnnotationFunction; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _Bounds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bounds */ "./src/js/diagram/DiagramElements/Equation/Elements/Bounds.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _Symbols_SymbolNew__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Symbols/SymbolNew */ "./src/js/diagram/DiagramElements/Equation/Symbols/SymbolNew.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

 // import { Elements } from './Element';

 // import BaseEquationFunction from './BaseEquationFunction';
// import type { TypeParsablePoint } from '../../../../tools/g2';
// import type {EQN_Annotation } from './Base'
// import {
//   DiagramElementPrimitive, DiagramElementCollection,
// } from '../../../Element';

 // import { Element, Elements } from './Element';

// import Symbol from '../Symbols/Symbol';
 // eslint-disable-next-line import/no-cycle
// import type { TypeEquationPhrase } from '../EquationFunctions';

// export type EQN_GlyphsIn = {
//   left?: TypeAnnotatedGlyph;
//   right?: TypeAnnotatedGlyph;
//   top?: TypeAnnotatedGlyph;
//   bottom?: TypeAnnotatedGlyph;
//   encompass?: EQN_EncompassGlyphIn;
// };
function copyAnnotation(annotation, namedCollection) {
  return {
    xPosition: annotation.xPosition,
    yPosition: annotation.yPosition,
    xAlign: annotation.xAlign,
    yAlign: annotation.yAlign,
    offset: annotation.offset._dup(),
    scale: annotation.scale,
    content: annotation.content._dup(namedCollection),
    inSize: annotation.inSize,
    fullContentBounds: annotation.fullContentBounds
  };
}

function copyAnnotations(annotations, namedCollection) {
  var copy = [];
  annotations.forEach(function (annotation) {
    copy.push(copyAnnotation(annotation, namedCollection));
  });
  return copy;
}

function copyGlyphs(glyphs, namedCollection) {
  var copy = {};
  Object.keys(glyphs).forEach(function (key) {
    if (glyphs[key] == null) {
      return;
    }

    var glyph = glyphs[key];
    var copyGlyph = {};
    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["duplicateFromTo"])(glyph, copyGlyph, ['glyph', 'annotations']);

    if (namedCollection != null) {
      copyGlyph.glyph = namedCollection[glyph.glyph.name];
    } else {
      copyGlyph.glyph = glyph.glyph;
    }

    copyGlyph.annotations = copyAnnotations(glyph.annotations, namedCollection);
    copy[key] = copyGlyph;
  });
  return copy;
}

function getAllElementsFromAnnotations(annotations) {
  var elements = [];
  annotations.forEach(function (annotation) {
    elements = [].concat(_toConsumableArray(elements), _toConsumableArray(annotation.content.getAllElements()));
  });
  return elements;
}

function getAllElementsFromGlyphs(glyphs) {
  var elements = [];
  Object.keys(glyphs).forEach(function (key) {
    var glyph = glyphs[key];

    if (glyph == null) {
      return;
    }

    elements = [].concat(_toConsumableArray(elements), [glyph.glyph], _toConsumableArray(getAllElementsFromAnnotations(glyph.annotations)));
  });
  return elements;
}

function setPositionsForAnnotations(annotations) {
  annotations.forEach(function (annotation) {
    annotation.content.setPositions();
  });
}

function offsetLocationForAnnotations(annotations, offset) {
  annotations.forEach(function (annotation) {
    annotation.content.offsetLocation(offset);
  });
}

function setPositionsForGlyphs(glyphs) {
  Object.keys(glyphs).forEach(function (key) {
    if (glyphs[key] == null) {
      return;
    }

    var glyph = glyphs[key];

    var t = glyph.glyph.transform._dup();

    t.updateScale(glyph.width, glyph.height);
    t.updateTranslation(glyph.location.x, glyph.location.y);
    glyph.glyph.setTransform(t);
    setPositionsForAnnotations(glyph.annotations);
  });
}

function offsetLocationForGlyphs(glyphs, offset) {
  Object.keys(glyphs).forEach(function (key) {
    if (glyphs[key] == null) {
      return;
    }

    var glyph = glyphs[key];
    glyph.location = glyph.location.add(offset);
    offsetLocationForAnnotations(glyph.annotations, offset);
  });
}

var BaseAnnotationFunction =
/*#__PURE__*/
function () {
  function BaseAnnotationFunction(content, annotations, glyphs, options) {
    _classCallCheck(this, BaseAnnotationFunction);

    this.glyphs = glyphs;
    this.content = content;
    this.annotations = annotations;
    this.options = options;
  }

  _createClass(BaseAnnotationFunction, [{
    key: "_dup",
    value: function _dup(namedCollection) {
      var contentCopy = this.content._dup(namedCollection);

      var glyphsCopy = copyGlyphs(this.glyphs);
      var annotationsCopy = copyAnnotations(this.annotations);
      var copy = new this.constructor( // $FlowFixMe
      contentCopy, annotationsCopy, glyphsCopy, this.options);
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["duplicateFromTo"])(this, copy, ['content', 'glyphs', 'annotations']);
      return copy;
    }
  }, {
    key: "getAllElements",
    value: function getAllElements() {
      return [].concat(_toConsumableArray(this.content.getAllElements()), _toConsumableArray(getAllElementsFromAnnotations(this.annotations)), _toConsumableArray(getAllElementsFromGlyphs(this.glyphs)));
    }
  }, {
    key: "setPositions",
    value: function setPositions() {
      this.content.setPositions();
      setPositionsForAnnotations(this.annotations);
      setPositionsForGlyphs(this.glyphs);
    }
  }, {
    key: "offsetLocation",
    value: function offsetLocation() {
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      this.location = this.location.add(offset);
      this.content.offsetLocation(offset);
      offsetLocationForAnnotations(this.annotations, offset);
      offsetLocationForGlyphs(this.glyphs, offset);
    } //                               Top Glyph
    //                  GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG
    //                  GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG     Encompassing Glyph
    //                                                      /
    //                                                    /
    //        GGG       GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG        GGG
    //        GGG       GGG                           GGG        GGG
    //        GGG       GGG     CCCCCCCCCCCCCCCCC     GGG        GGG
    //        GGG       GGG     CCCCCCCCCCCCCCCCC     GGG        GGG
    // Left   GGG       GGG     CCCCCCCCCCCCCCCCC     GGG        GGG   Right
    // Glyph  GGG       GGG     CCCCCCCCCCCCCCCCC     GGG        GGG   Glyph
    //        GGG       GGG     CCCCCCCCCCCCCCCCC     GGG        GGG
    //        GGG       GGG     CCCCCCCCCCCCCCCCC     GGG        GGG
    //        GGG       GGG     CCCCCCCCCCCCCCCCC     GGG        GGG
    //        GGG       GGG                           GGG        GGG
    //        GGG       GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG        GGG
    //
    //
    //                  GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG
    //                  GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG
    //                            Bottom Glyph
    //
    //
    //
    //
    // |                          GGGGGGGGGGGGGGGGGGGGGGGG
    // |                          GGGGGGGGGGGGGGGGGGGGGGGG
    // |                          GGG                  GGG
    // |                          GGG                  GGG
    // |        GGG               GGG   CCCCCCCCCCCC   GGG               GGG
    // |        GGG               GGG   CCCCCCCCCCCC   GGG               GGG
    // |        GGG               GGG   CCCCCCCCCCCC   GGG               GGG
    // |  AAA   GGG   AAA   AAA   GGG   CCCCCCCCCCCC   GGG   AAA   AAA   GGG   AAA
    // |  AAA   GGG   AAA   AAA   GGG   CCCCCCCCCCCC   GGG   AAA   AAA   GGG   AAA
    // |  AAA   GGG   AAA   AAA   GGG   CCCCCCCCCCCC   GGG   AAA   AAA   GGG   AAA
    // |  AAA   GGG   AAA   AAA   GGG   CCCCCCCCCCCC   GGG   AAA   AAA   GGG   AAA
    // |  AAA   GGG   AAA   AAA   GGG   CCCCCCCCCCCC   GGG   AAA   AAA   GGG   AAA
    // | |   |  GGG  |   | |   |  GGG   CCCCCCCCCCCC   GGG               GGG
    // | |   |  GGG  |   | |   |  GGG   CCCCCCCCCCCC   GGG               GGG
    // | |   |  GGG  |   | |   |  GGG   CCCCCCCCCCCC   GGG               GGG
    // | |   |  |  | |   | |   |  GGG   |              GGG
    // | |   |  |  | |   | |   |  GGG   |              GGG
    // | |   |  |  | |   | |   |  GGGGGGGGGGGGGGGGGGGGGGGG
    // | |   |  |  | |   | |   |  GGGGGGGGGGGGGGGGGGGGGGGG
    // | |   |  |  | |   | |   |  |  |  |
    // | |   |  |  | |   | |   |  |  |--|<----  contentEncompassGlyph Space
    // | |   |  |  | |   | |   |  |
    // | |   |  |  | |   | |   |--|<----- EncompassGlyphAnnotation Space
    // | |   |  |  | |   | |
    // | |   |  |  | |   |-|<----- ContentAnnotationGlyphInsideAnnotation Space
    // | |   |  |  | |
    // | |   |  |  |-|<------- GlyphInsideAnnotationGlyph Space
    // | |   |  |
    // | |  >|--|<------ GlypgGlyphOutsideAnnotation Space
    // | |
    // |-|<------ Outside Space

  }, {
    key: "calcSize",
    value: function calcSize(location, scale) {
      var _this = this;

      this.location = location._dup();

      var loc = location._dup(); // const [encompassGlyph, leftGlyph, bottomGlyph, rightGlyph, topGlyph] = this.glyphs;


      var content = this.content,
          annotations = this.annotations;
      var _this$options = this.options,
          inSize = _this$options.inSize,
          space = _this$options.space,
          topSpace = _this$options.topSpace,
          bottomSpace = _this$options.bottomSpace,
          leftSpace = _this$options.leftSpace,
          rightSpace = _this$options.rightSpace,
          contentScale = _this$options.contentScale,
          useFullBounds = _this$options.useFullBounds,
          fullContentBounds = _this$options.fullContentBounds;
      var inSizeBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();
      var fullBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();
      var contentBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();
      content.calcSize(loc._dup(), scale * contentScale);
      contentBounds.copyFrom(content.getBounds(fullContentBounds));
      inSizeBounds.copyFrom(contentBounds);
      fullBounds.copyFrom(contentBounds);
      annotations.forEach(function (annotation) {
        annotation.content.calcSize(loc, scale * annotation.scale);

        _this.setAnnotationPosition(contentBounds, annotation, scale);

        var annotationBounds = annotation.content.getBounds();
        inSizeBounds.growWithSameBaseline(annotationBounds);
        var fullSizeAnnotationBounds = annotation.content.getBounds(true);
        fullBounds.growWithSameBaseline(fullSizeAnnotationBounds);
      });

      var _this$setEncompassGly = this.setEncompassGlyph(scale, contentBounds),
          _this$setEncompassGly2 = _slicedToArray(_this$setEncompassGly, 2),
          encompassBounds = _this$setEncompassGly2[0],
          encompassFullBounds = _this$setEncompassGly2[1];

      inSizeBounds.growWithSameBaseline(encompassBounds);
      fullBounds.growWithSameBaseline(encompassFullBounds);

      var _this$setVerticalGlyp = this.setVerticalGlyph(scale, contentBounds, 'left'),
          _this$setVerticalGlyp2 = _slicedToArray(_this$setVerticalGlyp, 2),
          leftBounds = _this$setVerticalGlyp2[0],
          leftFullBounds = _this$setVerticalGlyp2[1];

      inSizeBounds.growWithSameBaseline(leftBounds);
      fullBounds.growWithSameBaseline(leftFullBounds);

      var _this$setVerticalGlyp3 = this.setVerticalGlyph(scale, contentBounds, 'right'),
          _this$setVerticalGlyp4 = _slicedToArray(_this$setVerticalGlyp3, 2),
          rightBounds = _this$setVerticalGlyp4[0],
          rightFullBounds = _this$setVerticalGlyp4[1];

      inSizeBounds.growWithSameBaseline(rightBounds);
      fullBounds.growWithSameBaseline(rightFullBounds);

      var _this$setHorizontalGl = this.setHorizontalGlyph(scale, contentBounds, 'top'),
          _this$setHorizontalGl2 = _slicedToArray(_this$setHorizontalGl, 2),
          topBounds = _this$setHorizontalGl2[0],
          topFullBounds = _this$setHorizontalGl2[1];

      inSizeBounds.growWithSameBaseline(topBounds);
      fullBounds.growWithSameBaseline(topFullBounds);

      var _this$setHorizontalGl3 = this.setHorizontalGlyph(scale, contentBounds, 'bottom'),
          _this$setHorizontalGl4 = _slicedToArray(_this$setHorizontalGl3, 2),
          bottomBounds = _this$setHorizontalGl4[0],
          bottomFullBounds = _this$setHorizontalGl4[1];

      inSizeBounds.growWithSameBaseline(bottomBounds);
      fullBounds.growWithSameBaseline(bottomFullBounds);
      var xLocationOffset = 0;
      var topSpaceToUse = (topSpace != null ? topSpace : space || 0) * scale;
      var bottomSpaceToUse = (bottomSpace != null ? bottomSpace : space || 0) * scale;
      var leftSpaceToUse = (leftSpace != null ? leftSpace : space || 0) * scale;
      var rightSpaceToUse = (rightSpace != null ? rightSpace : space || 0) * scale;
      inSizeBounds.offset(topSpaceToUse, rightSpaceToUse, -bottomSpaceToUse, -leftSpaceToUse);
      fullBounds.growWithSameBaseline(inSizeBounds);

      if (useFullBounds) {
        inSizeBounds.copyFrom(fullBounds);
      }

      if (inSize) {
        this.width = inSizeBounds.width;
        this.ascent = inSizeBounds.ascent;
        this.descent = inSizeBounds.descent;
        this.height = inSizeBounds.height;
        xLocationOffset = loc.x - inSizeBounds.left;
      } else {
        this.width = contentBounds.width;
        this.ascent = contentBounds.ascent;
        this.descent = contentBounds.descent;
        this.height = contentBounds.height;
      }

      this.fullSize = {
        leftOffset: this.location.x - fullBounds.left,
        width: fullBounds.width,
        ascent: fullBounds.ascent,
        descent: fullBounds.descent,
        height: fullBounds.height
      };

      if (xLocationOffset !== 0 && content != null) {
        var locationOffset = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](xLocationOffset, 0);
        content.offsetLocation(locationOffset);
        annotations.forEach(function (annotation) {
          annotation.content.offsetLocation(locationOffset);
        });
        Object.keys(this.glyphs).forEach(function (key) {
          var glyph = _this.glyphs[key];

          if (glyph == null) {
            return;
          }

          glyph.location = glyph.location.add(locationOffset);
          glyph.glyph.custom.setSize(glyph.location, glyph.width, glyph.height);
          glyph.annotations.forEach(function (annotation) {
            annotation.content.offsetLocation(locationOffset);
          });
        });
      }
    }
  }, {
    key: "setEncompassGlyph",
    value: function setEncompassGlyph(scale, contentBoundsIn) {
      var _this2 = this;

      if (this.glyphs.encompass == null) {
        var _fullBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();

        _fullBounds.copyFrom(contentBoundsIn);

        return [contentBoundsIn, _fullBounds];
      }

      var _this$glyphs$encompas = this.glyphs.encompass,
          leftSpace = _this$glyphs$encompas.leftSpace,
          rightSpace = _this$glyphs$encompas.rightSpace,
          bottomSpace = _this$glyphs$encompas.bottomSpace,
          topSpace = _this$glyphs$encompas.topSpace,
          space = _this$glyphs$encompas.space;
      var glyph = this.glyphs.encompass;
      var spaceToUse = space != null ? space : 0;
      var left = leftSpace != null ? leftSpace : spaceToUse;
      var right = rightSpace != null ? rightSpace : spaceToUse;
      var top = topSpace != null ? topSpace : spaceToUse;
      var bottom = bottomSpace != null ? bottomSpace : spaceToUse;
      var contentBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();
      contentBounds.copyFrom(contentBoundsIn);
      contentBounds.offset(top * scale, right * scale, -bottom * scale, -left * scale);
      var glyphBounds = glyph.glyph.getBounds(glyph.glyph.custom.options, contentBounds.left, contentBounds.bottom, contentBounds.width, contentBounds.height);
      var inSizeBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();
      var fullBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();
      inSizeBounds.copyFrom(contentBounds);
      inSizeBounds.growWithSameBaseline(glyphBounds);
      fullBounds.copyFrom(inSizeBounds);
      glyph.width = glyphBounds.width;
      glyph.height = glyphBounds.height;
      glyph.location = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](glyphBounds.left, glyphBounds.bottom);
      glyph.glyph.custom.setSize(glyph.location, glyph.width, glyph.height);
      glyph.annotations.forEach(function (annotation) {
        annotation.content.calcSize(glyph.location, scale * annotation.scale);

        _this2.setAnnotationPosition(glyphBounds, annotation, scale);

        var annotationBounds = annotation.content.getBounds();
        inSizeBounds.growWithSameBaseline(annotationBounds);
        var fullAnnotationBounds = annotation.content.getBounds(true);
        fullBounds.growWithSameBaseline(fullAnnotationBounds);
      });
      return [inSizeBounds, fullBounds];
    }
  }, {
    key: "setVerticalGlyph",
    value: function setVerticalGlyph(scale, contentBounds, glyphName) {
      var _this3 = this;

      if (this.glyphs[glyphName] == null) {
        var _fullBounds2 = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();

        _fullBounds2.copyFrom(contentBounds);

        return [contentBounds, _fullBounds2];
      }

      var _this$glyphs$glyphNam = this.glyphs[glyphName],
          space = _this$glyphs$glyphNam.space,
          overhang = _this$glyphs$glyphNam.overhang,
          topSpace = _this$glyphs$glyphNam.topSpace,
          bottomSpace = _this$glyphs$glyphNam.bottomSpace,
          minContentHeight = _this$glyphs$glyphNam.minContentHeight,
          minContentDescent = _this$glyphs$glyphNam.minContentDescent,
          minContentAscent = _this$glyphs$glyphNam.minContentAscent,
          descent = _this$glyphs$glyphNam.descent,
          height = _this$glyphs$glyphNam.height,
          yOffset = _this$glyphs$glyphNam.yOffset,
          annotationsOverContent = _this$glyphs$glyphNam.annotationsOverContent;
      var glyph = this.glyphs[glyphName]; // const contentBounds = new Bounds();
      // contentBounds.copyFrom(contentBounds);

      var glyphHeight = contentBounds.height;
      var contentX = contentBounds.left;
      var glyphBottom = contentBounds.bottom; // let glyphTop = contentBounds.top;

      var glyphDescent = contentBounds.descent;
      var glyphAscent = contentBounds.ascent;

      if (minContentDescent != null) {
        glyphDescent = Math.max(minContentDescent, glyphDescent);
        glyphHeight = contentBounds.ascent + glyphDescent;
      }

      if (minContentAscent != null) {
        glyphAscent = Math.max(minContentAscent, glyphAscent);
        glyphHeight = glyphAscent + glyphDescent;
      }

      if (minContentHeight != null) {
        glyphAscent = -glyphDescent + Math.max(minContentHeight, glyphHeight);
      }

      var topSpaceToUse = topSpace != null ? topSpace : overhang;
      var bottomSpaceToUse = bottomSpace != null ? bottomSpace : overhang;
      glyphDescent += scale * bottomSpaceToUse;

      if (descent != null) {
        glyphDescent = descent;
      }

      glyphAscent += scale * topSpaceToUse;
      glyphHeight = glyphDescent + glyphAscent;

      if (height != null) {
        glyphHeight = height;
        glyphAscent = glyphHeight - glyphDescent;
      }

      glyphBottom = contentBounds.bottom - (glyphDescent - contentBounds.descent); // glyphTop = contentBoundsIn.top + (glyphAscent - contentBoundsIn.ascent);
      // glyphLeft = contentBounds.left;

      if (glyphName === 'left') {
        contentX -= space * scale;
      } else {
        contentX = contentBounds.left + contentBounds.width + space * scale;
      } // let glyphBottom = contentBounds.bottom;


      if (descent == null && bottomSpace == null && height != null) {
        glyphBottom = contentBounds.bottom + contentBounds.height / 2 - height / 2;
      }

      var glyphBounds = glyph.glyph.getBounds(glyph.glyph.custom.options, contentX, glyphBottom + yOffset, // $FlowFixMe
      null, glyphHeight, glyphName); // const totalBounds = new Bounds();

      var inSizeBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();
      var fullBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();
      inSizeBounds.copyFrom(contentBounds);
      inSizeBounds.growWithSameBaseline(glyphBounds);
      fullBounds.copyFrom(inSizeBounds);
      var glyphAndAnnotationBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();
      glyphAndAnnotationBounds.copyFrom(glyphBounds);
      glyph.width = glyphBounds.width;
      glyph.height = glyphBounds.height;
      glyph.location = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](glyphBounds.left, glyphBounds.bottom);
      glyph.glyph.custom.setSize(glyph.location, glyph.width, glyph.height);
      glyph.annotations.forEach(function (annotation) {
        annotation.content.calcSize(glyph.location, scale * annotation.scale);

        _this3.setAnnotationPosition(glyphBounds, annotation, scale);

        var annotationBounds = annotation.content.getBounds();
        inSizeBounds.growWithSameBaseline(annotationBounds);
        glyphAndAnnotationBounds.growWithSameBaseline(annotationBounds);
        var fullAnnotationBounds = annotation.content.getBounds(true);
        fullBounds.growWithSameBaseline(fullAnnotationBounds);
      });
      var xOffset = 0;

      if (glyphName === 'left' && glyphAndAnnotationBounds.right > contentX && annotationsOverContent === false) {
        xOffset = contentX - glyphAndAnnotationBounds.right;
      }

      if (glyphName === 'right' && glyphAndAnnotationBounds.left < contentX && annotationsOverContent === false) {
        xOffset = contentX - glyphAndAnnotationBounds.left;
      }

      if (xOffset !== 0) {
        var locationOffset = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](xOffset, 0);
        glyph.location = glyph.location.add(locationOffset);
        glyph.glyph.custom.setSize(glyph.location, glyph.width, glyph.height);
        glyph.annotations.forEach(function (annotation) {
          annotation.content.offsetLocation(locationOffset);
        });
        inSizeBounds.left += xOffset;
        inSizeBounds.right = Math.max(inSizeBounds.right + xOffset, contentBounds.right);
        fullBounds.left += xOffset;
        fullBounds.right = Math.max(inSizeBounds.right + xOffset, contentBounds.right);
      } // console.log(inSizeBounds.left, inSizeBounds.width)


      return [inSizeBounds, fullBounds];
    }
  }, {
    key: "setHorizontalGlyph",
    value: function setHorizontalGlyph(scale, contentBoundsIn, glyphName) {
      var _this4 = this;

      if (this.glyphs[glyphName] == null) {
        var _fullBounds3 = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();

        _fullBounds3.copyFrom(contentBoundsIn);

        return [contentBoundsIn, _fullBounds3];
      }

      var _this$glyphs$glyphNam2 = this.glyphs[glyphName],
          space = _this$glyphs$glyphNam2.space,
          overhang = _this$glyphs$glyphNam2.overhang,
          width = _this$glyphs$glyphNam2.width,
          leftSpace = _this$glyphs$glyphNam2.leftSpace,
          rightSpace = _this$glyphs$glyphNam2.rightSpace,
          xOffset = _this$glyphs$glyphNam2.xOffset,
          annotationsOverContent = _this$glyphs$glyphNam2.annotationsOverContent;
      var glyph = this.glyphs[glyphName];
      var contentBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();
      contentBounds.copyFrom(contentBoundsIn);
      var glyphLength = contentBounds.width;
      var contentX = contentBounds.left;

      if (overhang != null) {
        glyphLength += 2 * overhang * scale;
        contentX = contentBounds.left - overhang * scale;
      }

      if (width != null) {
        glyphLength = width * scale;
      }

      if (leftSpace != null || rightSpace != null) {
        glyphLength = (leftSpace || 0) * scale + contentBounds.width + (rightSpace || 0) * scale;

        if (leftSpace != null) {
          contentX = contentBounds.left - leftSpace * scale;
        }
      }

      if (leftSpace == null && rightSpace == null && width != null) {
        contentX = contentBounds.left + (contentBounds.width - width) / 2;
      } else if (leftSpace == null && rightSpace != null && width != null) {
        contentX = contentBounds.right + rightSpace * scale - width;
      }

      var contentY;

      if (glyphName === 'top') {
        contentY = contentBounds.top + space * scale;
      } else {
        contentY = contentBounds.bottom - space * scale;
      }

      var glyphBounds = glyph.glyph.getBounds(glyph.glyph.custom.options, contentX + xOffset, contentY, glyphLength, // $FlowFixMe
      null, glyphName);
      var inSizeBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();
      var fullBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();
      inSizeBounds.copyFrom(contentBounds);
      inSizeBounds.growWithSameBaseline(glyphBounds);
      fullBounds.copyFrom(inSizeBounds);
      var glyphAndAnnotationBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();
      glyphAndAnnotationBounds.copyFrom(glyphBounds);
      glyph.width = glyphBounds.width;
      glyph.height = glyphBounds.height;
      glyph.location = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](glyphBounds.left, glyphBounds.bottom);
      glyph.glyph.custom.setSize(glyph.location, glyph.width, glyph.height);
      glyph.annotations.forEach(function (annotation) {
        annotation.content.calcSize(glyph.location, scale * annotation.scale);

        _this4.setAnnotationPosition(glyphBounds, annotation, scale);

        var annotationBounds = annotation.content.getBounds();
        inSizeBounds.growWithSameBaseline(annotationBounds);
        glyphAndAnnotationBounds.growWithSameBaseline(annotationBounds);
        var fullAnnotationBounds = annotation.content.getBounds(true);
        fullBounds.growWithSameBaseline(fullAnnotationBounds);
      });
      var yOffset = 0;

      if (glyphName === 'top' && glyphAndAnnotationBounds.bottom < contentY && annotationsOverContent === false) {
        yOffset = contentY - glyphAndAnnotationBounds.bottom;
      }

      if (glyphName === 'bottom' && glyphAndAnnotationBounds.top > contentY && annotationsOverContent === false) {
        yOffset = contentY - glyphAndAnnotationBounds.top;
      }

      if (yOffset !== 0) {
        var locationOffset = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, yOffset);
        glyph.location = glyph.location.add(locationOffset);
        glyph.glyph.custom.setSize(glyph.location, glyph.width, glyph.height);
        glyph.annotations.forEach(function (annotation) {
          annotation.content.offsetLocation(locationOffset);
        });
        inSizeBounds.top += yOffset;
        inSizeBounds.bottom += yOffset;
        fullBounds.top += yOffset;
        fullBounds.bottom += yOffset;
      }

      return [inSizeBounds, fullBounds];
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "setAnnotationPosition",
    value: function setAnnotationPosition(contentToAnnotateBounds, annotation, scale) {
      var xPosition = annotation.xPosition,
          yPosition = annotation.yPosition,
          xAlign = annotation.xAlign,
          yAlign = annotation.yAlign,
          offset = annotation.offset;
      offset = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(offset);
      var content = annotation.content,
          fullContentBounds = annotation.fullContentBounds;
      var locationContentToAnnotate = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](contentToAnnotateBounds.left, contentToAnnotateBounds.bottom + contentToAnnotateBounds.descent);
      var xPos;
      var yPos; // $FlowFixMe

      if (contentToAnnotateBounds.annotations != null && annotation.reference != null) {
        // $FlowFixMe
        var reference = contentToAnnotateBounds.annotations[annotation.reference];

        if (reference.xPosition != null) {
          xPosition = reference.xPosition;
        }

        if (reference.yPosition != null) {
          yPosition = reference.yPosition;
        }

        if (reference.xAlign != null) {
          xAlign = reference.xAlign;
        }

        if (reference.yAlign != null) {
          yAlign = reference.yAlign;
        }

        if (reference.offset != null) {
          offset = offset.add(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(reference.offset));
        }
      }

      if (xPosition === 'right') {
        xPos = 1;
      } else if (xPosition === 'center') {
        xPos = 0.5;
      } else if (typeof xPosition === 'number') {
        xPos = xPosition;
      } else {
        // left
        xPos = 0;
      }

      xPos = xPos * contentToAnnotateBounds.width + locationContentToAnnotate.x;

      if (yPosition === 'bottom') {
        yPos = 0;
      } else if (yPosition === 'middle') {
        yPos = 0.5;
      } else if (yPosition === 'top') {
        yPos = 1;
      } else if (typeof yPosition === 'number') {
        yPos = yPosition;
      } else if (typeof yPosition === 'string' && yPosition.slice(-1)[0] === 'a') {
        var ascentPercentage = parseFloat(yPosition);
        var ascentPercentHeight = contentToAnnotateBounds.ascent / contentToAnnotateBounds.height;
        var descentPercentHeight = contentToAnnotateBounds.descent / contentToAnnotateBounds.height;
        yPos = ascentPercentHeight * ascentPercentage + descentPercentHeight;
      } else {
        // baseline
        yPos = contentToAnnotateBounds.descent / contentToAnnotateBounds.height;
      }

      yPos = yPos * contentToAnnotateBounds.height + locationContentToAnnotate.y - contentToAnnotateBounds.descent;
      var contentBounds = content.getBounds(fullContentBounds);

      if (xAlign === 'center') {
        xPos -= contentBounds.width * 0.5;
      } else if (xAlign === 'right') {
        xPos -= contentBounds.width;
      } else if (typeof xAlign === 'number') {
        xPos -= contentBounds.width * xAlign;
      }

      if (yAlign === 'bottom') {
        yPos += contentBounds.descent;
      } else if (yAlign === 'middle') {
        yPos = yPos + contentBounds.descent - contentBounds.height / 2;
      } else if (yAlign === 'top') {
        yPos -= contentBounds.ascent;
      } else if (typeof yAlign === 'string' && yAlign.slice(-1)[0] === 'a') {
        var _ascentPercentage = parseFloat(yAlign);

        yPos -= contentBounds.ascent * _ascentPercentage;
      } else if (typeof yAlign === 'number') {
        yPos += contentBounds.descent - contentBounds.height * yAlign;
      }

      var offsetToUse = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(offset);
      xPos += offsetToUse.x * scale;
      yPos += offsetToUse.y * scale;
      var locationOffset = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](xPos, yPos).sub(contentBounds.left, contentBounds.bottom + contentBounds.descent);
      content.offsetLocation(locationOffset);
    }
  }, {
    key: "getBounds",
    value: function getBounds() {
      var useFullSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (useFullSize && this.fullSize != null) {
        return new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]({
          left: this.location.x + this.fullSize.leftOffset,
          right: this.location.x + this.fullSize.leftOffset + this.fullSize.width,
          top: this.location.y + this.fullSize.ascent,
          bottom: this.location.y - this.fullSize.descent,
          width: this.fullSize.width,
          height: this.fullSize.height,
          ascent: this.fullSize.ascent,
          descent: this.fullSize.descent
        });
      }

      return new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]({
        left: this.location.x,
        right: this.location.x + this.width,
        top: this.location.y + this.ascent,
        bottom: this.location.y - this.descent,
        width: this.width,
        height: this.height,
        ascent: this.ascent,
        descent: this.descent
      });
    }
  }]);

  return BaseAnnotationFunction;
}();



/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/Elements/BaseEquationFunction.js":
/*!**********************************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/Elements/BaseEquationFunction.js ***!
  \**********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BaseEquationFunction; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Element */ "./src/js/diagram/DiagramElements/Equation/Elements/Element.js");
/* harmony import */ var _Symbols_SymbolNew__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Symbols/SymbolNew */ "./src/js/diagram/DiagramElements/Equation/Symbols/SymbolNew.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

 // import {
//   DiagramElementPrimitive, DiagramElementCollection,
// } from '../../../Element';



 // import type { ElementInterface } from './Element';
// import Bounds from './Bounds';

var BaseEquationFunction =
/*#__PURE__*/
function (_Elements) {
  _inherits(BaseEquationFunction, _Elements);

  // inSize: boolean;
  function BaseEquationFunction(content, glyph, // inSize: boolean = true,
  options) {
    var _this;

    _classCallCheck(this, BaseEquationFunction);

    var glyphElements = [];

    if (Array.isArray(glyph)) {
      glyph.forEach(function (g) {
        glyphElements.push(g != null ? new _Element__WEBPACK_IMPORTED_MODULE_2__["Element"](g) : null);
      });
    } else {
      glyphElements.push(glyph != null ? new _Element__WEBPACK_IMPORTED_MODULE_2__["Element"](glyph) : null);
    }

    var glyphs = [];

    if (Array.isArray(glyph)) {
      glyphs = glyph;
    } else {
      glyphs.push(glyph);
    }

    var contentArray = [];

    if (Array.isArray(content)) {
      contentArray = content;
    } else {
      contentArray.push(content);
    }

    _this = _possibleConstructorReturn(this, _getPrototypeOf(BaseEquationFunction).call(this, [].concat(glyphElements, _toConsumableArray(contentArray))));
    _this.glyphs = glyphs;
    _this.contents = contentArray;
    _this.glyphLocations = glyphElements.map(function () {
      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
    });
    _this.glyphWidths = glyphElements.map(function () {
      return 1;
    });
    _this.glyphHeights = glyphElements.map(function () {
      return 1;
    });
    _this.options = options; // this.fullSize = null;

    return _this;
  } // getFullSize(useFullSize: boolean) {
  //   if (useFullSize && this.full != null) {
  //     return {
  //       width: this.fullBounds.width,
  //       height: this.fullBounds.height,
  //       ascent: this.fullBounds.ascent,
  //       descent: this.fullBounds.descent,
  //     };
  //   }
  //   return {
  //     width: this.width,
  //     height: this.height,
  //     ascent: this.ascent,
  //     descent: this.descent,
  //   };
  // }


  _createClass(BaseEquationFunction, [{
    key: "_dup",
    value: function _dup(namedCollection) {
      var copyContent = this.contents.map(function (content) {
        return content == null ? null : content._dup(namedCollection);
      });
      var glyphs = this.glyphs; // let copyGlyphs = [];

      if (namedCollection) {
        var newGlyphs = [];
        this.glyphs.forEach(function (g) {
          if (g != null) {
            // $FlowFixMe
            newGlyphs.push(namedCollection[g.name]);
          } else {
            newGlyphs.push(g);
          }
        });
        glyphs = newGlyphs;
      }

      var copy = new this.constructor(copyContent, glyphs, this.options);
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["duplicateFromTo"])(this, copy, ['content', 'contents', 'glyphs']);
      return copy;
    }
  }, {
    key: "getAllElements",
    value: function getAllElements() {
      var elements = [];
      this.contents.forEach(function (c) {
        if (c != null) {
          elements = [].concat(_toConsumableArray(elements), _toConsumableArray(c.getAllElements()));
        }
      });
      this.glyphs.forEach(function (g) {
        if (g != null) {
          elements = [].concat(_toConsumableArray(elements), [g]);
        }
      });
      return elements;
    }
  }, {
    key: "setPositions",
    value: function setPositions() {
      var _this2 = this;

      this.glyphs.forEach(function (glyph, index) {
        if (glyph != null) {
          var t = glyph.getTransform()._dup();

          t.updateTranslation(_this2.glyphLocations[index].x, _this2.glyphLocations[index].y);
          t.updateScale(_this2.glyphWidths[index], _this2.glyphHeights[index]);
          glyph.setTransform(t);
        }
      });
      this.contents.forEach(function (content) {
        if (content != null) {
          content.setPositions();
        }
      });
    }
  }, {
    key: "offsetLocation",
    value: function offsetLocation() {
      var _this3 = this;

      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      this.location = this.location.add(offset);
      this.glyphLocations.forEach(function (glyphLocation, index) {
        if (_this3.glyphs[index] != null) {
          _this3.glyphLocations[index] = glyphLocation.add(offset);
        }
      });
      this.contents.forEach(function (content) {
        if (content != null) {
          content.offsetLocation(offset);
        }
      });
    } // eslint-disable-next-line class-methods-use-this, no-unused-vars

  }, {
    key: "calcSize",
    value: function calcSize(location, scale) {// this.location = ;
      // this.glyphLocations[] = ;
      // this.glyphHeights[] = ;
      // this.glyphWidths[] = ;
      // this.width = ;
      // this.ascent = ;
      // this.descent = ;
      // this.height = ;
      // this.fullSize = {
      //   leftOffset: ,
      //   width: ,
      //   ascent: ,
      //   descent: ,
      //   height: ,
      // };
    }
  }]);

  return BaseEquationFunction;
}(_Element__WEBPACK_IMPORTED_MODULE_2__["Elements"]);



/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/Elements/Bounds.js":
/*!********************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/Elements/Bounds.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Bounds; });
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }




var Bounds =
/*#__PURE__*/
function () {
  function Bounds() {
    var boundsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Bounds);

    var defaultBounds = {
      width: 0,
      height: 0,
      ascent: 0,
      descent: 0,
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    var bounds = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"])(defaultBounds, boundsIn);
    this.copyFrom(bounds);
  }

  _createClass(Bounds, [{
    key: "copyFrom",
    value: function copyFrom(from) {
      if (from.width != null) {
        this.width = from.width;
      }

      if (from.height != null) {
        this.height = from.height;
      }

      if (from.ascent != null) {
        this.ascent = from.ascent;
      }

      if (from.descent != null) {
        this.descent = from.descent;
      }

      if (from.left != null) {
        this.left = from.left;
      }

      if (from.right != null) {
        this.right = from.right;
      }

      if (from.top != null) {
        this.top = from.top;
      }

      if (from.bottom != null) {
        this.bottom = from.bottom;
      }
    }
  }, {
    key: "leftOffset",
    value: function leftOffset(leftDelta) {
      this.left += leftDelta;
      this.width = this.right - this.left;
    }
  }, {
    key: "rightOffset",
    value: function rightOffset(rightDelta) {
      this.right += rightDelta;
      this.width = this.right - this.left;
    }
  }, {
    key: "topOffset",
    value: function topOffset(topDelta) {
      this.top += topDelta;
      this.ascent += topDelta;
      this.height = this.ascent + this.descent;
    }
  }, {
    key: "bottomOffset",
    value: function bottomOffset(bottomDelta) {
      this.bottom += bottomDelta;
      this.descent -= bottomDelta;
      this.height = this.ascent + this.descent;
    }
  }, {
    key: "offset",
    value: function offset(top, right, bottom, left) {
      this.left += left;
      this.right += right;
      this.top += top;
      this.ascent += top;
      this.descent -= bottom;
      this.bottom += bottom;
      this.width = this.right - this.left;
      this.height = this.ascent + this.descent;
    }
  }, {
    key: "growWithSameBaseline",
    value: function growWithSameBaseline(newBounds) {
      var baseline = this.bottom + this.descent;

      if (newBounds.left < this.left) {
        this.left = newBounds.left;
      }

      if (newBounds.right > this.right) {
        this.right = newBounds.right;
      }

      if (newBounds.top > this.top) {
        this.top = newBounds.top;
      }

      if (newBounds.bottom < this.bottom) {
        this.bottom = newBounds.bottom;
      }

      this.width = this.right - this.left;
      this.height = this.top - this.bottom;
      this.ascent = this.top - baseline;
      this.descent = baseline - this.bottom;
    }
  }]);

  return Bounds;
}();



/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/Elements/Container.js":
/*!***********************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/Elements/Container.js ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Container; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _Bounds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bounds */ "./src/js/diagram/DiagramElements/Equation/Elements/Bounds.js");
/* harmony import */ var _BaseEquationFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BaseEquationFunction */ "./src/js/diagram/DiagramElements/Equation/Elements/BaseEquationFunction.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





var Container =
/*#__PURE__*/
function (_BaseEquationFunction) {
  _inherits(Container, _BaseEquationFunction);

  function Container() {
    _classCallCheck(this, Container);

    return _possibleConstructorReturn(this, _getPrototypeOf(Container).apply(this, arguments));
  }

  _createClass(Container, [{
    key: "calcSize",
    value: function calcSize(location, scale) {
      this.location = location._dup();

      var loc = location._dup();

      var _this$options = this.options,
          width = _this$options.width,
          descent = _this$options.descent,
          ascent = _this$options.ascent,
          xAlign = _this$options.xAlign,
          yAlign = _this$options.yAlign,
          fit = _this$options.fit,
          scaleModifier = _this$options.scaleModifier,
          fullContentBounds = _this$options.fullContentBounds;

      var _this$contents = _slicedToArray(this.contents, 1),
          mainContent = _this$contents[0];

      var contentBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();
      var containerBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();
      var fullBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();

      if (mainContent != null) {
        mainContent.calcSize(loc._dup(), scale * scaleModifier);
        contentBounds.copyFrom(mainContent.getBounds(fullContentBounds)); // contentBounds.copyFrom(mainContent);

        containerBounds.copyFrom(contentBounds);
      }

      if (width != null) {
        containerBounds.width = width;
      }

      if (descent != null) {
        containerBounds.descent = descent;
      }

      if (ascent != null) {
        containerBounds.ascent = ascent;
      }

      containerBounds.height = containerBounds.descent + containerBounds.ascent;

      if (mainContent != null) {
        if (fit === 'width') {
          mainContent.calcSize(loc._dup(), containerBounds.width / contentBounds.width);
        } else if (fit === 'height') {
          mainContent.calcSize(loc._dup(), containerBounds.height / contentBounds.height);
        } else if (fit === 'contain') {
          var newScale = Math.min(containerBounds.width / contentBounds.width, containerBounds.height / contentBounds.height);
          mainContent.calcSize(loc._dup(), newScale);
        }

        contentBounds.copyFrom(mainContent);
      }

      var contentLoc = loc._dup();

      if (xAlign === 'center') {
        contentLoc.x = loc.x + containerBounds.width / 2 - contentBounds.width / 2;
      } else if (xAlign === 'right') {
        contentLoc.x = loc.x + containerBounds.width - contentBounds.width;
      } else if (typeof xAlign === 'number') {
        contentLoc.x = loc.x + containerBounds.width * xAlign;
      }

      if (yAlign === 'bottom') {
        contentLoc.y = loc.y - containerBounds.descent + contentBounds.descent;
      } else if (yAlign === 'middle') {
        contentLoc.y = loc.y - containerBounds.descent + containerBounds.height / 2 - contentBounds.height / 2 + contentBounds.descent;
      } else if (yAlign === 'top') {
        contentLoc.y = loc.y + containerBounds.ascent - contentBounds.height + contentBounds.descent;
      } else if (typeof yAlign === 'number') {
        contentLoc.y = loc.y - containerBounds.descent + containerBounds.height * yAlign + contentBounds.descent;
      }

      if (mainContent != null) {
        mainContent.offsetLocation(contentLoc.sub(mainContent.location));
      }

      if (mainContent != null) {
        fullBounds.copyFrom(mainContent.getBounds(true));
        fullBounds.growWithSameBaseline(containerBounds);
      } else {
        fullBounds.copyFrom(containerBounds);
      }

      this.width = containerBounds.width;
      this.height = containerBounds.height;
      this.descent = containerBounds.descent;
      this.ascent = containerBounds.ascent;
      this.fullSize = {
        leftOffset: this.location.x - fullBounds.left,
        width: fullBounds.width,
        ascent: fullBounds.ascent,
        descent: fullBounds.descent,
        height: fullBounds.height
      };
    }
  }]);

  return Container;
}(_BaseEquationFunction__WEBPACK_IMPORTED_MODULE_2__["default"]);



/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/Elements/Element.js":
/*!*********************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/Elements/Element.js ***!
  \*********************************************************************/
/*! exports provided: BlankElement, Element, Elements */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlankElement", function() { return BlankElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Element", function() { return Element; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Elements", function() { return Elements; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _Bounds__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Bounds */ "./src/js/diagram/DiagramElements/Equation/Elements/Bounds.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../Element */ "./src/js/diagram/Element.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }






// Equation is a class that takes a set of drawing objects (TextObjects,
// DiagramElementPrimitives or DiagramElementCollections and HTML Objects
// and arranges their size in a )
var BlankElement =
/*#__PURE__*/
function () {
  function BlankElement() {
    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.03;
    var ascent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var descent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    _classCallCheck(this, BlankElement);

    this.width = width;
    this.ascent = ascent;
    this.descent = descent;
    this.height = this.ascent + this.descent;
  }

  _createClass(BlankElement, [{
    key: "_dup",
    value: function _dup() {
      return new BlankElement(this.width, this.ascent, this.descent);
    }
  }]);

  return BlankElement;
}();

var Element =
/*#__PURE__*/
function () {
  function Element(content) {
    _classCallCheck(this, Element);

    this.content = content;
    this.ascent = 0;
    this.descent = 0;
    this.width = 0;
    this.location = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
    this.height = 0;
    this.fullSize = {
      leftOffset: 0,
      width: this.width,
      height: this.height,
      ascent: this.ascent,
      descent: this.descent
    };
  }

  _createClass(Element, [{
    key: "calcSize",
    value: function calcSize(location, scale) {
      var content = this.content;

      if (content instanceof BlankElement) {
        this.width = content.width * scale;
        this.height = content.height * scale;
        this.ascent = content.ascent * scale;
        this.descent = content.descent * scale;
        this.location = location._dup();
        this.scale = scale;
      }

      if (content instanceof _Element__WEBPACK_IMPORTED_MODULE_3__["DiagramElementCollection"] || content instanceof _Element__WEBPACK_IMPORTED_MODULE_3__["DiagramElementPrimitive"]) {
        // Update translation and scale
        content.transform.updateTranslation(location.x, location.y);
        content.transform.updateScale(scale, scale);
        content.updateLastDrawTransform();

        if (content.internalSetTransformCallback != null) {
          content.internalSetTransformCallback(content.transform);
        } // Get the boundaries of element


        var r = content.getRelativeVertexSpaceBoundingRect();
        this.location = location._dup();
        this.scale = scale;
        this.ascent = r.top * scale;
        this.descent = -r.bottom * scale;
        this.height = r.height * scale;
        this.width = r.width * scale;
      }

      this.fullSize = {
        leftOffset: 0,
        width: this.width,
        height: this.height,
        ascent: this.ascent,
        descent: this.descent
      };
    }
  }, {
    key: "_dup",
    value: function _dup(namedCollection) {
      var c;

      if (this.content instanceof BlankElement) {
        c = new Element(this.content);
      } else if (namedCollection) {
        c = new Element(namedCollection[this.content.name]);
      } else {
        c = new Element(this.content);
      }

      c.ascent = this.ascent;
      c.descent = this.descent;
      c.width = this.width;
      c.location = this.location._dup();
      c.height = this.height;
      c.scale = this.scale;
      return c;
    } // getFullSize() {
    //   return this.fullSize;
    // }

  }, {
    key: "getAllElements",
    value: function getAllElements() {
      if (this.content instanceof BlankElement) {
        return [];
      }

      return [this.content];
    }
  }, {
    key: "setPositions",
    value: function setPositions() {
      var content = this.content;

      if (content instanceof _Element__WEBPACK_IMPORTED_MODULE_3__["DiagramElementCollection"] || content instanceof _Element__WEBPACK_IMPORTED_MODULE_3__["DiagramElementPrimitive"]) {
        content.transform.updateTranslation(this.location.x, this.location.y);
        content.transform.updateScale(this.scale, this.scale);
        content.updateLastDrawTransform();
      }
    }
  }, {
    key: "offsetLocation",
    value: function offsetLocation() {
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      this.location = this.location.add(offset);
    } // getFullBounds() {
    //   return new Bounds({
    //     left: this.location.x + this.fullSize.leftOffset,
    //     right: this.location.x + this.fullSize.leftOffset + this.fullSize.width,
    //     top: this.location.y + this.fullSize.ascent,
    //     bottom: this.location.y - this.fullSize.descent,
    //     width: this.fullSize.width,
    //     height: this.fullSize.height,
    //     ascent: this.fullSize.ascent,
    //     descent: this.fullSize.descent,
    //   });
    // }

  }, {
    key: "getBounds",
    value: function getBounds() {
      var useFullSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (useFullSize && this.fullSize != null) {
        return new _Bounds__WEBPACK_IMPORTED_MODULE_2__["default"]({
          left: this.location.x + this.fullSize.leftOffset,
          right: this.location.x + this.fullSize.leftOffset + this.fullSize.width,
          top: this.location.y + this.fullSize.ascent,
          bottom: this.location.y - this.fullSize.descent,
          width: this.fullSize.width,
          height: this.fullSize.height,
          ascent: this.fullSize.ascent,
          descent: this.fullSize.descent
        });
      }

      return new _Bounds__WEBPACK_IMPORTED_MODULE_2__["default"]({
        left: this.location.x,
        right: this.location.x + this.width,
        top: this.location.y + this.ascent,
        bottom: this.location.y - this.descent,
        width: this.width,
        height: this.height,
        ascent: this.ascent,
        descent: this.descent
      });
    }
  }]);

  return Element;
}();

var Elements =
/*#__PURE__*/
function () {
  function Elements(content) {
    _classCallCheck(this, Elements);

    var nonNullContent = [];
    content.forEach(function (c) {
      if (c !== null) {
        nonNullContent.push(c);
      }
    });
    this.content = nonNullContent;
    this.ascent = 0;
    this.descent = 0;
    this.width = 0;
    this.location = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
    this.height = 0;
  }

  _createClass(Elements, [{
    key: "_dup",
    value: function _dup(namedCollection) {
      var contentCopy = [];
      this.content.forEach(function (element) {
        return contentCopy.push(element._dup(namedCollection));
      });
      var c = new Elements(contentCopy);
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["duplicateFromTo"])(this, c, ['content']);
      return c;
    }
  }, {
    key: "calcSize",
    value: function calcSize(location, scale) {
      var des = 0;
      var asc = 0;

      var loc = location._dup();

      var fullBounds = null;
      this.content.forEach(function (element) {
        element.calcSize(loc, scale);
        loc.x += element.width;

        if (element.descent > des) {
          des = element.descent;
        }

        if (element.ascent > asc) {
          asc = element.ascent;
        }

        var fullElementBounds = element.getBounds(true);

        if (fullBounds == null) {
          fullBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_2__["default"]();
          fullBounds.copyFrom(fullElementBounds);
        }
      });

      if (fullBounds === null) {
        fullBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_2__["default"]();
        fullBounds.left = location.x;
        fullBounds.top = location.y;
        fullBounds.bottom = location.y;
      }

      this.width = loc.x - location.x;
      this.ascent = asc;
      this.descent = des;
      this.location = location._dup();
      this.height = this.descent + this.ascent;
      this.fullSize = {
        leftOffset: this.location.x - fullBounds.left,
        width: fullBounds.width,
        ascent: fullBounds.ascent,
        descent: fullBounds.descent,
        height: fullBounds.height
      };
    } // getFullBounds() {
    //   // const fullSize = {
    //   //   leftOffset: 0,
    //   //   width: this.width,
    //   //   ascent: this.ascent,
    //   //   descent: this.descent,
    //   //   height: this.height,
    //   // };
    //   // const bounds = new Bounds();
    //   // bounds.width = this.width;
    //   // bounds.left = this.location.x;
    //   // bounds.right = bounds.left + bounds.right;
    //   // bounds.bottom = this.location.y - this.descent;
    //   // bounds.top = this.location.y + this.ascent;
    //   // bounds.ascent = this.ascent;
    //   // bounds.descent = this.descent;
    //   // bounds.height = this.height;
    //   const bounds = new Bounds();
    //   bounds.left = this.location.x;
    //   bounds.bottom = this.location.y;
    //   bounds.top = this.location.y;
    //   this.content.forEach((element) => {
    //     const elementBounds = element.getBounds();
    //     bounds.growWithSameBaseline(elementBounds);
    //   });
    //   return bounds;
    // }

  }, {
    key: "getAllElements",
    value: function getAllElements() {
      var elements = [];
      this.content.forEach(function (e) {
        elements = [].concat(_toConsumableArray(elements), _toConsumableArray(e.getAllElements()));
      });
      return elements;
    }
  }, {
    key: "setPositions",
    value: function setPositions() {
      this.content.forEach(function (e) {
        e.setPositions();
      });
    }
  }, {
    key: "offsetLocation",
    value: function offsetLocation() {
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      this.location = this.location.add(offset);
      this.content.forEach(function (e) {
        e.offsetLocation(offset);
      });
    }
  }, {
    key: "getBounds",
    value: function getBounds() {
      var useFullSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (useFullSize && this.fullSize != null) {
        return new _Bounds__WEBPACK_IMPORTED_MODULE_2__["default"]({
          left: this.location.x + this.fullSize.leftOffset,
          right: this.location.x + this.fullSize.leftOffset + this.fullSize.width,
          top: this.location.y + this.fullSize.ascent,
          bottom: this.location.y - this.fullSize.descent,
          width: this.fullSize.width,
          height: this.fullSize.height,
          ascent: this.fullSize.ascent,
          descent: this.fullSize.descent
        });
      }

      return new _Bounds__WEBPACK_IMPORTED_MODULE_2__["default"]({
        left: this.location.x,
        right: this.location.x + this.width,
        top: this.location.y + this.ascent,
        bottom: this.location.y - this.descent,
        width: this.width,
        height: this.height,
        ascent: this.ascent,
        descent: this.descent
      });
    }
  }]);

  return Elements;
}();



/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/Elements/Fraction.js":
/*!**********************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/Elements/Fraction.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Fraction; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _Bounds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bounds */ "./src/js/diagram/DiagramElements/Equation/Elements/Bounds.js");
/* harmony import */ var _BaseEquationFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BaseEquationFunction */ "./src/js/diagram/DiagramElements/Equation/Elements/BaseEquationFunction.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }



 // // Equation is a class that takes a set of drawing objects (TextObjects,
// // DiagramElementPrimitives or DiagramElementCollections and HTML Objects
// // and arranges their size in a )

var Fraction =
/*#__PURE__*/
function (_BaseEquationFunction) {
  _inherits(Fraction, _BaseEquationFunction);

  function Fraction() {
    _classCallCheck(this, Fraction);

    return _possibleConstructorReturn(this, _getPrototypeOf(Fraction).apply(this, arguments));
  }

  _createClass(Fraction, [{
    key: "calcSize",
    value: function calcSize(location, incomingScale) {
      this.location = location._dup();

      var loc = location._dup();

      var _this$glyphs = _slicedToArray(this.glyphs, 1),
          vinculum = _this$glyphs[0];

      var _this$contents = _slicedToArray(this.contents, 2),
          numerator = _this$contents[0],
          denominator = _this$contents[1];

      var _this$options = this.options,
          scaleModifier = _this$options.scaleModifier,
          numeratorSpace = _this$options.numeratorSpace,
          denominatorSpace = _this$options.denominatorSpace,
          overhang = _this$options.overhang,
          offsetY = _this$options.offsetY,
          fullContentBounds = _this$options.fullContentBounds;
      var scale = incomingScale * scaleModifier;
      var vinculumBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();
      var numeratorBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();
      var denominatorBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();
      var fullBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();

      if (numerator != null) {
        numerator.calcSize(loc._dup(), scale);
        numeratorBounds.copyFrom(numerator.getBounds(fullContentBounds));
      }

      if (denominator != null) {
        denominator.calcSize(loc._dup(), scale);
        denominatorBounds.copyFrom(denominator.getBounds(fullContentBounds));
      }

      this.location = location._dup(); // numerator.calcSize(location, scale);
      // denominator.calcSize(location, scale);

      vinculumBounds.width = Math.max(numeratorBounds.width, denominatorBounds.width) + overhang * 2 * scale;

      if (vinculum != null) {
        vinculumBounds.height = vinculum.getHeight(vinculum.custom.options, vinculumBounds.width);
      } // const vSpaceNum = scale * numeratorSpace;
      // const vSpaceDenom = scale * denominatorSpace;


      var lineVAboveBaseline = scale * offsetY / scaleModifier;
      var numeratorLoc = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](loc.x + (vinculumBounds.width - numeratorBounds.width) / 2, loc.y + lineVAboveBaseline + vinculumBounds.height + numeratorSpace * scale + numeratorBounds.descent);
      var denominatorLoc = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](loc.x + (vinculumBounds.width - denominatorBounds.width) / 2, loc.y + lineVAboveBaseline - denominatorSpace * scale - denominatorBounds.ascent); // const xNumerator = (vinculumBounds.width - numeratorBounds.width) / 2;
      // const xDenominator = (vinculumBounds.width - denominatorBounds.width) / 2;
      // const lineWidth = Math.max(scale * 0.01, 0.008);
      // const yNumerator = numeratorBounds.descent
      //                     + vSpaceNum + lineVAboveBaseline;
      // const yDenominator = denominatorBounds.ascent
      //                      + vSpaceDenom - lineVAboveBaseline;

      if (numerator != null) {
        numerator.offsetLocation(numeratorLoc.sub(numerator.location));
      }

      if (denominator != null) {
        denominator.offsetLocation(denominatorLoc.sub(denominator.location));
      }

      this.width = vinculumBounds.width;
      this.descent = loc.y - (denominatorLoc.y - denominatorBounds.descent); // vSpaceNum + lineWidth / 2
      //                - lineVAboveBaseline
      //                + denominatorBounds.ascent + denominatorBounds.descent;

      if (this.descent < 0) {
        this.descent = 0;
      }

      this.ascent = numeratorLoc.y + numeratorBounds.ascent - loc.y; // vSpaceNum + lineWidth / 2
      //               + lineVAboveBaseline + numeratorBounds.ascent
      //               + numeratorBounds.descent;

      this.height = this.descent + this.ascent;
      this.glyphLocations[0] = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](this.location.x, this.location.y + lineVAboveBaseline);
      this.glyphWidths[0] = vinculumBounds.width;
      this.glyphHeights[0] = vinculumBounds.height;
      fullBounds.copyFrom(vinculumBounds);
      fullBounds.left = this.glyphLocations[0].x;
      fullBounds.bottom = this.glyphLocations[0].y;

      if (numerator != null) {
        fullBounds.growWithSameBaseline(numerator.getBounds(true));
      }

      if (denominator != null) {
        fullBounds.growWithSameBaseline(denominator.getBounds(true));
      }

      if (vinculum) {
        vinculum.custom.setSize(this.glyphLocations[0], vinculumBounds.width, vinculumBounds.height);
      }

      this.fullSize = {
        leftOffset: this.location.x - fullBounds.left,
        width: fullBounds.width,
        ascent: fullBounds.ascent,
        descent: fullBounds.descent,
        height: fullBounds.height
      };
    }
  }]);

  return Fraction;
}(_BaseEquationFunction__WEBPACK_IMPORTED_MODULE_2__["default"]);



/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/Elements/Matrix.js":
/*!********************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/Elements/Matrix.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Matrix; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _Bounds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bounds */ "./src/js/diagram/DiagramElements/Equation/Elements/Bounds.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Element */ "./src/js/diagram/DiagramElements/Equation/Elements/Element.js");
/* harmony import */ var _BaseEquationFunction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BaseEquationFunction */ "./src/js/diagram/DiagramElements/Equation/Elements/BaseEquationFunction.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }






function getMaxAscentDescent(numRows, numCols, matrix, bounds) {
  var rowAscents = [];
  var rowDescents = [];
  var rowHeights = [];
  var maxAscent = 0;
  var maxDescent = 0;
  var maxHeight = 0;

  for (var row = 0; row < numRows; row += 1) {
    var rowMaxAscent = 0;
    var rowMaxDescent = 0; // let rowMaxHeight = 0;

    for (var col = 0; col < numCols; col += 1) {
      var bound = bounds[row][col];

      if (bound.ascent > rowMaxAscent || col === 0) {
        rowMaxAscent = bound.ascent;
      }

      if (bound.descent > rowMaxDescent || col === 0) {
        rowMaxDescent = bound.descent;
      }
    }

    if (rowMaxAscent > maxAscent || row === 0) {
      maxAscent = rowMaxAscent;
    }

    if (rowMaxDescent > maxDescent || row === 0) {
      maxDescent = rowMaxDescent;
    }

    var rowMaxHeight = rowMaxDescent + rowMaxAscent;

    if (rowMaxHeight > maxHeight || row === 0) {
      maxHeight = rowMaxHeight;
    }

    rowHeights.push(rowMaxHeight);
    rowAscents.push(rowMaxAscent);
    rowDescents.push(rowMaxDescent);
  }

  return {
    ascents: rowAscents,
    descents: rowDescents,
    heights: rowHeights,
    maxAscent: maxAscent,
    maxDescent: maxDescent,
    maxHeight: maxHeight
  };
}

function getMaxColWidth(numRows, numCols, matrix, bounds) {
  var colWidths = [];
  var maxWidth = 0;

  for (var col = 0; col < numCols; col += 1) {
    var maxColWidth = 0;

    for (var row = 0; row < numRows; row += 1) {
      var elementWidth = bounds[row][col].width;

      if (elementWidth > maxColWidth) {
        maxColWidth = elementWidth;
      }

      if (elementWidth > maxWidth) {
        maxWidth = elementWidth;
      }
    }

    colWidths.push(maxColWidth);
  }

  return [colWidths, maxWidth];
} // Matrix is centered in y.


var Matrix =
/*#__PURE__*/
function (_BaseEquationFunction) {
  _inherits(Matrix, _BaseEquationFunction);

  function Matrix() {
    _classCallCheck(this, Matrix);

    return _possibleConstructorReturn(this, _getPrototypeOf(Matrix).apply(this, arguments));
  }

  _createClass(Matrix, [{
    key: "calcSize",
    value: function calcSize(location, scale) {
      this.location = location._dup();

      var loc = location._dup();

      var aboveBaseline = scale * 0.07;
      var _this$options = this.options,
          order = _this$options.order,
          fit = _this$options.fit,
          space = _this$options.space,
          contentScale = _this$options.contentScale,
          yAlign = _this$options.yAlign,
          fullContentBounds = _this$options.fullContentBounds;

      var _order = _slicedToArray(order, 2),
          numRows = _order[0],
          numCols = _order[1];

      var bounds = [];
      var locs = [];
      var index = 0;
      var matrix = [];

      for (var row = 0; row < numRows; row += 1) {
        matrix.push([]);
        bounds.push([]);
        locs.push([]);

        for (var col = 0; col < numCols; col += 1) {
          var elementBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();
          var element = this.contents[index];

          if (element != null) {
            element.calcSize(loc._dup(), scale * contentScale);
            elementBounds.copyFrom(element.getBounds(fullContentBounds));
          }

          matrix[row].push(element);
          bounds[row].push(elementBounds);
          locs[row].push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0));
          index += 1;
        }
      }

      var rowBounds = getMaxAscentDescent(numRows, numCols, matrix, bounds);

      var _getMaxColWidth = getMaxColWidth(numRows, numCols, matrix, bounds),
          _getMaxColWidth2 = _slicedToArray(_getMaxColWidth, 2),
          colWidths = _getMaxColWidth2[0],
          maxWidth = _getMaxColWidth2[1];

      var maxDim = Math.max(maxWidth, rowBounds.maxHeight);

      if (fit !== 'min') {
        var dim;

        if (fit === 'max') {
          dim = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](maxDim, maxDim);
        } else {
          dim = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["parsePoint"])(fit);

          if (dim == null) {
            dim = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
          }
        }

        for (var _row = 0; _row < numRows; _row += 1) {
          rowBounds.heights[_row] = dim.y;
        }

        for (var _col = 0; _col < numCols; _col += 1) {
          colWidths[_col] = dim.x;
        }
      }

      var cumHeight = 0;
      var cumWidth = 0;

      for (var _row2 = numRows - 1; _row2 >= 0; _row2 -= 1) {
        cumWidth = 0;

        for (var _col2 = 0; _col2 < numCols; _col2 += 1) {
          var bound = bounds[_row2][_col2];
          var x = cumWidth + colWidths[_col2] / 2 - bound.width / 2;
          var y = cumHeight + rowBounds.heights[_row2] / 2 - (bound.ascent - bound.descent) / 2;

          if (yAlign === 'baseline') {
            y = cumHeight + rowBounds.descents[_row2];
          }

          cumWidth += colWidths[_col2] + space.x * scale;
          locs[_row2][_col2] = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](x, y);
        }

        if (yAlign === 'baseline') {
          cumHeight += rowBounds.descents[_row2] + rowBounds.ascents[_row2] + space.y * scale;
        } else {
          cumHeight += rowBounds.heights[_row2] + space.y * scale;
        }
      }

      var totalHeight = cumHeight - space.y * scale;
      var totalWidth = cumWidth - space.x * scale;
      var fullBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();

      for (var _row3 = 0; _row3 < numRows; _row3 += 1) {
        for (var _col3 = 0; _col3 < numCols; _col3 += 1) {
          locs[_row3][_col3].x += loc.x;
          locs[_row3][_col3].y = loc.y - totalHeight / 2 + locs[_row3][_col3].y + aboveBaseline;
          var _element = matrix[_row3][_col3];

          if (_element != null) {
            _element.offsetLocation(locs[_row3][_col3].sub(_element.location));

            if (fullBounds.width === 0) {
              fullBounds.copyFrom(_element.getBounds(true));
            }

            fullBounds.growWithSameBaseline(_element.getBounds(true));
          }
        }
      }

      this.width = totalWidth;
      this.height = totalHeight;
      this.descent = totalHeight / 2 - aboveBaseline;
      this.ascent = totalHeight / 2 + aboveBaseline;
      this.fullSize = {
        leftOffset: this.location.x - fullBounds.left,
        width: fullBounds.width,
        ascent: fullBounds.ascent,
        descent: fullBounds.descent,
        height: fullBounds.height
      };
    }
  }]);

  return Matrix;
}(_BaseEquationFunction__WEBPACK_IMPORTED_MODULE_3__["default"]);



/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/Elements/Scale.js":
/*!*******************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/Elements/Scale.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Scale; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _Bounds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bounds */ "./src/js/diagram/DiagramElements/Equation/Elements/Bounds.js");
/* harmony import */ var _BaseEquationFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BaseEquationFunction */ "./src/js/diagram/DiagramElements/Equation/Elements/BaseEquationFunction.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





var Scale =
/*#__PURE__*/
function (_BaseEquationFunction) {
  _inherits(Scale, _BaseEquationFunction);

  function Scale() {
    _classCallCheck(this, Scale);

    return _possibleConstructorReturn(this, _getPrototypeOf(Scale).apply(this, arguments));
  }

  _createClass(Scale, [{
    key: "calcSize",
    value: function calcSize(location, scale) {
      this.location = location._dup();

      var loc = location._dup();

      var _this$options = this.options,
          scaleModifier = _this$options.scaleModifier,
          fullContentBounds = _this$options.fullContentBounds;

      var _this$contents = _slicedToArray(this.contents, 1),
          mainContent = _this$contents[0];

      var contentBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();
      var fullBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();

      if (mainContent != null) {
        mainContent.calcSize(loc._dup(), scale * scaleModifier);
        contentBounds.copyFrom(mainContent.getBounds(fullContentBounds));
        fullBounds.copyFrom(mainContent.getBounds(true));
      }

      this.width = contentBounds.width;
      this.height = contentBounds.height;
      this.descent = contentBounds.descent;
      this.ascent = contentBounds.ascent;
      this.fullSize = {
        leftOffset: this.location.x - fullBounds.left,
        width: fullBounds.width,
        ascent: fullBounds.ascent,
        descent: fullBounds.descent,
        height: fullBounds.height
      };
    }
  }]);

  return Scale;
}(_BaseEquationFunction__WEBPACK_IMPORTED_MODULE_2__["default"]);



/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/Equation.js":
/*!*************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/Equation.js ***!
  \*************************************************************/
/*! exports provided: Equation */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Equation", function() { return Equation; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../DrawingObjects/TextObject/TextObject */ "./src/js/diagram/DrawingObjects/TextObject/TextObject.js");
/* harmony import */ var _Elements_Element__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Elements/Element */ "./src/js/diagram/DiagramElements/Equation/Elements/Element.js");
/* harmony import */ var _Elements_BaseAnnotationFunction__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Elements/BaseAnnotationFunction */ "./src/js/diagram/DiagramElements/Equation/Elements/BaseAnnotationFunction.js");
/* harmony import */ var _EquationForm__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./EquationForm */ "./src/js/diagram/DiagramElements/Equation/EquationForm.js");
/* harmony import */ var _tools_htmlGenerator__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../tools/htmlGenerator */ "./src/js/tools/htmlGenerator.js");
/* harmony import */ var _EquationSymbols__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./EquationSymbols */ "./src/js/diagram/DiagramElements/Equation/EquationSymbols.js");
/* harmony import */ var _EquationFunctions__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./EquationFunctions */ "./src/js/diagram/DiagramElements/Equation/EquationFunctions.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }


 // import { RGBToArray } from '../../../tools/color';






// import HTMLObject from '../../DrawingObjects/HTMLObject/HTMLObject';



// export const foo = () => {};
// An Equation is a collection of elements that can be arranged into different
// forms.
// Equation allows setting of forms, and navigating through form series
// Eqn manages different forms of the

/**
 * An Equation is a collection of elements that can be arranged into different
 * forms.
 * @param {EQN_Equation} options
 * @example
 * // Create with options object
 * eqn = new Equation({
 *    elements: {
 *      a: 'a',
 *      b: 'b',
 *      c: 'c',
 *      equals: ' = ',
 *      plus: ' + ',
 *    },
 *    forms: {
 *      base: ['a', 'equals', 'b', 'plus', 'c'],
 *    },
 * );
 * @example
 * // Create with methods
 * eqn = new Equation();
 * eqn.addElements({
 *    a: 'a',
 *    b: 'b',
 *    c: 'c',
 *    equals: ' = ',
 *    plus: ' + ',
 *  });
 *  eqn.addForms({
 *    base: ['a', 'equals', 'b', 'plus', 'c'],
 *  });
 */
var Equation =
/*#__PURE__*/
function (_DiagramElementCollec) {
  _inherits(Equation, _DiagramElementCollec);

  /**
   * Equation parameters and functions
   * @property {EquationFunctions} functions - equation functions
   */
  // isTouchDevice: boolean;
  // animateNextFrame: void => void;
  function Equation(shapes) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Equation);

    var color = options.color;

    if (color == null) {
      color = [0.5, 0.5, 0.5, 1];
    }

    var defaultOptions = {
      color: color,
      fontMath: new _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_3__["DiagramFont"]('Times New Roman', 'normal', 0.2, '200', 'left', 'alphabetic', color),
      position: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
      scale: 0.7,
      defaultFormAlignment: {
        fixTo: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
        xAlign: 'left',
        yAlign: 'baseline'
      },
      elements: {},
      forms: {},
      formSeries: {},
      formRestart: null
    };
    var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, options);
    optionsToUse.position = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["parsePoint"])(optionsToUse.position, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0));
    optionsToUse.defaultFormAlignment.fixTo = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["parsePoint"])(optionsToUse.defaultFormAlignment.fixTo, optionsToUse.defaultFormAlignment.fixTo);

    if (optionsToUse.formRestart != null && optionsToUse.formRestart.pulse != null) {
      optionsToUse.formRestart.pulse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, {
        scale: 1.1,
        duration: 1
      }, optionsToUse.formRestart.pulse);
    }

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Equation).call(this, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('Equation').scale(1, 1).rotate(0).translate(0, 0), shapes.limits));
    _this.shapes = shapes;

    _this.setColor(optionsToUse.color); // this.isTouchDevice = isTouchDevice;
    // this.animateNextFrame = animateNextFrame;
    // Set default values


    _this.eqn = {
      forms: {},
      currentForm: '',
      currentSubForm: '',
      subFormPriority: ['base'],
      formSeries: {
        base: []
      },
      currentFormSeries: [],
      currentFormSeriesName: '',
      scale: optionsToUse.scale,
      defaultFormAlignment: optionsToUse.defaultFormAlignment,
      functions: new _EquationFunctions__WEBPACK_IMPORTED_MODULE_9__["EquationFunctions"](_this.elements, _this.addElementFromKey.bind(_assertThisInitialized(_this)), _this.getExistingOrAddSymbol.bind(_assertThisInitialized(_this))),
      symbols: new _EquationSymbols__WEBPACK_IMPORTED_MODULE_8__["default"](_this.shapes, _this.color),
      fontMath: optionsToUse.fontMath,
      // fontText: optionsToUse.fontText,
      isAnimating: false,
      descriptionElement: null,
      descriptionPosition: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
      formRestart: optionsToUse.formRestart
    };

    _this.setPosition(optionsToUse.position);

    if (optionsToUse.elements != null) {
      _this.addElements(optionsToUse.elements);
    }

    if (optionsToUse.forms != null) {
      _this.addForms(optionsToUse.forms);
    }

    if (optionsToUse.formSeries != null) {
      if (Array.isArray(optionsToUse.formSeries)) {
        _this.eqn.formSeries = {
          base: optionsToUse.formSeries
        };
        _this.eqn.currentFormSeries = _this.eqn.formSeries.base;
        _this.eqn.currentFormSeriesName = 'base';
      } else {
        _this.eqn.formSeries = optionsToUse.formSeries;

        if (optionsToUse.defaultFormSeries != null) {
          _this.setFormSeries(optionsToUse.defaultFormSeries);
        } else {
          _this.setFormSeries(Object.keys(_this.eqn.formSeries)[0]);
        }
      }
    }

    return _this;
  }
  /**
    * Set the current form series to 'name'
   */


  _createClass(Equation, [{
    key: "setFormSeries",
    value: function setFormSeries(name) {
      if (this.eqn.formSeries[name] != null) {
        this.eqn.currentFormSeries = this.eqn.formSeries[name];
        this.eqn.currentFormSeriesName = name;
      }
    }
    /**
      * Get the current form series name
     */

  }, {
    key: "getFormSeries",
    value: function getFormSeries() {
      return this.eqn.currentFormSeriesName;
    }
  }, {
    key: "makeTextElem",
    value: function makeTextElem(options) {
      var defaultText = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var textToUse = defaultText;

      if (options.text != null) {
        textToUse = options.text;
      }

      var fontToUse = this.eqn.fontMath; // if (textToUse.match(/[A-Z,a-z,\u03B8]/)) {
      //   fontToUse = this.eqn.fontText;
      // }

      var style;
      var weight;
      var scale;
      var size;

      if (options.style != null) {
        style = options.style;
      } else if (textToUse.match(/[A-Z,a-z,\u03B8]/)) {
        style = 'italic';
      }

      if (options.weight != null) {
        weight = options.weight;
      }

      if (options.scale != null) {
        scale = options.scale;
        size = scale * 0.2;
      }

      if (options.size != null) {
        size = options.size;
      }

      if (style != null || weight != null || size != null) {
        fontToUse = new _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_3__["DiagramFont"]('Times New Roman', style || 'normal', size || 0.2, weight || '200', 'left', 'alphabetic', this.color);
      }

      if (options.font != null) {
        fontToUse = options.font;
      }

      var p = this.shapes.text(textToUse, {
        position: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
        font: fontToUse
      });

      if (options.color != null) {
        p.setColor(options.color);
      } else {
        p.setColor(p.drawingObject.text[0].font.color);
      }

      return p;
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "getTextFromKey",
    value: function getTextFromKey(key) {
      return key.replace(/^_*/, '').replace(/_.*/, '');
    }
  }, {
    key: "getExistingOrAddSymbol",
    value: function getExistingOrAddSymbol(symbol) {
      if (typeof symbol === 'string') {
        return this.getExistingOrAddSymbolFromKey(symbol, {});
      }

      var _Object$entries$ = _slicedToArray(Object.entries(symbol)[0], 2),
          key = _Object$entries$[0],
          params = _Object$entries$[1]; // $FlowFixMe


      return this.getExistingOrAddSymbolFromKey(key, params);
    } // 'text'
    // 'text_id'
    // 'id_symbol'
    // 'id_id_symbol'
    // 'symbol'

  }, {
    key: "getExistingOrAddSymbolFromKey",
    value: function getExistingOrAddSymbolFromKey(key) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var existingElement = this.getElement(key);

      if (existingElement != null) {
        return existingElement;
      } // Check the key is a symbol


      var cleanKey = key.replace(/^_*/, '');
      var symbol = this.eqn.symbols.get(cleanKey, options);

      if (symbol != null) {
        symbol.setColor(this.color);
        this.add(key, symbol);
        return symbol;
      }

      var ending = cleanKey.match(/_[^_]*$/);

      if (ending != null) {
        symbol = this.eqn.symbols.get(ending[0].replace(/_/, ''), options);

        if (symbol != null) {
          symbol.setColor(this.color);
          this.add(key.replace(/_[^_]*$/, ''), symbol);
          return symbol;
        }
      }

      return null;
    }
  }, {
    key: "addElementFromKey",
    value: function addElementFromKey(key) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var element = this.getExistingOrAddSymbolFromKey(key, options);

      if (element != null) {
        return element;
      }

      var cleanKey = key.replace(/^_*/, '');
      var text = cleanKey.replace(/_.*/, '');
      element = this.makeTextElem(Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({
        text: text
      }, options));
      this.add(key, element);
      return element;
    } // addElementFromObject(key: string, options: Object) {
    //   if (typeof key !== 'string') {
    //     return null;
    //   }
    //   const existingElement = this.getElement(key);
    //   if (existingElement != null) {
    //     return existingElement;
    //   }
    //   const text = this.getTextFromKey(key);
    //   const element = this.makeTextElem({ text });
    //   this.add(key, element);
    //   return element;
    // }

  }, {
    key: "makeSymbolElem",
    value: function makeSymbolElem(options) {
      var symbol = this.eqn.symbols.get(options.symbol, options); // console.log('got', symbol)

      if (symbol == null) {
        symbol = this.makeTextElem({
          text: "Symbol ".concat(options.symbol, " not valid")
        });
      }

      if (options.color == null) {
        symbol.setColor(this.color);
      }

      return symbol;
    }
    /**
     * Add elements to equation.
     */

  }, {
    key: "addElements",
    value: function addElements(elems) {
      var _this2 = this;

      // Go through each element and add it
      Object.keys(elems).forEach(function (key) {
        // const [key, elem] = entry;
        var elem = elems[key];

        if (typeof elem === 'string') {
          if (!(key.startsWith('space') && key.startsWith(' '))) {
            _this2.add(key, _this2.makeTextElem({
              text: elem
            }));
          }
        } else if (elem instanceof _Element__WEBPACK_IMPORTED_MODULE_2__["DiagramElementPrimitive"]) {
          _this2.add(key, elem);
        } else if (elem instanceof _Element__WEBPACK_IMPORTED_MODULE_2__["DiagramElementCollection"]) {
          _this2.add(key, elem);
        } else {
          var diagramElem;

          if (elem.symbol != null && typeof elem.symbol === 'string') {
            // console.log(elem.symbol)
            // $FlowFixMe
            diagramElem = _this2.makeSymbolElem(elem);
          } else {
            // $FlowFixMe
            diagramElem = _this2.makeTextElem(elem, _this2.getTextFromKey(key));
          }

          if (diagramElem != null) {
            if (elem.mods != null) {
              diagramElem.setProperties(elem.mods);
            }

            _this2.add(key, diagramElem);
          }
        }
      });
      var fullLineHeightPrimitive = this.makeTextElem({
        text: 'gh'
      });
      var form = this.createForm({
        elem: fullLineHeightPrimitive
      });
      form.content = [this.eqn.functions.contentToElement(fullLineHeightPrimitive)];
      form.arrange(this.eqn.scale, 'left', 'baseline', new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0));
      this.eqn.functions.fullLineHeight = form;
      this.setFirstTransform(this.transform);
    }
  }, {
    key: "addDescriptionElement",
    value: function addDescriptionElement() {
      var descriptionElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var descriptionPosition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      this.eqn.descriptionElement = descriptionElement;
      this.eqn.descriptionPosition = descriptionPosition;

      if (this.eqn.descriptionElement) {
        this.eqn.descriptionElement.setPosition(this.getPosition('diagram').add(descriptionPosition));
      }
    }
  }, {
    key: "setPosition",
    value: function setPosition(pointOrX) {
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      _get(_getPrototypeOf(Equation.prototype), "setPosition", this).call(this, pointOrX, y);

      var position = this.getPosition('diagram'); // console.log(this.eqn, this.eqn.descriptionElement)

      if (this.eqn.descriptionElement != null) {
        this.eqn.descriptionElement.setPosition(position.add(this.eqn.descriptionPosition));
      }
    } // scaleForm(name: string, scale: number, subForm: string = 'base') {
    //   // console.log(name, this.form, formType, this.form[name][formType])
    //   if (name in this.eqn.forms) {
    //     if (subForm in this.eqn.forms[name]) {
    //       this.eqn.forms[name][subForm].arrange(
    //         scale,
    //         this.eqn.formAlignment.xAlign,
    //         this.eqn.formAlignment.yAlign,
    //         this.eqn.formAlignment.fixTo,
    //       );
    //     }
    //   }
    // }
    // scale(scale: number) {
    //   Object.keys(this.form).forEach((name) => {
    //     Object.keys(this.form[name]).forEach((formType) => {
    //       if (formType !== 'name') {
    //         this.scaleForm(name, scale, formType);
    //       }
    //     });
    //   });
    // }

  }, {
    key: "addPhrases",
    value: function addPhrases(phrases) {
      var _this3 = this;

      Object.keys(phrases).forEach(function (phraseName) {
        var phrase = phrases[phraseName];
        _this3.eqn.functions.phrases[phraseName] = phrase;
      });
    }
    /**
     * Add forms to equation.
     */

  }, {
    key: "addForms",
    value: function addForms(forms) {
      var _this4 = this;

      var isFormString = function isFormString(form) {
        return typeof form === 'string';
      };

      var isFormArray = function isFormArray(form) {
        return Array.isArray(form);
      };

      var isFormMethodDefinition = function isFormMethodDefinition(form) {
        if (isFormString(form) || isFormArray(form)) {
          return false;
        }

        if (form != null && _typeof(form) === 'object') {
          // $FlowFixMe
          var keys = Object.keys(form);

          if (keys.length === 1 && keys[0] in _this4.eqn.functions) {
            return true;
          }
        }

        return false;
      }; // eslint-disable-next-line max-len


      var isFormElements = function isFormElements(form) {
        return form instanceof _Elements_Element__WEBPACK_IMPORTED_MODULE_4__["Elements"] || form instanceof _Elements_BaseAnnotationFunction__WEBPACK_IMPORTED_MODULE_5__["default"];
      };

      var isFormFullObject = function isFormFullObject(form) {
        if (isFormString(form) || isFormArray(form) || isFormMethodDefinition(form) || isFormElements(form)) {
          return false;
        }

        if (form != null && _typeof(form) === 'object' && form.content != null) {
          return true;
        }

        return false;
      };

      var addFormNormal = function addFormNormal(name, form) {
        // $FlowFixMe
        var formContent = [_this4.eqn.functions.contentToElement(form)];

        _this4.addForm(name, formContent);
      };

      var addFormFullObject = function addFormFullObject(name, form) {
        // $FlowFixMe
        var formContent = [_this4.eqn.functions.contentToElement(form.content)];
        var subForm = form.subForm,
            elementMods = form.elementMods,
            duration = form.duration,
            alignment = form.alignment,
            scale = form.scale,
            description = form.description,
            modifiers = form.modifiers,
            fromPrev = form.fromPrev,
            fromNext = form.fromNext,
            translation = form.translation;
        var options = {
          subForm: subForm,
          // addToSeries,
          elementMods: elementMods,
          duration: duration,
          translation: translation,
          alignment: alignment,
          scale: scale,
          description: description,
          modifiers: modifiers,
          fromPrev: fromPrev,
          fromNext: fromNext
        }; // $FlowFixMe

        _this4.addForm(name, formContent, options);
      };

      Object.keys(forms).forEach(function (name) {
        var form = forms[name];

        if (isFormString(form) || isFormArray(form) || isFormMethodDefinition(form) || isFormElements(form)) {
          addFormNormal(name, form);
        } else if (isFormFullObject(form)) {
          addFormFullObject(name, form);
        } else {
          Object.entries(form).forEach(function (subFormEntry) {
            var _subFormEntry = _slicedToArray(subFormEntry, 2),
                subFormName = _subFormEntry[0],
                subFormValue = _subFormEntry[1]; // const subFormOption = { subForm: subFormName };


            if (isFormString(subFormValue) || isFormArray(subFormValue) || isFormMethodDefinition(subFormValue) || isFormElements(subFormValue)) {
              // $FlowFixMe
              addFormFullObject(name, {
                content: subFormValue,
                subForm: subFormName
              });
            } else {
              // $FlowFixMe
              addFormFullObject(name, Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(subFormValue, {
                subForm: subFormName
              }));
            }
          });
        }
      });
    }
  }, {
    key: "checkFixTo",
    value: function checkFixTo(fixTo) {
      if (typeof fixTo === 'string') {
        var element = Object(_EquationFunctions__WEBPACK_IMPORTED_MODULE_9__["getDiagramElement"])(this, fixTo);

        if (element != null) {
          return element;
        }

        return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      }

      if (fixTo instanceof _Element__WEBPACK_IMPORTED_MODULE_2__["DiagramElementPrimitive"] || fixTo instanceof _Element__WEBPACK_IMPORTED_MODULE_2__["DiagramElementCollection"] || fixTo instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"]) {
        return fixTo;
      }

      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
    }
  }, {
    key: "createForm",
    value: function createForm() {
      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.elements;
      return new _EquationForm__WEBPACK_IMPORTED_MODULE_6__["default"](elements, {
        getAllElements: this.getAllElements.bind(this),
        hideAll: this.hideAll.bind(this),
        show: this.show.bind(this),
        showOnly: this.showOnly.bind(this),
        stop: this.stop.bind(this),
        getElementTransforms: this.getElementTransforms.bind(this),
        setElementTransforms: this.setElementTransforms.bind(this),
        animateToTransforms: this.animateToTransforms.bind(this)
      });
    }
  }, {
    key: "addForm",
    value: function addForm(name, content) {
      var _this5 = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (!(name in this.eqn.forms)) {
        // $FlowFixMe   - its ok for this to start undefined, it will be filled.
        this.eqn.forms[name] = {};
      }

      var defaultOptions = {
        subForm: 'base',
        elementMods: {},
        duration: undefined,
        // duration: null,                // use velocities instead of time
        description: '',
        modifiers: {},
        scale: this.eqn.scale,
        alignment: this.eqn.defaultFormAlignment,
        translation: {},
        fromNext: undefined,
        fromPrev: undefined
      };
      var optionsToUse = defaultOptions;

      if (options) {
        optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, options);
      }

      var _optionsToUse = optionsToUse,
          subForm = _optionsToUse.subForm,
          description = _optionsToUse.description,
          modifiers = _optionsToUse.modifiers,
          duration = _optionsToUse.duration;
      this.eqn.forms[name].name = name;
      var form = this.eqn.forms[name];
      form[subForm] = this.createForm();
      form[subForm].description = description;
      form[subForm].modifiers = modifiers;
      form[subForm].name = name;
      form[subForm].subForm = subForm;
      form[subForm].duration = duration; // Populate element mods

      form[subForm].elementMods = {};
      Object.keys(optionsToUse.elementMods).forEach(function (elementName) {
        var mods = optionsToUse.elementMods[elementName];
        var diagramElement = Object(_EquationFunctions__WEBPACK_IMPORTED_MODULE_9__["getDiagramElement"])(_this5, elementName);

        if (diagramElement != null) {
          form[subForm].elementMods[elementName] = {
            element: diagramElement,
            mods: mods
          };
        }
      }); // Populate translation mods

      form[subForm].translation = {};
      Object.keys(optionsToUse.translation).forEach(function (elementName) {
        var mods = optionsToUse.translation[elementName];
        var diagramElement = Object(_EquationFunctions__WEBPACK_IMPORTED_MODULE_9__["getDiagramElement"])(_this5, elementName);
        var direction;
        var style;
        var mag;

        if (Array.isArray(mods)) {
          var _mods = _slicedToArray(mods, 3);

          style = _mods[0];
          direction = _mods[1];
          mag = _mods[2];
        } else {
          style = mods.style;
          direction = mods.direction;
          mag = mods.mag;
        }

        if (diagramElement != null) {
          form[subForm].translation[elementName] = {
            element: diagramElement,
            style: style,
            direction: direction,
            mag: mag
          };
        }
      }); // Populate translation mods

      var _optionsToUse2 = optionsToUse,
          fromPrev = _optionsToUse2.fromPrev;

      if (fromPrev != null) {
        form[subForm].fromPrev = {};

        if (fromPrev.duration !== undefined) {
          form[subForm].fromPrev.duration = fromPrev.duration;
        }

        form[subForm].fromPrev.translation = {};

        if (fromPrev.translation != null) {
          Object.keys(fromPrev.translation).forEach(function (elementName) {
            var mods = fromPrev.translation[elementName];
            var diagramElement = Object(_EquationFunctions__WEBPACK_IMPORTED_MODULE_9__["getDiagramElement"])(_this5, elementName);
            var direction;
            var style;
            var mag;

            if (Array.isArray(mods)) {
              var _mods2 = _slicedToArray(mods, 3);

              style = _mods2[0];
              direction = _mods2[1];
              mag = _mods2[2];
            } else {
              style = mods.style;
              direction = mods.direction;
              mag = mods.mag;
            }

            if (diagramElement != null) {
              // $FlowFixMe
              form[subForm].fromPrev.translation[elementName] = {
                element: diagramElement,
                style: style,
                direction: direction,
                mag: mag
              };
            }
          });
        }
      } // Populate translation mods


      var _optionsToUse3 = optionsToUse,
          fromNext = _optionsToUse3.fromNext;

      if (fromNext != null) {
        form[subForm].fromNext = {};

        if (fromNext.duration !== undefined) {
          form[subForm].fromNext.duration = fromNext.duration;
        }

        form[subForm].fromNext.translation = {};

        if (fromNext.translation != null) {
          Object.keys(fromNext.translation).forEach(function (elementName) {
            var mods = fromNext.translation[elementName];
            var diagramElement = Object(_EquationFunctions__WEBPACK_IMPORTED_MODULE_9__["getDiagramElement"])(_this5, elementName);
            var direction;
            var style;
            var mag;

            if (Array.isArray(mods)) {
              var _mods3 = _slicedToArray(mods, 3);

              style = _mods3[0];
              direction = _mods3[1];
              mag = _mods3[2];
            } else {
              style = mods.style;
              direction = mods.direction;
              mag = mods.mag;
            }

            if (diagramElement != null) {
              // $FlowFixMe
              form[subForm].fromNext.translation[elementName] = {
                element: diagramElement,
                style: style,
                direction: direction,
                mag: mag
              };
            }
          });
        }
      }

      optionsToUse.alignment.fixTo = this.checkFixTo(optionsToUse.alignment.fixTo);
      form[subForm].content = content;
      form[subForm].arrange(optionsToUse.scale, optionsToUse.alignment.xAlign, optionsToUse.alignment.yAlign, optionsToUse.alignment.fixTo); // const { addToSeries } = optionsToUse;
      // console.log(addToSeries)
      // if (addToSeries != null && addToSeries !== '' && typeof addToSeries === 'string') {
      //   if (this.eqn.formSeries[addToSeries] == null) {
      //     this.eqn.formSeries[addToSeries] = [];
      //   }
      //   this.eqn.formSeries[addToSeries].push(form);
      // }
      // make the first form added also equal to the base form as always
      // need a base form for some functions

      if (this.eqn.forms[name].base === undefined) {
        var baseOptions = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, optionsToUse);
        baseOptions.subForm = 'base';
        this.addForm(name, content, baseOptions);
      }

      if (this.eqn.currentForm === '') {
        this.eqn.currentForm = name;
      }

      if (this.eqn.currentSubForm === '') {
        this.eqn.currentSubForm = 'base';
      }
    }
    /**
     * Get the current equation form
     */

  }, {
    key: "getCurrentForm",
    value: function getCurrentForm() {
      if (this.eqn.forms[this.eqn.currentForm] == null) {
        return null;
      }

      if (this.eqn.forms[this.eqn.currentForm][this.eqn.currentSubForm] == null) {
        return null;
      }

      return this.eqn.forms[this.eqn.currentForm][this.eqn.currentSubForm];
    }
  }, {
    key: "render",
    value: function render() {
      var animationStop = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var form = this.getCurrentForm();

      if (form != null) {
        form.setPositions();
        form.showHide(0, 0, null, animationStop);
        this.show(); // form.setPositions();

        form.applyElementMods(); // this.updateDescription();
      }
    }
    /**
     * Set current equation form - Note, this does not show the form.
     */

  }, {
    key: "setCurrentForm",
    value: function setCurrentForm(formOrName) {
      var subForm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'base';

      if (typeof formOrName === 'string') {
        this.eqn.currentForm = '';
        this.eqn.currentSubForm = '';

        if (formOrName in this.eqn.forms) {
          this.eqn.currentForm = formOrName;

          if (subForm in this.eqn.forms[formOrName]) {
            this.eqn.currentSubForm = subForm;
          }
        }
      } else {
        this.eqn.currentForm = formOrName.name;
        this.eqn.currentSubForm = formOrName.subForm;
      }
    }
    /**
     * Show equation form
     */

  }, {
    key: "showForm",
    value: function showForm(formOrName) {
      var subForm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var animationStop = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      this.show();
      var form = formOrName;

      if (typeof formOrName === 'string') {
        form = this.getForm(formOrName, subForm);
      }

      if (form) {
        this.setCurrentForm(form);
        this.render(animationStop);
      }
    }
    /**
     * Get an equation form object from a form name
     */

  }, {
    key: "getForm",
    value: function getForm(formOrName, subForm) {
      var _this6 = this;

      if (formOrName instanceof _EquationForm__WEBPACK_IMPORTED_MODULE_6__["default"]) {
        return formOrName;
      }

      if (formOrName in this.eqn.forms) {
        var formTypeToUse = subForm;

        if (formTypeToUse == null) {
          var possibleFormTypes // $FlowFixMe
          = this.eqn.subFormPriority.filter(function (fType) {
            return fType in _this6.eqn.forms[formOrName];
          });

          if (possibleFormTypes.length) {
            // eslint-disable-next-line prefer-destructuring
            formTypeToUse = possibleFormTypes[0];
          }
        }

        if (formTypeToUse != null) {
          return this.eqn.forms[formOrName][formTypeToUse];
        }
      }

      return null;
    }
    /**
     Start an animation to an equation form
     */

  }, {
    key: "goToForm",
    value: function goToForm() {
      var _this7 = this;

      var optionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var defaultOptions = {
        duration: null,
        prioritizeFormDuration: true,
        delay: 0,
        fromWhere: null,
        animate: 'dissolve',
        callback: null,
        // finishAnimatingAndCancelGoTo: false,
        ifAnimating: {
          skipToTarget: true,
          cancelGoTo: true
        }
      };
      var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, optionsIn);

      if (this.eqn.isAnimating) {
        if (options.ifAnimating.skipToTarget) {
          this.stop(true, true);
          var currentForm = this.getCurrentForm();

          if (currentForm != null) {
            this.showForm(currentForm);
          }
        } else {
          this.stop(true, false);
        }

        this.eqn.isAnimating = false;

        if (options.ifAnimating.cancelGoTo) {
          return;
        }
      } // this.stop(true, true);
      // this.eqn.isAnimating = false;
      // Get the desired form - preference is name, then series index,
      // then next form in the current series


      var form;

      if (options.name != null) {
        form = this.eqn.forms[options.name];
      } else if (options.index != null) {
        form = this.eqn.forms[this.eqn.currentFormSeries[options.index]];
      } else if (this.eqn.currentFormSeries.length > 0) {
        var index = 0;

        var _currentForm = this.getCurrentForm();

        if (_currentForm != null) {
          index = this.eqn.currentFormSeries.indexOf(_currentForm.name);

          if (index < 0) {
            index = 0;
          }
        }

        var formIndex = index + 1;

        if (formIndex === this.eqn.currentFormSeries.length) {
          formIndex = 0;
        }

        form = this.eqn.forms[this.eqn.currentFormSeries[formIndex]];
      }

      if (form == null) {
        return;
      } // const nextForm = this.eqn.forms[this.eqn.currentFormSeries[formIndex]];


      var subForm = null;
      var subFormToUse = null;
      var possibleSubForms // $FlowFixMe - this is already checked above
      = this.eqn.subFormPriority.filter(function (sf) {
        return sf in form;
      });

      if (possibleSubForms.length) {
        // eslint-disable-next-line prefer-destructuring
        subFormToUse = possibleSubForms[0];
      }

      if (subFormToUse != null) {
        subForm = form[subFormToUse];
        var duration = options.duration;

        if (options.prioritizeFormDuration) {
          if (options.fromWhere === 'fromPrev' && subForm.fromPrev != null && subForm.fromPrev.duration !== undefined) {
            duration = subForm.fromPrev.duration;
          } else if (options.fromWhere === 'fromNext' && subForm.fromNext != null && subForm.fromNext.duration !== undefined) {
            duration = subForm.fromNext.duration;
          } else if (subForm.duration !== undefined) {
            var _subForm = subForm;
            duration = _subForm.duration;
          }
        }

        if (duration != null && duration > 0 && options.animate === 'dissolve') {
          if (options.dissolveOutTime == null) {
            options.dissolveOutTime = duration * 0.4;
          }

          if (options.dissolveInTime == null) {
            options.dissolveInTime = duration * 0.4;
          }

          if (options.blankTime == null) {
            options.blankTime = duration * 0.2;
          }
        } else {
          if (options.dissolveOutTime == null) {
            options.dissolveOutTime = 0.4;
          }

          if (options.dissolveInTime == null) {
            options.dissolveInTime = 0.4;
          }

          if (options.blankTime == null) {
            options.blankTime = 0.2;
          }
        }

        if (duration === 0) {
          this.showForm(subForm);

          if (options.callback != null) {
            options.callback();
          }
        } else {
          this.eqn.isAnimating = true;

          var end = function end() {
            _this7.eqn.isAnimating = false;

            if (options.callback != null) {
              options.callback();
            }
          };

          if (options.animate === 'move') {
            // console.log('move', duration, options, subForm.duration)
            // console.log('******************* animate')
            subForm.animatePositionsTo(options.delay, options.dissolveOutTime, duration, options.dissolveInTime, end, options.fromWhere, false);
          } else if (options.animate === 'dissolveInThenMove') {
            // console.log('move', duration, options, subForm.duration)
            // console.log('******************* animate')
            subForm.animatePositionsTo(options.delay, options.dissolveOutTime, duration, options.dissolveInTime, end, options.fromWhere, true);
          } else if (options.animate === 'moveFrom' && this.eqn.formRestart != null && this.eqn.formRestart.moveFrom != null) {
            var moveFrom = this.eqn.formRestart.moveFrom;
            var target = this.getPosition();
            var start = this.getPosition();

            if (moveFrom instanceof Equation) {
              moveFrom.showForm(subForm.name);
            }

            if (moveFrom instanceof _Element__WEBPACK_IMPORTED_MODULE_2__["DiagramElementCollection"]) {
              start = moveFrom.getPosition();
            } else {
              // $FlowFixMe
              start = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(this.eqn.formRestart.moveFrom);
            }

            this.animations["new"]().dissolveOut({
              duration: options.dissolveOutTime
            }).position({
              target: start,
              duration: 0
            }).trigger({
              callback: function callback() {
                // $FlowFixMe
                _this7.showForm(subForm.name, subFormToUse, false);
              },
              duration: 0.01
            }).position({
              target: target,
              duration: duration
            }).whenFinished(end).start();
          } else if (options.animate === 'pulse' && this.eqn.formRestart != null && this.eqn.formRestart.pulse != null) {
            var pulse = this.eqn.formRestart.pulse;

            var newEnd = function newEnd() {
              _this7.pulseScaleNow(pulse.duration, pulse.scale, 0, end);

              if (pulse.element != null && pulse.element instanceof Equation // $FlowFixMe
              && pulse.element.getCurrentForm().name === subForm.name) {
                pulse.element.pulseScaleNow(pulse.duration, pulse.scale);
              }
            };

            subForm.allHideShow(options.delay, options.dissolveOutTime, options.blankTime, options.dissolveInTime, newEnd);
          } else {
            // console.log('******************* hideshow')
            subForm.allHideShow(options.delay, options.dissolveOutTime, options.blankTime, options.dissolveInTime, end);
          }

          this.setCurrentForm(subForm);
        } // this.updateDescription();

      }
    }
  }, {
    key: "getFormIndex",
    value: function getFormIndex(formToGet) {
      var form = this.getForm(formToGet);
      var index = -1;

      if (form != null) {
        index = this.eqn.currentFormSeries.indexOf(form.name);
      }

      return index;
    }
    /**
     * Animate to previous form in the current form series
     */

  }, {
    key: "prevForm",
    value: function prevForm() {
      var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var currentForm = this.getCurrentForm();

      if (currentForm == null) {
        return;
      }

      var index = this.getFormIndex(currentForm);

      if (index > -1) {
        index -= 1;

        if (index < 0) {
          index = this.eqn.currentFormSeries.length - 1;
        }

        this.goToForm({
          index: index,
          duration: duration,
          delay: delay,
          fromWhere: 'fromNext'
        });
      }
    }
    /**
     * Animate to next form in the current form series
     */

  }, {
    key: "nextForm",
    value: function nextForm() {
      var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var animate = 'move';
      var currentForm = this.getCurrentForm();

      if (currentForm == null) {
        return;
      }

      var index = this.getFormIndex(currentForm);

      if (index > -1) {
        index += 1;

        if (index > this.eqn.currentFormSeries.length - 1) {
          index = 0;
          var formRestart = this.eqn.formRestart;

          if (formRestart != null && formRestart.moveFrom != null) {
            animate = 'moveFrom';
          } else if (formRestart != null && formRestart.pulse != null) {
            animate = 'pulse';
          } else {
            animate = 'dissolve';
          }
        }

        this.goToForm({
          index: index,
          duration: duration,
          delay: delay,
          fromWhere: 'fromPrev',
          animate: animate
        });
      }
    }
    /**
     * Start from previous form and animate to current form
     */

  }, {
    key: "replayCurrentForm",
    value: function replayCurrentForm(duration) {
      if (this.eqn.isAnimating) {
        // this.stop(true, true);
        this.stop(true, true); // this.animations.cancel('complete');
        // this.animations.cancel('complete');

        this.eqn.isAnimating = false;
        var currentForm = this.getCurrentForm();

        if (currentForm != null) {
          this.showForm(currentForm);
        }

        return;
      } // this.animations.cancel();
      // this.animations.cancel();
      // this.stop();


      this.stop();
      this.eqn.isAnimating = false;
      this.prevForm(0);
      this.nextForm(duration, 0.5);
    }
  }, {
    key: "animateToForm",
    value: function animateToForm(name) {
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      // this.stopAnimatingColor(true, true);
      // this.stopAnimatingColor(true, true);
      // this.stop();
      this.stop(); // this.animations.cancel();
      // this.animations.cancel();

      var form = this.getForm(name);

      if (form != null) {
        form.animatePositionsTo(delay, 0.4, duration, 0.4, callback);
      }

      this.setCurrentForm(name);
    }
  }, {
    key: "changeDescription",
    value: function changeDescription(formOrName) {
      var description = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var modifiers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var subForm = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'base';
      var form = this.getForm(formOrName, subForm);

      if (form != null) {
        form.description = "".concat(description);
        form.modifiers = modifiers;
      }
    }
  }, {
    key: "getDescription",
    value: function getDescription(formOrName) {
      var subForm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'base';
      var form = this.getForm(formOrName, subForm);

      if (form != null && form.description != null) {
        return _tools_htmlGenerator__WEBPACK_IMPORTED_MODULE_7__["applyModifiers"](form.description, form.modifiers);
      }

      return '';
    } // updateDescription(
    //   formOrName: EquationForm | string | null = null,
    //   subForm: string = 'base',
    // ) {
    //   const element = this.eqn.descriptionElement;
    //   if (element == null) {
    //     return;
    //   }
    //   if (element.isShown === false) {
    //     return;
    //   }
    //   let form = null;
    //   if (formOrName == null) {
    //     form = this.getCurrentForm();
    //   } else if (typeof formOrName === 'string') {
    //     form = this.getForm(formOrName, subForm);
    //   } else {
    //     form = formOrName;
    //   }
    //   if (form == null) {
    //     return;
    //   }
    //   if (form.description == null) {
    //     return;
    //   }
    //   const { drawingObject } = element;
    //   if (drawingObject instanceof HTMLObject) {
    //     drawingObject.change(
    //       html.applyModifiers(form.description, form.modifiers),
    //       element.lastDrawTransform.m(),
    //     );
    //     html.setOnClicks(form.modifiers);
    //   }
    // }

  }]);

  return Equation;
}(_Element__WEBPACK_IMPORTED_MODULE_2__["DiagramElementCollection"]);

/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/EquationForm.js":
/*!*****************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/EquationForm.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EquationForm; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _Elements_Element__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Elements/Element */ "./src/js/diagram/DiagramElements/Equation/Elements/Element.js");
/* harmony import */ var _EquationFunctions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./EquationFunctions */ "./src/js/diagram/DiagramElements/Equation/EquationFunctions.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

 // import { roundNum } from '../../../tools/math';



 // eslint-disable-next-line import/no-cycle



var EquationForm =
/*#__PURE__*/
function (_Elements) {
  _inherits(EquationForm, _Elements);

  // These properties are just saved in the form and not used by this class
  // They are used by external classes using this form
  function EquationForm(elements, collectionMethods) {
    var _this;

    _classCallCheck(this, EquationForm);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(EquationForm).call(this, []));
    _this.elements = elements;
    _this.collectionMethods = collectionMethods;
    _this.description = null;
    _this.modifiers = {};
    _this.elementMods = {}; // this.duration = null;

    _this.translation = {};
    _this.subForm = '';
    return _this;
  }

  _createClass(EquationForm, [{
    key: "getNamedElements",
    value: function getNamedElements() {
      var namedElements = {};
      this.collectionMethods.getAllElements().forEach(function (element) {
        namedElements[element.name] = element;
      });
      return namedElements;
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.elements;
      var collectionMethods = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.collectionMethods;
      var equationCopy = new EquationForm(elements, collectionMethods);
      var namedElements = {};
      collectionMethods.getAllElements().forEach(function (element) {
        namedElements[element.name] = element;
      });
      var newContent = [];
      this.content.forEach(function (contentElement) {
        newContent.push(contentElement._dup(namedElements));
      });
      equationCopy.content = newContent;
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["duplicateFromTo"])(this, equationCopy, ['content', 'collectionMethods', 'form', 'elements']);
      return equationCopy;
    }
  }, {
    key: "createEq",
    value: function createEq(content) {
      var _this2 = this;

      var elements = [];
      content.forEach(function (c) {
        if (typeof c === 'string') {
          if (c.startsWith('space')) {
            var spaceNum = parseFloat(c.replace(/space[_]*/, '')) || 0.03;
            elements.push(new _Elements_Element__WEBPACK_IMPORTED_MODULE_3__["Element"](new _Elements_Element__WEBPACK_IMPORTED_MODULE_3__["BlankElement"](spaceNum)));
          } else if (c.startsWith(' ')) {
            var _spaceNum = c.length * 0.03;

            elements.push(new _Elements_Element__WEBPACK_IMPORTED_MODULE_3__["Element"](new _Elements_Element__WEBPACK_IMPORTED_MODULE_3__["BlankElement"](_spaceNum)));
          } else {
            var diagramElement = Object(_EquationFunctions__WEBPACK_IMPORTED_MODULE_4__["getDiagramElement"])(_this2.elements, c);

            if (diagramElement) {
              elements.push(new _Elements_Element__WEBPACK_IMPORTED_MODULE_3__["Element"](diagramElement));
            }
          }
        } else {
          elements.push(c._dup());
        }

        _this2.content = elements;
      }); // this.content = content;
    } // An Equation collection is a flat collection of DiagramElements.
    //
    // The form determines how elements are positioned relative to each other.
    //
    // A form of an equation takes the form's elements (a subset of the
    // collection) and applies a translation and scale transformation. This
    // aligns all the elements of a form relative to each other to render
    // the desired form.
    //
    // Arranging a form of an equation goes through each element in the form
    // and positions and scales it in the equation's vertex space.
    // It also saves the locaiton and scale information in the form's element
    // property.
    //
    // The elements are positioned relative to 0,0 in vertex space based on the
    // fixTo, xAlign and yAlign parameters.
    //
    // fixTo can only be a point in the equation's vertex space, or a
    // DiagramElement in the equation.
    //
    // If fixTo is an element in the equation:
    //    - the fixTo element is positioned at 0, 0, and all other elements
    //      repositioned relative to that.
    //    - The equation collection setPosition (or translation transform) can
    //      then be used to position the equation in the diagram (or relative
    //      collection space)
    //    - if xAlign is:
    //        - 'center': the fixTo element is centered in x around (0, 0)
    //        - 'right': the fixTo element right most point is at x = 0
    //        - 'left': default - the fixTo element x position at 0
    //    - if yAlign is:
    //        - 'middle': the fixTo element is centered in y around (0, 0)
    //        - 'bottom': the fixTo element bottom most point is at y = 0
    //        - 'top': the fixTo element top most point is at y = 0
    //        - 'baseline': default - the fixTo element y position at 0
    //
    // If fixTo is a Point, the equation is positioned at that point in the
    // equation's vertex space.
    //  - xAlign:
    //    - 'left': The equation's left most element's left most point is at
    //              Point.x
    //    - 'right': The equation's right most element's right most point is at
    //              Point.x
    //    - 'center': The equation is centered horizontally around Point.x
    //  - yAlign:
    //    - 'baseline': The equation's baseline is at Point.y
    //    - 'top': The equation's top most element's top most point is at Point.y
    //    - 'bottom': The equation's top most element's top most point is at
    //                Point.y
    //    - 'middle': The equation is centered vertically around Point.y
    //

  }, {
    key: "arrange",
    value: function arrange() {
      var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var xAlign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'left';
      var yAlign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'baseline';
      var fixTo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      var elementsInCollection = this.collectionMethods.getAllElements();
      var elementsCurrentlyShowing = elementsInCollection.filter(function (e) {
        return e.isShown;
      });
      this.collectionMethods.hideAll();
      this.collectionMethods.show();

      _get(_getPrototypeOf(EquationForm.prototype), "calcSize", this).call(this, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), scale);

      var fixPoint = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);

      if (fixTo instanceof _Element__WEBPACK_IMPORTED_MODULE_2__["DiagramElementPrimitive"] || fixTo instanceof _Element__WEBPACK_IMPORTED_MODULE_2__["DiagramElementCollection"]) {
        var t = fixTo.transform.t();

        if (t != null) {
          fixPoint = t._dup();
        }
      } else {
        fixPoint = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-fixTo.x, -fixTo.y);
      }

      var w = this.width;
      var h = this.height;
      var a = this.ascent;
      var d = this.descent;

      var p = this.location._dup();

      if (fixTo instanceof _Element__WEBPACK_IMPORTED_MODULE_2__["DiagramElementPrimitive"] || fixTo instanceof _Element__WEBPACK_IMPORTED_MODULE_2__["DiagramElementCollection"]) {
        var _t = fixTo.transform.t();

        var s = fixTo.transform.s();

        if (_t != null && s != null) {
          var rect = fixTo.getBoundingRect('vertex');
          w = rect.width * s.x;
          h = rect.height * s.y;
          a = rect.top * s.y - _t.y;
          d = _t.y - rect.bottom * s.y;
          p = _t._dup();
        }
      }

      if (xAlign === 'right') {
        fixPoint.x += w;
      } else if (xAlign === 'center') {
        fixPoint.x += w / 2;
      } else if (typeof xAlign === 'number') {
        fixPoint.x += xAlign * w;
      } else if (xAlign != null && xAlign.slice(-1)[0] === 'o') {
        var offset = parseFloat(xAlign);
        fixPoint.x += offset;
      }

      if (yAlign === 'top') {
        fixPoint.y += p.y + a;
      } else if (yAlign === 'bottom') {
        fixPoint.y += p.y - d;
      } else if (yAlign === 'middle') {
        fixPoint.y += p.y - d + h / 2;
      } else if (typeof yAlign === 'number') {
        fixPoint.y += p.y - d + yAlign * h;
      } else if (yAlign != null && yAlign.slice(-1)[0] === 'o') {
        var _offset = parseFloat(yAlign);

        fixPoint.y += p.y + _offset;
      }

      var delta = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0).sub(fixPoint);

      if (delta.x !== 0 || delta.y !== 0) {
        this.offsetLocation(delta);
        this.setPositions();
      }

      this.collectionMethods.showOnly(elementsCurrentlyShowing);
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "dissolveElements",
    value: function dissolveElements(elements) {
      var dissolve = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'in';
      var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.01;
      var time = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      var callback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;

      if (elements.length === 0) {
        if (callback) {
          callback(false);
          return;
        }
      }

      var count = elements.length;
      var completed = 0;

      var onFinish = function onFinish(cancelled) {
        completed += 1;

        if (completed === count) {
          if (callback) {
            callback(cancelled);
          }
        }
      };

      elements.forEach(function (e) {
        e.animations.addTo('Equation Color').opacity({
          dissolve: dissolve,
          onFinish: onFinish,
          duration: time,
          delay: delay,
          completeOnCancel: true
        }).start();
      });
    }
  }, {
    key: "getElementsToShowAndHide",
    value: function getElementsToShowAndHide() {
      var allElements = this.collectionMethods.getAllElements();
      var elementsShown = allElements.filter(function (e) {
        return e.isShown;
      });
      var elementsShownTarget = this.getAllElements();
      var elementsToHide = elementsShown.filter(function (e) {
        return elementsShownTarget.indexOf(e) === -1;
      });
      var elementsToShow = elementsShownTarget.filter(function (e) {
        return elementsShown.indexOf(e) === -1;
      });
      return {
        show: elementsToShow,
        hide: elementsToHide
      };
    }
  }, {
    key: "render",
    value: function render() {
      this.hideShow();
      this.setPositions();
    }
  }, {
    key: "showHide",
    value: function showHide() {
      var showTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var hideTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var animationStop = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

      if (animationStop) {
        this.collectionMethods.stop();
      }

      this.collectionMethods.show();

      var _this$getElementsToSh = this.getElementsToShowAndHide(),
          show = _this$getElementsToSh.show,
          hide = _this$getElementsToSh.hide;

      if (showTime === 0) {
        show.forEach(function (e) {
          e.showAll();
        });
      } else {
        this.dissolveElements(show, 'in', 0.01, showTime, null);
      }

      if (hideTime === 0) {
        hide.forEach(function (e) {
          return e.hide();
        });
      } else {
        this.dissolveElements(hide, 'out', showTime, hideTime, callback);
      }
    }
  }, {
    key: "hideShow",
    value: function hideShow() {
      var showTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var hideTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var animationStop = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

      if (animationStop) {
        this.collectionMethods.stop();
      }

      this.collectionMethods.show();

      var _this$getElementsToSh2 = this.getElementsToShowAndHide(),
          show = _this$getElementsToSh2.show,
          hide = _this$getElementsToSh2.hide;

      if (hideTime === 0) {
        hide.forEach(function (e) {
          return e.hide();
        });
      } else {
        this.dissolveElements(hide, 'out', 0.01, hideTime, null);
      }

      if (showTime === 0) {
        show.forEach(function (e) {
          e.showAll();
        });

        if (callback != null) {
          callback();
        }
      } else {
        this.dissolveElements(show, 'in', hideTime, showTime, callback);
      }
    }
  }, {
    key: "allHideShow",
    value: function allHideShow() {
      var _this3 = this;

      var delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var hideTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;
      var blankTime = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.5;
      var showTime = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.5;
      var callback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      this.collectionMethods.stop();
      var allElements = this.collectionMethods.getAllElements();
      var elementsShown = allElements.filter(function (e) {
        return e.isShown;
      });
      var elementsToShow = this.getAllElements();
      var elementsToDelayShowing = elementsToShow.filter(function (e) {
        return !e.isShown;
      });
      var elementsToShowAfterDissolve = elementsToShow.filter(function (e) {
        return e.isShown;
      });
      var cumTime = delay;

      if (elementsToShow.length === 0 && elementsShown.length === 0) {
        if (callback != null) {
          callback(false);
          return;
        }
      }

      var dissolveOutCallback = function dissolveOutCallback() {
        _this3.setPositions();
      };

      if (elementsToShow.length === 0) {
        dissolveOutCallback = function dissolveOutCallback(cancelled) {
          _this3.setPositions();

          if (callback != null) {
            callback(cancelled);
          }
        };
      }

      if (elementsShown.length > 0) {
        this.dissolveElements(elementsShown, 'out', delay, hideTime, dissolveOutCallback);
        cumTime += hideTime;
      } else {
        this.setPositions();
      }

      this.applyElementMods();
      var count = elementsToShow.length;
      var completed = 0;

      var onFinish = function onFinish(cancelled) {
        completed += 1;

        if (completed === count - 1) {
          if (callback) {
            callback(cancelled);
          }
        }
      };

      elementsToDelayShowing.forEach(function (e) {
        e.animations.addTo('Equation Color').dissolveIn({
          duration: showTime,
          onFinish: onFinish,
          delay: cumTime + blankTime
        }).start();
      });
      elementsToShowAfterDissolve.forEach(function (e) {
        e.animations.addTo('Equation Color').dissolveIn({
          duration: showTime,
          onFinish: onFinish,
          delay: blankTime
        }).start();
      });
    }
  }, {
    key: "applyElementMods",
    value: function applyElementMods() {
      var _this4 = this;

      Object.keys(this.elementMods).forEach(function (elementName) {
        var _this4$elementMods$el = _this4.elementMods[elementName],
            element = _this4$elementMods$el.element,
            mods = _this4$elementMods$el.mods;

        if (element != null && mods != null) {
          element.setProperties(mods);

          if (mods.color != null) {
            element.setColor(mods.color);
          }

          if (mods.opacity != null) {
            element.setOpacity(mods.opacity);
          }
        }
      });
    } // Check callback is being called

  }, {
    key: "animatePositionsTo",
    value: function animatePositionsTo(delay, dissolveOutTime, moveTime, dissolveInTime) {
      var callback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      var fromWhere = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
      var dissolveInBeforeMove = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
      var allElements = this.collectionMethods.getAllElements();
      this.collectionMethods.stop();
      var elementsShownTarget = this.getAllElements();
      elementsShownTarget.forEach(function (e) {
        if (e.opacity === 0.001) {
          e.hide();
          e.setOpacity(1);
        } else {
          e.setOpacity(1);
        }
      });
      var elementsShown = allElements.filter(function (e) {
        return e.isShown;
      });
      var elementsToHide = elementsShown.filter(function (e) {
        return elementsShownTarget.indexOf(e) === -1;
      });
      var elementsToShow = elementsShownTarget.filter(function (e) {
        return elementsShown.indexOf(e) === -1;
      });
      var currentTransforms = this.collectionMethods.getElementTransforms();
      this.setPositions();
      var animateToTransforms = this.collectionMethods.getElementTransforms();
      var elementsToMove = [];
      var toMoveStartTransforms = [];
      var toMoveStopTransforms = [];
      Object.keys(animateToTransforms).forEach(function (key) {
        var currentT = currentTransforms[key];
        var nextT = animateToTransforms[key];

        if (!currentT.isEqualTo(nextT)) {
          elementsToMove.push(key);
          toMoveStartTransforms.push(currentT);
          toMoveStopTransforms.push(nextT);
        }
      });
      var toShowTransforms = {};
      elementsToShow.forEach(function (element) {
        toShowTransforms[element.name] = element.transform._dup();
      }); // Find move time to use. If moveTime is null, then a velocity is used.

      var moveTimeToUse;

      if (moveTime === null) {
        moveTimeToUse = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getMoveTime"])(toMoveStartTransforms, toMoveStopTransforms, 0, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0.35, 0.35), // 0.25 diagram space per s
        2 * Math.PI / 6, // 60 per second
        new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0.4, 0.4) // 100% per second
        );
      } else {
        moveTimeToUse = moveTime;
      }

      this.collectionMethods.setElementTransforms(currentTransforms);
      this.collectionMethods.setElementTransforms(toShowTransforms);
      var cumTime = delay;
      var moveCallback = null;
      var dissolveInCallback = null;
      var dissolveOutCallback = null;

      if (dissolveInBeforeMove) {
        if (elementsToMove.length === 0 && elementsToShow.length === 0) {
          dissolveOutCallback = callback;
        } else if (elementsToMove.length === 0) {
          dissolveInCallback = callback;
        } else {
          moveCallback = callback;
        }
      } else if (elementsToMove.length === 0 && elementsToShow.length === 0) {
        dissolveOutCallback = callback;
      } else if (elementsToShow.length === 0) {
        moveCallback = callback;
      } else {
        dissolveInCallback = callback;
      }

      if (elementsToHide.length > 0) {
        this.dissolveElements(elementsToHide, 'out', delay, dissolveOutTime, dissolveOutCallback);
        cumTime += dissolveOutTime;
      } else if (dissolveOutCallback != null) {
        dissolveOutCallback();
      }

      this.applyElementMods();
      var translationToUse = {};

      if (fromWhere === 'fromPrev' && this.fromPrev != null) {
        translationToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, this.translation, this.fromPrev);
      } else if (fromWhere === 'fromNext' && this.fromNext != null) {
        translationToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, this.translation, this.fromNext);
      } else {
        translationToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, this.translation);
      }

      Object.keys(translationToUse).forEach(function (key) {
        var mods = translationToUse[key];
        var element = mods.element,
            style = mods.style,
            direction = mods.direction,
            mag = mods.mag;

        if (element) {
          if (style != null) {
            element.animations.options.translation.style = style;
          }

          if (direction != null) {
            element.animations.options.translation.direction = direction;
          }

          if (mag != null) {
            element.animations.options.translation.magnitude = mag;
          }
        }
      });

      if (dissolveInBeforeMove) {
        if (elementsToShow.length > 0) {
          this.dissolveElements(elementsToShow, 'in', cumTime, dissolveInTime, dissolveInCallback);
          cumTime += dissolveInTime + 0.001;
        }
      }

      var t = this.collectionMethods.animateToTransforms(animateToTransforms, moveTimeToUse, cumTime, 0, moveCallback);

      if (t > 0) {
        cumTime = t;
      } // if (elementsToShow.length > 0) {
      //   this.dissolveElements(elementsToShow, 'in', cumTime, dissolveInTime, dissolveInCallback);
      //   cumTime += dissolveInTime + 0.001;
      // }


      if (!dissolveInBeforeMove) {
        if (elementsToShow.length > 0) {
          this.dissolveElements(elementsToShow, 'in', cumTime, dissolveInTime, dissolveInCallback);
          cumTime += dissolveInTime + 0.001;
        }
      }

      return cumTime;
    }
  }]);

  return EquationForm;
}(_Elements_Element__WEBPACK_IMPORTED_MODULE_3__["Elements"]);



/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/EquationFunctions.js":
/*!**********************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/EquationFunctions.js ***!
  \**********************************************************************/
/*! exports provided: getDiagramElement, EquationFunctions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDiagramElement", function() { return getDiagramElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EquationFunctions", function() { return EquationFunctions; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _Elements_Element__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Elements/Element */ "./src/js/diagram/DiagramElements/Equation/Elements/Element.js");
/* harmony import */ var _Elements_Fraction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Elements/Fraction */ "./src/js/diagram/DiagramElements/Equation/Elements/Fraction.js");
/* harmony import */ var _EquationForm__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./EquationForm */ "./src/js/diagram/DiagramElements/Equation/EquationForm.js");
/* harmony import */ var _Elements_Matrix__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Elements/Matrix */ "./src/js/diagram/DiagramElements/Equation/Elements/Matrix.js");
/* harmony import */ var _Elements_Scale__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Elements/Scale */ "./src/js/diagram/DiagramElements/Equation/Elements/Scale.js");
/* harmony import */ var _Elements_Container__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Elements/Container */ "./src/js/diagram/DiagramElements/Equation/Elements/Container.js");
/* harmony import */ var _Elements_BaseAnnotationFunction__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Elements/BaseAnnotationFunction */ "./src/js/diagram/DiagramElements/Equation/Elements/BaseAnnotationFunction.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }





 // eslint-disable-next-line import/no-cycle





 // eslint-disable-next-line import/no-cycle
// import type {
//   EQN_Annotation, EQN_EncompassGlyph, EQN_LeftRightGlyph, EQN_TopBottomGlyph,
// } from './Elements/BaseAnnotationFunction';

function getDiagramElement(elementsObject, name) {
  if (typeof name !== 'string') {
    return name;
  }

  if (elementsObject instanceof _Element__WEBPACK_IMPORTED_MODULE_2__["DiagramElementCollection"]) {
    if (elementsObject && "_".concat(name) in elementsObject) {
      // $FlowFixMe
      return elementsObject["_".concat(name)];
    }

    return null;
  }

  if (elementsObject && name in elementsObject) {
    return elementsObject[name];
  }

  return null;
}
/* eslint-disable no-use-before-define */

/**
 * An equation phrase is used to define an equation form. An equation phrase
 * can either be the entirety of the form definition, or a series of nested
 * phrases.
 *
 *  * An object or array definition (e.g. {@link EQN_Fraction})
 *  * A string that represents an equation element
 *  * An array of {@link TypeEquationPhrase}
 *
 * @example:
 * forms: {
 *   form1: 'a'
 *   form2: ['a', 'equals', 'b']
 *   form3: [{
 *     frac: {
 *       numerator: 'a',
 *       symbol: 'v',
 *       denominator: '1'
 *     },
 *   }, 'equals', 'b'],
 *   form4: [{ frac: ['a', 'v', '1'], 'equals', 'b'}],
 * },
 */

// There are lots of FlowFixMes in this file. This is not perfect, but
// haven't been able to come up with a quick work around. The problem statement
// is each function can accept as arguements either a full object definition
// or the definition split over parameters.
// The problem is then the first arguement can be so many types, some of which
// are subsets of the other, then when its parameters are extracted, their type
// is all confused.
var EquationFunctions =
/*#__PURE__*/
function () {
  // eslint-disable-next-line no-use-before-define
  // [methodName: string]: (TypeEquationPhrase) => {};
  // eslint-disable-next-line no-use-before-define
  function EquationFunctions(elements, addElementFromKey, getExistingOrAddSymbol) {
    _classCallCheck(this, EquationFunctions);

    this.elements = elements;
    this.phrases = {};
    this.fullLineHeight = null;
    this.addElementFromKey = addElementFromKey;
    this.getExistingOrAddSymbol = getExistingOrAddSymbol;
  } // eslint-disable-next-line class-methods-use-this


  _createClass(EquationFunctions, [{
    key: "stringToElement",
    value: function stringToElement(content) {
      if (content.startsWith('space')) {
        var spaceNum = parseFloat(content.replace(/space[_]*/, '')) || 0.03;
        return new _Elements_Element__WEBPACK_IMPORTED_MODULE_3__["Element"](new _Elements_Element__WEBPACK_IMPORTED_MODULE_3__["BlankElement"](spaceNum));
      }

      if (content.startsWith(' ')) {
        var _spaceNum = content.length * 0.03;

        return new _Elements_Element__WEBPACK_IMPORTED_MODULE_3__["Element"](new _Elements_Element__WEBPACK_IMPORTED_MODULE_3__["BlankElement"](_spaceNum));
      }

      var diagramElement = getDiagramElement(this.elements, content);

      if (diagramElement) {
        return new _Elements_Element__WEBPACK_IMPORTED_MODULE_3__["Element"](diagramElement);
      }

      if (content in this.phrases) {
        return this.parseContent(this.phrases[content]);
      }

      var elementFromKey = this.addElementFromKey(content, {});

      if (elementFromKey != null) {
        return new _Elements_Element__WEBPACK_IMPORTED_MODULE_3__["Element"](elementFromKey);
      }

      return null;
    }
  }, {
    key: "parseContent",
    value: function parseContent(content) {
      var _this = this;

      if (content == null) {
        return null;
      }

      if (typeof content === 'number') {
        return null;
      }

      if (content instanceof _Elements_Element__WEBPACK_IMPORTED_MODULE_3__["Elements"]) {
        return content;
      }

      if (content instanceof _Elements_BaseAnnotationFunction__WEBPACK_IMPORTED_MODULE_9__["default"]) {
        return content;
      }

      if (typeof content === 'string') {
        return this.stringToElement(content);
      }

      if (Array.isArray(content)) {
        var elementArray = [];
        content.forEach(function (c) {
          // $FlowFixMe
          var result = _this.parseContent(c);

          if (Array.isArray(result)) {
            elementArray = [].concat(_toConsumableArray(elementArray), _toConsumableArray(result));
          } else {
            elementArray.push(result);
          }
        });
        return elementArray;
      } // Otherwise its an object


      var _Object$entries$ = _slicedToArray(Object.entries(content)[0], 2),
          method = _Object$entries$[0],
          params = _Object$entries$[1]; // if (this[method] != null) {
      // return this[method](params);
      // }
      // $FlowFixMe


      var eqnMethod = this.eqnMethod(method, params);

      if (eqnMethod != null) {
        return eqnMethod;
      } // If it is not a known function, then it must be a new text or
      // symbol element           // $FlowFixMe


      var elem = this.addElementFromKey(method, params); // $FlowFixMe

      return new _Elements_Element__WEBPACK_IMPORTED_MODULE_3__["Element"](elem);
    }
  }, {
    key: "contentToElement",
    value: function contentToElement(content) {
      // If input is alread an Elements object, then return it
      if (content instanceof _Elements_Element__WEBPACK_IMPORTED_MODULE_3__["Elements"]) {
        return content._dup();
      }

      if (content instanceof _Element__WEBPACK_IMPORTED_MODULE_2__["DiagramElementCollection"] || content instanceof _Element__WEBPACK_IMPORTED_MODULE_2__["DiagramElementPrimitive"]) {
        return new _Elements_Element__WEBPACK_IMPORTED_MODULE_3__["Elements"]([new _Elements_Element__WEBPACK_IMPORTED_MODULE_3__["Element"](content)]);
      }

      var elementArray = this.parseContent(content);

      if (!Array.isArray(elementArray)) {
        elementArray = [elementArray];
      }

      return new _Elements_Element__WEBPACK_IMPORTED_MODULE_3__["Elements"](elementArray);
    }
  }, {
    key: "eqnMethod",
    value: function eqnMethod(name, params) {
      // $FlowFixMe
      if (name === 'frac') {
        return this.frac(params);
      } // $FlowFixMe


      if (name === 'strike') {
        return this.strike(params);
      } // $FlowFixMe


      if (name === 'box') {
        return this.box(params);
      } // $FlowFixMe


      if (name === 'root') {
        return this.root(params);
      } // $FlowFixMe


      if (name === 'brac') {
        return this.brac(params);
      } // $FlowFixMe


      if (name === 'sub') {
        return this.sub(params);
      } // $FlowFixMe


      if (name === 'sup') {
        return this.sup(params);
      } // $FlowFixMe


      if (name === 'supSub') {
        return this.supSub(params);
      } // $FlowFixMe


      if (name === 'topBar') {
        return this.topBar(params);
      } // $FlowFixMe


      if (name === 'bottomBar') {
        return this.bottomBar(params);
      } // $FlowFixMe


      if (name === 'annotate') {
        return this.annotate(params);
      } // $FlowFixMe


      if (name === 'bottomComment') {
        return this.bottomComment(params);
      } // $FlowFixMe


      if (name === 'topComment') {
        return this.topComment(params);
      } // $FlowFixMe


      if (name === 'bar') {
        return this.bar(params);
      } // $FlowFixMe


      if (name === 'topStrike') {
        return this.topStrike(params);
      } // $FlowFixMe


      if (name === 'bottomStrike') {
        return this.bottomStrike(params);
      } // $FlowFixMe


      if (name === 'pad') {
        return this.pad(params);
      } // $FlowFixMe


      if (name === 'int') {
        return this["int"](params);
      } // $FlowFixMe


      if (name === 'sumOf') {
        return this.sumProd(params);
      } // $FlowFixMe


      if (name === 'prodOf') {
        return this.sumProd(params);
      } // $FlowFixMe


      if (name === 'matrix') {
        return this.matrix(params);
      } // $FlowFixMe


      if (name === 'scale') {
        return this.scale(params);
      } // $FlowFixMe


      if (name === 'container') {
        return this.container(params);
      }

      return null;
    }
    /**
     * Equation container function
     * @example
     * e = new Equation();
     * e.addElements({
     *   v: { symbol: 'vinculum' },
     * });
     * frac = e.eqn.functions.frac;
     * eqn.addForms({
     *   base: ['a', 'equals', frac(['b', 'v', 'c'])],
     * });
     */

  }, {
    key: "container",
    value: function container(optionsOrArray) {
      var content;
      var scale;
      var fit; // fits content to container - width, height, contain, null

      var width;
      var ascent;
      var descent;
      var xAlign; // left, center, right, multiplier (to left)

      var yAlign; // bottom, baseline, middle, top, multiplier (to bottom)

      var fullContentBounds;
      var defaultOptions = {
        scaleModifier: 1,
        fit: null,
        width: null,
        ascent: null,
        descent: null,
        xAlign: 'center',
        yAlign: 'baseline',
        fullContentBounds: false
      };

      if (Array.isArray(optionsOrArray)) {
        var _optionsOrArray = _slicedToArray(optionsOrArray, 9);

        content = _optionsOrArray[0];
        width = _optionsOrArray[1];
        descent = _optionsOrArray[2];
        ascent = _optionsOrArray[3];
        xAlign = _optionsOrArray[4];
        yAlign = _optionsOrArray[5];
        fit = _optionsOrArray[6];
        scale = _optionsOrArray[7];
        fullContentBounds = _optionsOrArray[8];
      } else {
        content = optionsOrArray.content;
        width = optionsOrArray.width;
        descent = optionsOrArray.descent;
        ascent = optionsOrArray.ascent;
        xAlign = optionsOrArray.xAlign;
        yAlign = optionsOrArray.yAlign;
        fit = optionsOrArray.fit;
        scale = optionsOrArray.scale;
        fullContentBounds = optionsOrArray.fullContentBounds;
      }

      var optionsIn = {
        scaleModifier: scale,
        fit: fit,
        width: width,
        ascent: ascent,
        descent: descent,
        xAlign: xAlign,
        yAlign: yAlign,
        fullContentBounds: fullContentBounds
      };
      var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, optionsIn);
      return new _Elements_Container__WEBPACK_IMPORTED_MODULE_8__["default"]([this.contentToElement(content)], [], options);
    }
  }, {
    key: "brac",
    value: function brac(optionsOrArray) {
      var content;
      var left;
      var right;
      var insideSpace;
      var outsideSpace;
      var topSpace;
      var bottomSpace;
      var minContentHeight;
      var minContentDescent;
      var descent;
      var height;
      var inSize;
      var useFullBounds;
      var fullContentBounds;

      if (Array.isArray(optionsOrArray)) {
        var _optionsOrArray2 = _slicedToArray(optionsOrArray, 14);

        left = _optionsOrArray2[0];
        content = _optionsOrArray2[1];
        right = _optionsOrArray2[2];
        inSize = _optionsOrArray2[3];
        insideSpace = _optionsOrArray2[4];
        outsideSpace = _optionsOrArray2[5];
        // $FlowFixMe
        topSpace = _optionsOrArray2[6];
        bottomSpace = _optionsOrArray2[7];
        minContentHeight = _optionsOrArray2[8];
        // $FlowFixMe
        minContentDescent = _optionsOrArray2[9];
        height = _optionsOrArray2[10];
        descent = _optionsOrArray2[11];
        fullContentBounds = _optionsOrArray2[12];
        // $FlowFixMe
        useFullBounds = _optionsOrArray2[13];
      } else {
        left = optionsOrArray.left;
        content = optionsOrArray.content;
        right = optionsOrArray.right;
        inSize = optionsOrArray.inSize;
        insideSpace = optionsOrArray.insideSpace;
        outsideSpace = optionsOrArray.outsideSpace;
        topSpace = optionsOrArray.topSpace;
        bottomSpace = optionsOrArray.bottomSpace;
        minContentHeight = optionsOrArray.minContentHeight;
        minContentDescent = optionsOrArray.minContentDescent;
        height = optionsOrArray.height;
        descent = optionsOrArray.descent;
        fullContentBounds = optionsOrArray.fullContentBounds;
        useFullBounds = optionsOrArray.useFullBounds;
      }

      var defaultOptions = {
        insideSpace: 0.03,
        outsideSpace: 0.03,
        topSpace: 0.05,
        bottomSpace: 0.05,
        minContentHeight: null,
        minContentDescent: null,
        descent: null,
        height: null,
        inSize: true,
        useFullBounds: false,
        fullContentBounds: false
      };
      var optionsIn = {
        insideSpace: insideSpace,
        outsideSpace: outsideSpace,
        topSpace: topSpace,
        bottomSpace: bottomSpace,
        minContentHeight: minContentHeight,
        minContentDescent: minContentDescent,
        descent: descent,
        height: height,
        inSize: inSize,
        useFullBounds: useFullBounds,
        fullContentBounds: fullContentBounds
      };
      var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, optionsIn);
      var glyphs = {};

      if (left) {
        glyphs.left = {
          symbol: left,
          space: options.insideSpace,
          topSpace: options.topSpace,
          bottomSpace: options.bottomSpace,
          minContentHeight: options.minContentHeight,
          minContentDescent: options.minContentDescent,
          descent: options.descent,
          height: options.height
        };
      }

      if (right) {
        glyphs.right = {
          symbol: right,
          space: options.insideSpace,
          topSpace: options.topSpace,
          bottomSpace: options.bottomSpace,
          minContentHeight: options.minContentHeight,
          minContentDescent: options.minContentDescent,
          descent: options.descent,
          height: options.height
        };
      }

      return this.annotate({
        content: content,
        glyphs: glyphs,
        inSize: options.inSize,
        leftSpace: options.outsideSpace,
        rightSpace: options.outsideSpace,
        useFullBounds: options.useFullBounds,
        fullContentBounds: options.fullContentBounds
      });
    }
  }, {
    key: "bar",
    value: function bar(optionsOrArray) {
      var forceOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var content;
      var symbol;
      var side;
      var space;
      var overhang;
      var length;
      var left;
      var right;
      var top;
      var bottom;
      var inSize;
      var minContentHeight;
      var minContentDescent;
      var minContentAscent;
      var descent;
      var fullContentBounds;
      var useFullBounds;
      var defaultOptions = {
        inSize: true,
        space: 0.03,
        overhang: 0,
        length: null,
        left: null,
        right: null,
        top: null,
        bottom: null,
        side: 'top',
        minContentHeight: null,
        minContentDescent: null,
        minContentAscent: null,
        descent: null,
        fullContentBounds: false,
        useFullBounds: false
      };

      if (Array.isArray(optionsOrArray)) {
        var _optionsOrArray3 = _slicedToArray(optionsOrArray, 17);

        content = _optionsOrArray3[0];
        symbol = _optionsOrArray3[1];
        inSize = _optionsOrArray3[2];
        space = _optionsOrArray3[3];
        overhang = _optionsOrArray3[4];
        length = _optionsOrArray3[5];
        left = _optionsOrArray3[6];
        right = _optionsOrArray3[7];
        top = _optionsOrArray3[8];
        bottom = _optionsOrArray3[9];
        side = _optionsOrArray3[10];
        minContentHeight = _optionsOrArray3[11];
        minContentDescent = _optionsOrArray3[12];
        minContentAscent = _optionsOrArray3[13];
        descent = _optionsOrArray3[14];
        fullContentBounds = _optionsOrArray3[15];
        useFullBounds = _optionsOrArray3[16];
      } else {
        content = optionsOrArray.content;
        symbol = optionsOrArray.symbol;
        inSize = optionsOrArray.inSize;
        space = optionsOrArray.space;
        overhang = optionsOrArray.overhang;
        length = optionsOrArray.length;
        left = optionsOrArray.left;
        right = optionsOrArray.right;
        top = optionsOrArray.top;
        bottom = optionsOrArray.bottom;
        side = optionsOrArray.side;
        minContentHeight = optionsOrArray.minContentHeight;
        minContentDescent = optionsOrArray.minContentDescent;
        minContentAscent = optionsOrArray.minContentAscent;
        descent = optionsOrArray.descent;
        fullContentBounds = optionsOrArray.fullContentBounds;
        useFullBounds = optionsOrArray.useFullBounds;
      }

      var optionsIn = {
        side: side,
        space: space,
        overhang: overhang,
        length: length,
        left: left,
        right: right,
        top: top,
        bottom: bottom,
        inSize: inSize,
        minContentHeight: minContentHeight,
        minContentDescent: minContentDescent,
        minContentAscent: minContentAscent,
        descent: descent,
        fullContentBounds: fullContentBounds,
        useFullBounds: useFullBounds
      };
      var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, optionsIn, forceOptions);
      var glyphs = {};

      if (options.side === 'top') {
        glyphs.top = {
          symbol: symbol,
          space: options.space,
          overhang: options.overhang,
          leftSpace: options.left,
          rightSpace: options.right,
          width: options.length
        };
      }

      if (options.side === 'bottom') {
        glyphs.bottom = {
          symbol: symbol,
          space: options.space,
          overhang: options.overhang,
          leftSpace: options.left,
          rightSpace: options.right,
          width: options.length
        };
      }

      if (options.side === 'left') {
        glyphs.left = {
          symbol: symbol,
          space: options.space,
          overhang: options.overhang,
          topSpace: options.top,
          bottomSpace: options.bottom,
          height: options.length,
          minContentHeight: options.minContentHeight,
          minContentDescent: options.minContentDescent,
          minContentAscent: options.minContentAscent,
          descent: options.descent
        };
      }

      if (options.side === 'right') {
        glyphs.right = {
          symbol: symbol,
          space: options.space,
          overhang: options.overhang,
          topSpace: options.top,
          bottomSpace: options.bottom,
          height: options.length,
          minContentHeight: options.minContentHeight,
          minContentDescent: options.minContentDescent,
          minContentAscent: options.minContentAscent,
          descent: options.descent
        };
      }

      return this.annotate({
        content: content,
        // $FlowFixMe
        glyphs: glyphs,
        inSize: options.inSize,
        fullContentBounds: options.fullContentBounds,
        useFullBounds: options.useFullBounds
      });
    }
  }, {
    key: "annotate",
    value: function annotate(optionsIn) {
      var _this2 = this;

      var defaultOptions = {
        inSize: true,
        useFullBounds: false,
        fullContentBounds: false,
        space: 0,
        contentScale: 1,
        encompass: {
          space: 0
        },
        left: {
          space: 0,
          overhang: 0,
          yOffset: 0,
          annotationsOverContent: false
        },
        right: {
          space: 0,
          overhang: 0,
          yOffset: 0,
          annotationsOverContent: false
        },
        top: {
          space: 0,
          overhang: 0,
          xOffset: 0,
          annotationsOverContent: false
        },
        bottom: {
          space: 0,
          overhang: 0,
          xOffset: 0,
          annotationsOverContent: false
        }
      };
      var content = optionsIn.content,
          annotation = optionsIn.annotation,
          annotations = optionsIn.annotations,
          glyphs = optionsIn.glyphs;
      var defaultAnnotation = {
        xPosition: 'center',
        yPosition: 'top',
        xAlign: 'center',
        yAlign: 'bottom',
        offset: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
        scale: 1,
        inSize: true,
        fullContentBounds: false
      };
      var annotationsToProcess = [];

      if (annotation != null) {
        annotationsToProcess.push(annotation);
      } else if (annotations != null) {
        annotationsToProcess = annotations;
      }

      var fillAnnotation = function fillAnnotation(ann) {
        var annCopy = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultAnnotation, ann); // $FlowFixMe

        annCopy.content = _this2.contentToElement(ann.content);
        return annCopy;
      };

      var fillAnnotations = function fillAnnotations(anns) {
        if (anns == null || !Array.isArray(anns)) {
          return [];
        }

        var annsCopy = [];
        anns.forEach(function (ann) {
          annsCopy.push(fillAnnotation(ann));
        });
        return annsCopy;
      };

      var annotationsToUse = fillAnnotations(annotationsToProcess);
      var glyphsToUse = {};

      var fillGlyphAnnotation = function fillGlyphAnnotation(side) {
        if (glyphs == null) {
          return;
        }

        var glyphSide = glyphs[side];

        if (glyphSide == null) {
          return;
        }

        glyphsToUse[side] = {};
        var glyphAnnotationsToProcess = glyphSide.annotations; // $FlowFixMe

        if (glyphSide.annotation != null) {
          // $FlowFixMe
          glyphAnnotationsToProcess = [glyphSide.annotation];
        }

        var glyphAnnotationsToUse = fillAnnotations(glyphAnnotationsToProcess);
        glyphsToUse[side] = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions[side], glyphSide);
        glyphsToUse[side].annotations = glyphAnnotationsToUse; // $FlowFixMe

        glyphsToUse[side].glyph = _this2.getExistingOrAddSymbol(glyphSide.symbol || '');
      };

      fillGlyphAnnotation('encompass');
      fillGlyphAnnotation('left');
      fillGlyphAnnotation('right');
      fillGlyphAnnotation('top');
      fillGlyphAnnotation('bottom');
      var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, optionsIn);
      return new _Elements_BaseAnnotationFunction__WEBPACK_IMPORTED_MODULE_9__["default"](this.contentToElement(content), annotationsToUse, // $FlowFixMe
      glyphsToUse, options);
    }
  }, {
    key: "scale",
    value: function scale(optionsOrArray) {
      var content;
      var scale;
      var fullContentBounds;
      var defaultOptions = {
        scaleModifier: 1,
        fullContentBounds: false
      };

      if (Array.isArray(optionsOrArray)) {
        var _optionsOrArray4 = _slicedToArray(optionsOrArray, 3);

        content = _optionsOrArray4[0];
        scale = _optionsOrArray4[1];
        fullContentBounds = _optionsOrArray4[2];
      } else {
        content = optionsOrArray.content;
        scale = optionsOrArray.scale;
        fullContentBounds = optionsOrArray.fullContentBounds;
      }

      var optionsIn = {
        scaleModifier: scale,
        fullContentBounds: fullContentBounds
      };
      var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, optionsIn);
      return new _Elements_Scale__WEBPACK_IMPORTED_MODULE_7__["default"]([this.contentToElement(content)], [], options);
    }
    /**
     * Equation fraction function
     * @example
     * e = new Equation();
     * e.addElements({
     *   v: { symbol: 'vinculum' },
     * });
     * frac = e.eqn.functions.frac;
     * eqn.addForms({
     *   base: ['a', 'equals', frac(['b', 'v', 'c'])],
     * });
     */

  }, {
    key: "frac",
    value: function frac(optionsOrArray) {
      var numerator;
      var denominator;
      var symbol;
      var scale;
      var overhang;
      var numeratorSpace;
      var denominatorSpace;
      var offsetY;
      var fullContentBounds; // This is imperfect type checking, as the assumption is if den, sym
      // and fractionScale is null, then they weren't defined by the caller
      // and therefore the caller is passing in a TypeFracObject or TypeFracArray
      // All the flow errors go away if TypeEquationPhrase is removed from
      // optionsOrNum (and then also remove the first if statement below)

      var defaultOptions = {
        scaleModifier: 1,
        numeratorSpace: 0.05,
        denominatorSpace: 0.05,
        offsetY: 0.07,
        overhang: 0.05,
        fullContentBounds: false
      };

      if (Array.isArray(optionsOrArray)) {
        var _optionsOrArray5 = _slicedToArray(optionsOrArray, 9);

        numerator = _optionsOrArray5[0];
        symbol = _optionsOrArray5[1];
        denominator = _optionsOrArray5[2];
        scale = _optionsOrArray5[3];
        numeratorSpace = _optionsOrArray5[4];
        denominatorSpace = _optionsOrArray5[5];
        overhang = _optionsOrArray5[6];
        offsetY = _optionsOrArray5[7];
        fullContentBounds = _optionsOrArray5[8];
      } else {
        numerator = optionsOrArray.numerator;
        symbol = optionsOrArray.symbol;
        denominator = optionsOrArray.denominator;
        scale = optionsOrArray.scale;
        numeratorSpace = optionsOrArray.numeratorSpace;
        denominatorSpace = optionsOrArray.denominatorSpace;
        overhang = optionsOrArray.overhang;
        offsetY = optionsOrArray.offsetY;
        fullContentBounds = optionsOrArray.fullContentBounds;
      }

      var optionsIn = {
        scaleModifier: scale,
        overhang: overhang,
        numeratorSpace: numeratorSpace,
        denominatorSpace: denominatorSpace,
        offsetY: offsetY,
        fullContentBounds: fullContentBounds
      };
      var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, optionsIn);
      return new _Elements_Fraction__WEBPACK_IMPORTED_MODULE_4__["default"]([this.contentToElement(numerator), this.contentToElement(denominator)], // $FlowFixMe
      this.getExistingOrAddSymbol(symbol), options);
    }
  }, {
    key: "root",
    value: function root(optionsOrArray) {
      var content;
      var root;
      var symbol;
      var space;
      var leftSpace;
      var topSpace;
      var bottomSpace;
      var rightSpace;
      var rootScale;
      var rootOffset;
      var inSize = true;
      var fullContentBounds;
      var useFullBounds;

      if (Array.isArray(optionsOrArray)) {
        var _optionsOrArray6 = _slicedToArray(optionsOrArray, 13);

        // $FlowFixMe
        symbol = _optionsOrArray6[0];
        content = _optionsOrArray6[1];
        inSize = _optionsOrArray6[2];
        // $FlowFixMe
        space = _optionsOrArray6[3];
        topSpace = _optionsOrArray6[4];
        rightSpace = _optionsOrArray6[5];
        bottomSpace = _optionsOrArray6[6];
        leftSpace = _optionsOrArray6[7];
        // $FlowFixMe
        root = _optionsOrArray6[8];
        rootOffset = _optionsOrArray6[9];
        rootScale = _optionsOrArray6[10];
        fullContentBounds = _optionsOrArray6[11];
        useFullBounds = _optionsOrArray6[12];
      } else {
        symbol = optionsOrArray.symbol;
        content = optionsOrArray.content;
        inSize = optionsOrArray.inSize;
        space = optionsOrArray.space;
        topSpace = optionsOrArray.topSpace;
        rightSpace = optionsOrArray.rightSpace;
        bottomSpace = optionsOrArray.bottomSpace;
        leftSpace = optionsOrArray.leftSpace;
        root = optionsOrArray.root;
        rootOffset = optionsOrArray.rootOffset;
        rootScale = optionsOrArray.rootScale;
        fullContentBounds = optionsOrArray.fullContentBounds;
        useFullBounds = optionsOrArray.useFullBounds;
      }

      var defaultOptions = {
        space: 0.02,
        rootScale: 0.6,
        rootOffset: [0, 0.06],
        inSize: true,
        fullContentBounds: false,
        useFullBounds: false
      };
      var optionsIn = {
        leftSpace: leftSpace,
        topSpace: topSpace,
        bottomSpace: bottomSpace,
        rightSpace: rightSpace,
        space: space,
        rootScale: rootScale,
        rootOffset: rootOffset,
        inSize: inSize,
        fullContentBounds: fullContentBounds,
        useFullBounds: useFullBounds
      };
      var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, optionsIn);
      options.rootOffset = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(options.rootOffset);
      var annotations = [];

      if (root != null) {
        annotations.push({
          content: root,
          offset: options.rootOffset,
          scale: options.rootScale,
          reference: 'root'
        });
      }

      return this.annotate({
        content: content,
        inSize: options.inSize,
        useFullBounds: options.useFullBounds,
        fullContentBounds: options.fullContentBounds,
        glyphs: {
          encompass: {
            symbol: symbol,
            // $FlowFixMe
            annotations: annotations,
            space: options.space,
            leftSpace: options.leftSpace,
            rightSpace: options.rightSpace,
            topSpace: options.topSpace,
            bottomSpace: options.bottomSpace
          }
        }
      });
    }
  }, {
    key: "supSub",
    value: function supSub(optionsOrArray) {
      var content;
      var superscript = null;
      var subscript = null;
      var scale = null;
      var subscriptOffset = null;
      var superscriptOffset = null;
      var inSize;

      if (Array.isArray(optionsOrArray)) {
        var _optionsOrArray7 = _slicedToArray(optionsOrArray, 7);

        // $FlowFixMe
        content = _optionsOrArray7[0];
        superscript = _optionsOrArray7[1];
        subscript = _optionsOrArray7[2];
        scale = _optionsOrArray7[3];
        // $FlowFixMe
        superscriptOffset = _optionsOrArray7[4];
        subscriptOffset = _optionsOrArray7[5];
        inSize = _optionsOrArray7[6];
      } else {
        content = optionsOrArray.content;
        superscript = optionsOrArray.superscript;
        subscript = optionsOrArray.subscript;
        scale = optionsOrArray.scale;
        superscriptOffset = optionsOrArray.superscriptOffset;
        subscriptOffset = optionsOrArray.subscriptOffset;
        inSize = optionsOrArray.inSize;
      }

      var defaultOptions = {
        scale: 0.5,
        subscriptOffset: [0, 0],
        superscriptOffset: [0, 0],
        inSize: true
      };
      var optionsIn = {
        superscript: superscript,
        subscript: subscript,
        scale: scale,
        subscriptOffset: subscriptOffset,
        superscriptOffset: superscriptOffset,
        inSize: inSize
      };
      var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, optionsIn);
      var annotations = [];

      if (superscript != null) {
        annotations.push({
          content: options.superscript,
          xPosition: 'right',
          yPosition: '0.7a',
          xAlign: 'left',
          yAlign: 'baseline',
          offset: options.superscriptOffset,
          scale: options.scale
        });
      }

      if (subscript != null) {
        annotations.push({
          content: options.subscript,
          xPosition: 'right',
          yPosition: 'baseline',
          xAlign: 'left',
          yAlign: '0.7a',
          offset: options.subscriptOffset,
          scale: options.scale
        });
      }

      return this.annotate({
        content: content,
        // $FlowFixMe
        annotations: annotations,
        inSize: options.inSize
      });
    }
  }, {
    key: "sup",
    value: function sup(optionsOrArray) {
      var content;
      var superscript;
      var scale;
      var offset; // let superscriptOffset = null;

      var inSize;

      if (Array.isArray(optionsOrArray)) {
        var _optionsOrArray8 = _slicedToArray(optionsOrArray, 5);

        // $FlowFixMe
        content = _optionsOrArray8[0];
        superscript = _optionsOrArray8[1];
        scale = _optionsOrArray8[2];
        offset = _optionsOrArray8[3];
        inSize // $FlowFixMe
        = _optionsOrArray8[4];
      } else {
        content = optionsOrArray.content;
        superscript = optionsOrArray.superscript;
        scale = optionsOrArray.scale;
        offset = optionsOrArray.offset;
        inSize = optionsOrArray.inSize;
      } // $FlowFixMe


      return this.supSub({
        // $FlowFixMe
        content: content,
        // $FlowFixMe
        superscript: superscript,
        // $FlowFixMe
        superscriptOffset: offset,
        // $FlowFixMe
        inSize: inSize,
        // $FlowFixMe
        scale: scale
      });
    }
  }, {
    key: "sub",
    value: function sub(optionsOrArray) {
      var content;
      var subscript;
      var scale;
      var offset;
      var inSize;

      if (Array.isArray(optionsOrArray)) {
        var _optionsOrArray9 = _slicedToArray(optionsOrArray, 5);

        // $FlowFixMe
        content = _optionsOrArray9[0];
        subscript = _optionsOrArray9[1];
        scale = _optionsOrArray9[2];
        offset = _optionsOrArray9[3];
        inSize // $FlowFixMe
        = _optionsOrArray9[4];
      } else {
        content = optionsOrArray.content;
        subscript = optionsOrArray.subscript;
        scale = optionsOrArray.scale;
        offset = optionsOrArray.offset;
        inSize = optionsOrArray.inSize;
      } // $FlowFixMe


      return this.supSub({
        // $FlowFixMe
        content: content,
        // $FlowFixMe
        subscript: subscript,
        // $FlowFixMe
        subscriptOffset: offset,
        // $FlowFixMe
        inSize: inSize,
        // $FlowFixMe
        scale: scale
      });
    }
  }, {
    key: "box",
    value: function box(optionsOrArray) {
      var content;
      var symbol;
      var inSize;
      var space;
      var topSpace;
      var bottomSpace;
      var leftSpace;
      var rightSpace;
      var fullContentBounds;
      var useFullBounds;
      var defaultOptions = {
        inSize: false,
        space: 0,
        topSpace: null,
        bottomSpace: null,
        leftSpace: null,
        rightSpace: null,
        fullContentBounds: false,
        useFullBounds: false
      };

      if (Array.isArray(optionsOrArray)) {
        var _optionsOrArray10 = _slicedToArray(optionsOrArray, 10);

        content = _optionsOrArray10[0];
        symbol = _optionsOrArray10[1];
        inSize = _optionsOrArray10[2];
        space = _optionsOrArray10[3];
        topSpace = _optionsOrArray10[4];
        rightSpace = _optionsOrArray10[5];
        bottomSpace = _optionsOrArray10[6];
        leftSpace = _optionsOrArray10[7];
        fullContentBounds = _optionsOrArray10[8];
        useFullBounds = _optionsOrArray10[9];
      } else {
        content = optionsOrArray.content;
        symbol = optionsOrArray.symbol;
        inSize = optionsOrArray.inSize;
        space = optionsOrArray.space;
        topSpace = optionsOrArray.topSpace;
        rightSpace = optionsOrArray.rightSpace;
        bottomSpace = optionsOrArray.bottomSpace;
        leftSpace = optionsOrArray.leftSpace;
        fullContentBounds = optionsOrArray.fullContentBounds;
        useFullBounds = optionsOrArray.useFullBounds;
      }

      var optionsIn = {
        content: content,
        symbol: symbol,
        inSize: inSize,
        space: space,
        topSpace: topSpace,
        rightSpace: rightSpace,
        bottomSpace: bottomSpace,
        leftSpace: leftSpace,
        fullContentBounds: fullContentBounds,
        useFullBounds: useFullBounds
      };
      var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, optionsIn);
      return this.annotate({
        content: content,
        inSize: options.inSize,
        fullContentBounds: options.fullContentBounds,
        useFullBounds: options.useFullBounds,
        glyphs: {
          encompass: {
            symbol: symbol,
            space: options.space,
            leftSpace: options.leftSpace,
            rightSpace: options.rightSpace,
            topSpace: options.topSpace,
            bottomSpace: options.bottomSpace
          }
        }
      });
    }
  }, {
    key: "pad",
    value: function pad(optionsOrContent) {
      var content;
      var top;
      var right;
      var bottom;
      var left;
      var defaultOptions = {
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
      };

      if (Array.isArray(optionsOrContent)) {
        var _optionsOrContent = _slicedToArray(optionsOrContent, 5);

        content = _optionsOrContent[0];
        top = _optionsOrContent[1];
        right = _optionsOrContent[2];
        bottom = _optionsOrContent[3];
        left = _optionsOrContent[4];
      } else {
        content = optionsOrContent.content;
        top = optionsOrContent.top;
        right = optionsOrContent.right;
        bottom = optionsOrContent.bottom;
        left = optionsOrContent.left;
      }

      var optionsIn = {
        top: top,
        right: right,
        bottom: bottom,
        left: left
      };
      var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, optionsIn);
      return this.annotate({
        content: content,
        topSpace: options.top,
        bottomSpace: options.bottom,
        rightSpace: options.right,
        leftSpace: options.left
      });
    }
  }, {
    key: "topBar",
    value: function topBar(optionsOrArray) {
      return this.bar(optionsOrArray, {
        side: 'top'
      });
    }
  }, {
    key: "bottomBar",
    value: function bottomBar(optionsOrArray) {
      return this.bar(optionsOrArray, {
        side: 'bottom'
      });
    }
  }, {
    key: "matrix",
    value: function matrix(optionsOrArray) {
      var _this3 = this;

      var content;
      var left;
      var right;
      var order;
      var fit;
      var space;
      var scale;
      var yAlign;
      var brac;
      var fullContentBounds;
      var defaultOptions = {
        contentScale: 0.7,
        fit: 'min',
        space: [0.05, 0.05],
        yAlign: 'baseline',
        brac: {},
        fullContentBounds: false
      };

      if (Array.isArray(optionsOrArray)) {
        var _optionsOrArray11 = _slicedToArray(optionsOrArray, 10);

        order = _optionsOrArray11[0];
        left = _optionsOrArray11[1];
        content = _optionsOrArray11[2];
        right = _optionsOrArray11[3];
        scale = _optionsOrArray11[4];
        fit = _optionsOrArray11[5];
        space = _optionsOrArray11[6];
        yAlign = _optionsOrArray11[7];
        brac = _optionsOrArray11[8];
        fullContentBounds = _optionsOrArray11[9];
      } else {
        order = optionsOrArray.order;
        left = optionsOrArray.left;
        content = optionsOrArray.content;
        right = optionsOrArray.right;
        scale = optionsOrArray.scale;
        fit = optionsOrArray.fit;
        space = optionsOrArray.space;
        yAlign = optionsOrArray.yAlign;
        brac = optionsOrArray.brac;
        fullContentBounds = optionsOrArray.fullContentBounds;
      }

      var optionsIn = {
        space: space,
        fit: fit,
        order: order,
        contentScale: scale,
        brac: brac,
        yAlign: yAlign,
        fullContentBounds: fullContentBounds
      };
      var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, optionsIn);
      var contentArray = [];

      if (content != null) {
        // $FlowFixMe
        contentArray = content.map(function (c) {
          return _this3.contentToElement(c);
        });
      }

      if (options.order == null || options.order[0] * options.order[1] !== contentArray.length) {
        options.order = [1, contentArray.length];
      }

      if (options.space != null) {
        options.space = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(options.space);
      }

      var matrixContent = new _Elements_Matrix__WEBPACK_IMPORTED_MODULE_6__["default"](contentArray, [], options);

      if (left != null && right != null) {
        return this.brac(Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, options.brac, {
          content: matrixContent,
          left: left,
          right: right
        }));
      }

      return matrixContent;
    }
  }, {
    key: "int",
    value: function int(optionsOrArray) {
      var content;
      var symbol;
      var space;
      var topSpace;
      var bottomSpace;
      var height;
      var yOffset;
      var inSize;
      var from;
      var to;
      var scale;
      var fromScale;
      var toScale; // let fromSpace;
      // let toSpace;

      var fromOffset;
      var toOffset;
      var limitsPosition;
      var limitsAroundContent;
      var fromXPosition;
      var fromYPosition;
      var fromXAlign;
      var fromYAlign;
      var toXPosition;
      var toYPosition;
      var toXAlign;
      var toYAlign;
      var fullBoundsContent;
      var useFullBounds;
      var defaultOptions = {
        inSize: true,
        space: 0.05,
        topSpace: 0.1,
        bottomSpace: 0.1,
        height: null,
        yOffset: 0,
        contentScale: 1,
        fromScale: 0.5,
        toScale: 0.5,
        fromOffset: [0, 0],
        toOffset: [0.04, 0],
        limitsPosition: 'side',
        limitsAroundContent: true,
        fromXPosition: 0.5,
        fromYPosition: 'bottom',
        fromXAlign: 'left',
        fromYAlign: 'middle',
        toXPosition: 'right',
        toYPosition: 'top',
        toXAlign: 'left',
        toYAlign: 'middle',
        fullBoundsContent: false,
        useFullBounds: false
      };

      if (Array.isArray(optionsOrArray)) {
        var _optionsOrArray12 = _slicedToArray(optionsOrArray, 27);

        // $FlowFixMe
        symbol = _optionsOrArray12[0];
        content = _optionsOrArray12[1];
        from = _optionsOrArray12[2];
        to = _optionsOrArray12[3];
        inSize = _optionsOrArray12[4];
        space = _optionsOrArray12[5];
        // $FlowFixMe
        topSpace = _optionsOrArray12[6];
        bottomSpace = _optionsOrArray12[7];
        // $FlowFixMe
        height = _optionsOrArray12[8];
        yOffset = _optionsOrArray12[9];
        scale = _optionsOrArray12[10];
        // $FlowFixMe
        fromScale = _optionsOrArray12[11];
        toScale = _optionsOrArray12[12];
        // $FlowFixMe
        fromOffset = _optionsOrArray12[13];
        toOffset = _optionsOrArray12[14];
        limitsPosition = _optionsOrArray12[15];
        // $FlowFixMe
        limitsAroundContent = _optionsOrArray12[16];
        // $FlowFixMe
        fromXPosition = _optionsOrArray12[17];
        fromYPosition = _optionsOrArray12[18];
        fromXAlign = _optionsOrArray12[19];
        fromYAlign = _optionsOrArray12[20];
        // $FlowFixMe
        toXPosition = _optionsOrArray12[21];
        toYPosition = _optionsOrArray12[22];
        toXAlign = _optionsOrArray12[23];
        toYAlign = _optionsOrArray12[24];
        // $FlowFixMe
        fullBoundsContent = _optionsOrArray12[25];
        useFullBounds = _optionsOrArray12[26];
      } else {
        content = optionsOrArray.content;
        symbol = optionsOrArray.symbol;
        from = optionsOrArray.from;
        to = optionsOrArray.to;
        inSize = optionsOrArray.inSize;
        space = optionsOrArray.space;
        topSpace = optionsOrArray.topSpace;
        bottomSpace = optionsOrArray.bottomSpace;
        height = optionsOrArray.height;
        yOffset = optionsOrArray.yOffset;
        scale = optionsOrArray.scale;
        fromScale = optionsOrArray.fromScale;
        toScale = optionsOrArray.toScale;
        fromOffset = optionsOrArray.fromOffset;
        toOffset = optionsOrArray.toOffset;
        limitsPosition = optionsOrArray.limitsPosition;
        limitsAroundContent = optionsOrArray.limitsAroundContent;
        fromXPosition = optionsOrArray.fromXPosition;
        fromYPosition = optionsOrArray.fromYPosition;
        fromXAlign = optionsOrArray.fromXAlign;
        fromYAlign = optionsOrArray.fromYAlign;
        toXPosition = optionsOrArray.toXPosition;
        toYPosition = optionsOrArray.toYPosition;
        toXAlign = optionsOrArray.toXAlign;
        toYAlign = optionsOrArray.toYAlign;
        fullBoundsContent = optionsOrArray.fullBoundsContent;
        useFullBounds = optionsOrArray.useFullBounds;
      }

      if (limitsPosition === 'topBottom') {
        defaultOptions.fromXPosition = 0.1;
        defaultOptions.fromYPosition = 'bottom';
        defaultOptions.fromXAlign = 'center';
        defaultOptions.fromYAlign = 'top'; // $FlowFixMe

        defaultOptions.toXPosition = 0.9;
        defaultOptions.toYPosition = 'top';
        defaultOptions.toXAlign = 'center';
        defaultOptions.toYAlign = 'bottom';
        defaultOptions.fromOffset = [0, -0.04];
        defaultOptions.toOffset = [0, 0.04];
      }

      if (limitsPosition === 'topBottomCenter') {
        // $FlowFixMe
        defaultOptions.fromXPosition = 'center';
        defaultOptions.fromYPosition = 'bottom';
        defaultOptions.fromXAlign = 'center';
        defaultOptions.fromYAlign = 'top';
        defaultOptions.toXPosition = 'center';
        defaultOptions.toYPosition = 'top';
        defaultOptions.toXAlign = 'center';
        defaultOptions.toYAlign = 'bottom';
        defaultOptions.fromOffset = [0, -0.04];
        defaultOptions.toOffset = [0, 0.04];
      }

      var optionsIn = {
        space: space,
        topSpace: topSpace,
        bottomSpace: bottomSpace,
        height: height,
        yOffset: yOffset,
        inSize: inSize,
        contentScale: scale,
        fromScale: fromScale,
        toScale: toScale,
        // fromSpace,
        // toSpace,
        fromOffset: fromOffset,
        toOffset: toOffset,
        limitsPosition: limitsPosition,
        limitsAroundContent: limitsAroundContent,
        fromXPosition: fromXPosition,
        fromYPosition: fromYPosition,
        fromXAlign: fromXAlign,
        fromYAlign: fromYAlign,
        toXPosition: toXPosition,
        toYPosition: toYPosition,
        toXAlign: toXAlign,
        toYAlign: toYAlign,
        fullBoundsContent: fullBoundsContent,
        useFullBounds: useFullBounds
      };
      var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, optionsIn);
      options.fromOffset = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(options.fromOffset);
      options.toOffset = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(options.toOffset);
      var annotations = [{
        content: to,
        xPosition: options.toXPosition,
        yPosition: options.toYPosition,
        xAlign: options.toXAlign,
        yAlign: options.toYAlign,
        offset: options.toOffset,
        scale: options.toScale
      }, {
        content: from,
        xPosition: options.fromXPosition,
        yPosition: options.fromYPosition,
        xAlign: options.fromXAlign,
        yAlign: options.fromYAlign,
        offset: options.fromOffset,
        scale: options.fromScale
      }];
      return this.annotate({
        // $FlowFixMe
        content: content,
        inSize: options.inSize,
        contentScale: options.contentScale,
        fullBoundsContent: options.fullBoundsContent,
        useFullBounds: options.useFullBounds,
        glyphs: {
          left: {
            // $FlowFixMe
            symbol: symbol,
            space: options.space,
            topSpace: options.topSpace,
            bottomSpace: options.bottomSpace,
            height: options.height,
            yOffset: options.yOffset,
            annotationsOverContent: options.limitsAroundContent,
            // $FlowFixMe
            annotations: annotations
          }
        }
      });
    }
  }, {
    key: "sumOf",
    value: function sumOf(options) {
      return this.sumProd(options);
    }
  }, {
    key: "prodOf",
    value: function prodOf(options) {
      return this.sumProd(options);
    }
  }, {
    key: "sumProd",
    value: function sumProd(optionsOrArray) {
      var content;
      var symbol;
      var space;
      var topSpace;
      var bottomSpace;
      var height;
      var yOffset;
      var inSize;
      var from;
      var to;
      var scale;
      var fromScale;
      var toScale;
      var fromSpace;
      var toSpace;
      var fromOffset;
      var toOffset;
      var fullBoundsContent;
      var useFullBounds;
      var defaultOptions = {
        inSize: true,
        space: 0.05,
        topSpace: 0.07,
        bottomSpace: 0.07,
        height: null,
        yOffset: 0,
        contentScale: 1,
        fromScale: 0.5,
        toScale: 0.5,
        fromSpace: 0.04,
        toSpace: 0.04,
        fromOffset: [0, 0],
        toOffset: [0, 0],
        fullBoundsContent: false,
        useFullBounds: false
      };

      if (Array.isArray(optionsOrArray)) {
        var _optionsOrArray13 = _slicedToArray(optionsOrArray, 19);

        symbol = _optionsOrArray13[0];
        content = _optionsOrArray13[1];
        from = _optionsOrArray13[2];
        to = _optionsOrArray13[3];
        inSize = _optionsOrArray13[4];
        space = _optionsOrArray13[5];
        topSpace = _optionsOrArray13[6];
        bottomSpace = _optionsOrArray13[7];
        height = _optionsOrArray13[8];
        yOffset = _optionsOrArray13[9];
        scale = _optionsOrArray13[10];
        fromScale = _optionsOrArray13[11];
        toScale = _optionsOrArray13[12];
        fromSpace = _optionsOrArray13[13];
        toSpace = _optionsOrArray13[14];
        fromOffset = _optionsOrArray13[15];
        toOffset = _optionsOrArray13[16];
        fullBoundsContent = _optionsOrArray13[17];
        useFullBounds = _optionsOrArray13[18];
      } else {
        symbol = optionsOrArray.symbol;
        content = optionsOrArray.content;
        from = optionsOrArray.from;
        to = optionsOrArray.to;
        inSize = optionsOrArray.inSize;
        space = optionsOrArray.space;
        topSpace = optionsOrArray.topSpace;
        bottomSpace = optionsOrArray.bottomSpace;
        height = optionsOrArray.height;
        yOffset = optionsOrArray.yOffset;
        scale = optionsOrArray.scale;
        fromScale = optionsOrArray.fromScale;
        toScale = optionsOrArray.toScale;
        fromSpace = optionsOrArray.fromSpace;
        toSpace = optionsOrArray.toSpace;
        fromOffset = optionsOrArray.fromOffset;
        toOffset = optionsOrArray.toOffset;
        fullBoundsContent = optionsOrArray.fullBoundsContent;
        useFullBounds = optionsOrArray.useFullBounds;
      }

      var optionsIn = {
        space: space,
        topSpace: topSpace,
        bottomSpace: bottomSpace,
        height: height,
        yOffset: yOffset,
        inSize: inSize,
        contentScale: scale,
        fromScale: fromScale,
        toScale: toScale,
        fromSpace: fromSpace,
        toSpace: toSpace,
        fromOffset: fromOffset,
        toOffset: toOffset,
        fullBoundsContent: fullBoundsContent,
        useFullBounds: useFullBounds
      };
      var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, optionsIn);
      var annotations = [{
        content: to,
        xPosition: 'center',
        yPosition: 'top',
        xAlign: 'center',
        yAlign: 'bottom',
        offset: Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(options.toOffset).add(0, options.toSpace),
        scale: options.toScale
      }, {
        content: from,
        xPosition: 'center',
        yPosition: 'bottom',
        xAlign: 'center',
        yAlign: 'top',
        offset: Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(options.fromOffset).add(0, -options.fromSpace),
        scale: options.fromScale
      }];
      return this.annotate({
        content: content,
        contentScale: options.contentScale,
        fullBoundsContent: options.fullBoundsContent,
        useFullBounds: options.useFullBounds,
        glyphs: {
          left: {
            // $FlowFixMe
            symbol: symbol,
            // $FlowFixMe
            annotations: annotations,
            // $FlowFixMe
            space: space,
            topSpace: options.topSpace,
            bottomSpace: options.bottomSpace,
            yOffset: options.yOffset,
            height: options.height
          }
        },
        inSize: options.inSize
      });
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "processComment",
    value: function processComment(optionsOrArray) {
      var content;
      var comment;
      var symbol;
      var contentSpace;
      var commentSpace;
      var scale;
      var inSize;
      var fullContentBounds;
      var useFullBounds;

      if (Array.isArray(optionsOrArray)) {
        var _optionsOrArray14 = _slicedToArray(optionsOrArray, 9);

        content = _optionsOrArray14[0];
        comment = _optionsOrArray14[1];
        symbol = _optionsOrArray14[2];
        contentSpace = _optionsOrArray14[3];
        commentSpace = _optionsOrArray14[4];
        scale = _optionsOrArray14[5];
        inSize = _optionsOrArray14[6];
        fullContentBounds = _optionsOrArray14[7];
        useFullBounds = _optionsOrArray14[8];
      } else {
        content = optionsOrArray.content;
        comment = optionsOrArray.comment;
        symbol = optionsOrArray.symbol;
        contentSpace = optionsOrArray.contentSpace;
        commentSpace = optionsOrArray.commentSpace;
        scale = optionsOrArray.scale;
        inSize = optionsOrArray.inSize;
        fullContentBounds = optionsOrArray.fullContentBounds;
        useFullBounds = optionsOrArray.useFullBounds;
      }

      var optionsIn = {
        contentSpace: contentSpace,
        commentSpace: commentSpace,
        scale: scale,
        inSize: inSize,
        useFullBounds: useFullBounds,
        fullContentBounds: fullContentBounds
      };
      var defaultOptions = {
        contentSpace: 0.03,
        commentSpace: 0.03,
        scale: 0.6,
        inSize: true,
        fullContentBounds: false,
        useFullBounds: false
      };
      var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, optionsIn);
      return [content, comment, symbol, options.contentSpace, options.commentSpace, options.scale, options.inSize, options.fullContentBounds, options.useFullBounds];
    } // $FlowFixMe

  }, {
    key: "topComment",
    value: function topComment() {
      var _this$processComment = this.processComment.apply(this, arguments),
          _this$processComment2 = _slicedToArray(_this$processComment, 9),
          content = _this$processComment2[0],
          comment = _this$processComment2[1],
          symbol = _this$processComment2[2],
          contentSpaceToUse = _this$processComment2[3],
          commentSpaceToUse = _this$processComment2[4],
          scaleToUse = _this$processComment2[5],
          inSize = _this$processComment2[6],
          fullContentBounds = _this$processComment2[7],
          useFullBounds = _this$processComment2[8];

      var annotations = [{
        content: comment,
        xPosition: 'center',
        yPosition: 'top',
        xAlign: 'center',
        yAlign: 'bottom',
        scale: scaleToUse,
        offset: [0, commentSpaceToUse]
      }];

      if (symbol === '' || symbol == null) {
        return this.annotate({
          content: content,
          // $FlowFixMe
          annotations: annotations,
          inSize: inSize
        });
      }

      return this.annotate({
        content: content,
        fullContentBounds: fullContentBounds,
        useFullBounds: useFullBounds,
        glyphs: {
          top: {
            symbol: symbol,
            // $FlowFixMe
            annotations: annotations,
            space: contentSpaceToUse
          }
        },
        inSize: inSize
      });
    } // $FlowFixMe

  }, {
    key: "bottomComment",
    value: function bottomComment() {
      var _this$processComment3 = this.processComment.apply(this, arguments),
          _this$processComment4 = _slicedToArray(_this$processComment3, 9),
          content = _this$processComment4[0],
          comment = _this$processComment4[1],
          symbol = _this$processComment4[2],
          contentSpaceToUse = _this$processComment4[3],
          commentSpaceToUse = _this$processComment4[4],
          scaleToUse = _this$processComment4[5],
          inSize = _this$processComment4[6],
          fullContentBounds = _this$processComment4[7],
          useFullBounds = _this$processComment4[8];

      var annotations = [{
        content: comment,
        xPosition: 'center',
        yPosition: 'bottom',
        xAlign: 'center',
        yAlign: 'top',
        scale: scaleToUse,
        offset: [0, -commentSpaceToUse]
      }];

      if (symbol === '' || symbol == null) {
        return this.annotate({
          content: content,
          // $FlowFixMe
          annotations: annotations,
          inSize: inSize
        });
      }

      return this.annotate({
        content: content,
        fullContentBounds: fullContentBounds,
        useFullBounds: useFullBounds,
        glyphs: {
          bottom: {
            symbol: symbol,
            // $FlowFixMe
            annotations: annotations,
            space: contentSpaceToUse
          }
        },
        inSize: inSize
      });
    }
  }, {
    key: "strike",
    value: function strike(optionsOrArray) {
      var content;
      var symbol;
      var inSize;
      var space;
      var topSpace;
      var bottomSpace;
      var leftSpace;
      var rightSpace;
      var fullContentBounds;
      var useFullBounds;
      var defaultOptions = {
        inSize: false,
        space: 0.02,
        topSpace: null,
        bottomSpace: null,
        leftSpace: null,
        rightSpace: null,
        fullContentBounds: false,
        useFullBounds: false
      };

      if (Array.isArray(optionsOrArray)) {
        var _optionsOrArray15 = _slicedToArray(optionsOrArray, 10);

        content = _optionsOrArray15[0];
        symbol = _optionsOrArray15[1];
        inSize = _optionsOrArray15[2];
        space = _optionsOrArray15[3];
        topSpace = _optionsOrArray15[4];
        rightSpace = _optionsOrArray15[5];
        bottomSpace = _optionsOrArray15[6];
        leftSpace = _optionsOrArray15[7];
        fullContentBounds = _optionsOrArray15[8];
        useFullBounds = _optionsOrArray15[9];
      } else {
        content = optionsOrArray.content;
        symbol = optionsOrArray.symbol;
        inSize = optionsOrArray.inSize;
        space = optionsOrArray.space;
        topSpace = optionsOrArray.topSpace;
        rightSpace = optionsOrArray.rightSpace;
        bottomSpace = optionsOrArray.bottomSpace;
        leftSpace = optionsOrArray.leftSpace;
        fullContentBounds = optionsOrArray.fullContentBounds;
        useFullBounds = optionsOrArray.useFullBounds;
      }

      var glyph = this.getExistingOrAddSymbol(symbol);

      if (glyph != null && glyph.custom.options.style === 'horizontal') {
        defaultOptions.space = 0; // $FlowFixMe

        defaultOptions.leftSpace = 0.02; // $FlowFixMe

        defaultOptions.rightSpace = 0.02; // $FlowFixMe
      }

      var optionsIn = {
        content: content,
        symbol: symbol,
        inSize: inSize,
        space: space,
        topSpace: topSpace,
        rightSpace: rightSpace,
        bottomSpace: bottomSpace,
        leftSpace: leftSpace,
        fullContentBounds: fullContentBounds,
        useFullBounds: useFullBounds
      };
      var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, optionsIn);
      return this.annotate({
        content: content,
        inSize: options.inSize,
        fullContentBounds: options.fullContentBounds,
        useFullBounds: options.useFullBounds,
        glyphs: {
          encompass: {
            symbol: symbol,
            topSpace: options.topSpace,
            bottomSpace: options.bottomSpace,
            leftSpace: options.leftSpace,
            rightSpace: options.rightSpace,
            space: options.space
          }
        }
      });
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "processStrike",
    value: function processStrike(optionsOrContent) {
      var content;
      var comment;
      var symbol;
      var commentSpace;
      var scale;
      var space;
      var inSize;

      if (Array.isArray(optionsOrContent)) {
        // $FlowFixMe
        var _optionsOrContent2 = _slicedToArray(optionsOrContent, 7);

        content = _optionsOrContent2[0];
        symbol = _optionsOrContent2[1];
        comment = _optionsOrContent2[2];
        inSize = _optionsOrContent2[3];
        space = _optionsOrContent2[4];
        scale = _optionsOrContent2[5];
        commentSpace = _optionsOrContent2[6];
      } else {
        content = optionsOrContent.content;
        comment = optionsOrContent.comment;
        symbol = optionsOrContent.symbol;
        inSize = optionsOrContent.inSize;
        space = optionsOrContent.space;
        scale = optionsOrContent.scale;
        commentSpace = optionsOrContent.commentSpace;
      }

      var optionsIn = {
        inSize: inSize,
        commentSpace: commentSpace,
        scale: scale,
        space: space
      };
      var defaultOptions = {
        space: 0,
        scale: 0.5,
        commentSpace: 0.1,
        inSize: true
      };
      var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, optionsIn);
      return [content, symbol, comment, options.inSize, options.commentSpace, options.scale, options.space];
    } // $FlowFixMe

  }, {
    key: "topStrike",
    value: function topStrike() {
      var _this$processStrike = this.processStrike.apply(this, arguments),
          _this$processStrike2 = _slicedToArray(_this$processStrike, 7),
          content = _this$processStrike2[0],
          symbol = _this$processStrike2[1],
          comment = _this$processStrike2[2],
          inSize = _this$processStrike2[3],
          commentSpace = _this$processStrike2[4],
          scale = _this$processStrike2[5],
          space = _this$processStrike2[6];

      var annotations = [{
        content: comment,
        xPosition: 'center',
        yPosition: 'top',
        xAlign: 'center',
        yAlign: 'bottom',
        offset: [0, commentSpace],
        scale: scale
      }];
      return this.annotate({
        // $FlowFixMe
        content: content,
        inSize: inSize,
        glyphs: {
          encompass: {
            // $FlowFixMe
            symbol: symbol,
            space: space,
            // $FlowFixMe
            annotations: annotations
          }
        }
      });
    } // $FlowFixMe

  }, {
    key: "bottomStrike",
    value: function bottomStrike() {
      var _this$processStrike3 = this.processStrike.apply(this, arguments),
          _this$processStrike4 = _slicedToArray(_this$processStrike3, 7),
          content = _this$processStrike4[0],
          symbol = _this$processStrike4[1],
          comment = _this$processStrike4[2],
          inSize = _this$processStrike4[3],
          commentSpace = _this$processStrike4[4],
          scale = _this$processStrike4[5],
          space = _this$processStrike4[6];

      var annotations = [{
        content: comment,
        xPosition: 'center',
        yPosition: 'bottom',
        xAlign: 'center',
        yAlign: 'top',
        offset: [0, -commentSpace],
        scale: scale
      }];
      return this.annotate({
        // $FlowFixMe
        content: content,
        inSize: inSize,
        glyphs: {
          encompass: {
            // $FlowFixMe
            symbol: symbol,
            space: space,
            // $FlowFixMe
            annotations: annotations
          }
        }
      });
    }
  }]);

  return EquationFunctions;
}();

/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/EquationSymbols.js":
/*!********************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/EquationSymbols.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EquationSymbols; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _DiagramPrimitives_DiagramPrimitives__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../DiagramPrimitives/DiagramPrimitives */ "./src/js/diagram/DiagramPrimitives/DiagramPrimitives.js");
/* harmony import */ var _Symbols_Bracket__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Symbols/Bracket */ "./src/js/diagram/DiagramElements/Equation/Symbols/Bracket.js");
/* harmony import */ var _Symbols_Box__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Symbols/Box */ "./src/js/diagram/DiagramElements/Equation/Symbols/Box.js");
/* harmony import */ var _Symbols_Brace__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Symbols/Brace */ "./src/js/diagram/DiagramElements/Equation/Symbols/Brace.js");
/* harmony import */ var _Symbols_SquareBracket__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Symbols/SquareBracket */ "./src/js/diagram/DiagramElements/Equation/Symbols/SquareBracket.js");
/* harmony import */ var _Symbols_AngleBracket__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Symbols/AngleBracket */ "./src/js/diagram/DiagramElements/Equation/Symbols/AngleBracket.js");
/* harmony import */ var _Symbols_Bar__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Symbols/Bar */ "./src/js/diagram/DiagramElements/Equation/Symbols/Bar.js");
/* harmony import */ var _Symbols_Sum__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Symbols/Sum */ "./src/js/diagram/DiagramElements/Equation/Symbols/Sum.js");
/* harmony import */ var _Symbols_Product__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Symbols/Product */ "./src/js/diagram/DiagramElements/Equation/Symbols/Product.js");
/* harmony import */ var _Symbols_Integral__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Symbols/Integral */ "./src/js/diagram/DiagramElements/Equation/Symbols/Integral.js");
/* harmony import */ var _Symbols_Arrow__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Symbols/Arrow */ "./src/js/diagram/DiagramElements/Equation/Symbols/Arrow.js");
/* harmony import */ var _Symbols_Vinculum__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Symbols/Vinculum */ "./src/js/diagram/DiagramElements/Equation/Symbols/Vinculum.js");
/* harmony import */ var _Symbols_Strike__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Symbols/Strike */ "./src/js/diagram/DiagramElements/Equation/Symbols/Strike.js");
/* harmony import */ var _Symbols_Radical__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./Symbols/Radical */ "./src/js/diagram/DiagramElements/Equation/Symbols/Radical.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }



 // import { DiagramElementCollection } from '../../Element';
// import Integral from './Symbols/Integral';
// import SuperSub from './Elements/SuperSub';

 // import BracketNew from './Symbols/BracketNew';

 // import Radical from './Symbols/Radical';



 // import SquareBracketNew from './Symbols/SquareBracketNew';



 // import SimpleIntegral from './Symbols/SimpleIntegral';





 // import BracketNew from './Symbols/BracketNew';
// import BraceNew from './Symbols/BraceNew';
// import { Annotation, AnnotationInformation } from './Elements/Annotation';
// export type TypeSymbolOptions = {
//   color?: Array<number>,
//   numLines?: number,
//   side?: 'left' | 'right' | 'bottom' | 'top',
//   width?: number,
//   fill?: boolean,
//   staticSize?: ?(Point | [number, number] | number),
//   startWidth?: number,
//   lineWidth?: number,
//   startHeight?: number,
//   maxStartWidth?: ?number,
//   maxStartHeight?: ?number,
//   proportionalToHeight?: boolean,
//   endLength?: number,
//   sides?: number,
//   tipWidth?: number,
//   radius?: number,
//   arrowWidth?: number,
//   arrowHeight?: number,
// }

/**
 * Vinculum equation symbol
 *
 * <pre>
 *                          width
 *       |<---------------------------------------->|
 *       |                                          |
 *       |                                          | ____
 *       00000000000000000000000000000000000000000000   A
 *       00000000000000000000000000000000000000000000   |  lineWidth
 *       00000000000000000000000000000000000000000000 __V_
 *
 * </pre>
 * @property {'vinculum'} symbol
 * @property {Array<number>} [color] (equation color)
 * @property {number} [lineWidth] (`0.01`)
 * @property {'static' | 'dynamic'} [draw] `'dynamic'` updates vertices on
 * resize, `'static'` only changes scale transform (`dynamic`)
 * @property {number | 'first'} [staticWidth] used when `draw`=`static`.
 * `number` sets width of static symbol - `'first'` calculates and sets width
 * based on first use (`'first'`)
 *
 * @example
 * eqn.addElements({
 *   v: {
 *     symbol: 'vinculum',
 *     color: [1, 0, 0, 1],
 *     lineWidth: 0.01,
 *   },
 * })
 */

var EquationSymbols =
/*#__PURE__*/
function () {
  function EquationSymbols(shapes, defaultColor) {
    _classCallCheck(this, EquationSymbols);

    this.shapes = shapes;
    this.defaultColor = defaultColor;
  }

  _createClass(EquationSymbols, [{
    key: "get",
    value: function get(name, options) {
      if (name === 'vinculum') {
        // $FlowFixMe
        return this.vinculum(options);
      }

      if (name === 'strike') {
        // $FlowFixMe
        return this.strike(options);
      }

      if (name === 'bracket') {
        // $FlowFixMe
        return this.bracket(options);
      }

      if (name === 'squareBracket') {
        // $FlowFixMe
        return this.squareBracket(options);
      }

      if (name === 'brace') {
        // $FlowFixMe
        return this.brace(options);
      }

      if (name === 'bar') {
        // $FlowFixMe
        return this.bar(options);
      }

      if (name === 'box') {
        // $FlowFixMe
        return this.box(options);
      }

      if (name === 'angleBracket') {
        // $FlowFixMe
        return this.angleBracket(options);
      }

      if (name === 'radical') {
        // $FlowFixMe
        return this.radical(options);
      }

      if (name === 'sum') {
        // $FlowFixMe
        return this.sum(options);
      }

      if (name === 'prod') {
        // $FlowFixMe
        return this.product(options);
      }

      if (name === 'int') {
        // $FlowFixMe
        return this.integral(options);
      }

      if (name === 'arrow') {
        // $FlowFixMe
        return this.arrow(options);
      }

      return null;
    } // vinculumOld(options: { color?: Array<number> } = {}) {
    //   let { color } = options;
    //   if (color == null) {
    //     color = this.defaultColor;
    //   }
    //   return this.shapes.horizontalLine(
    //     new Point(0, 0),
    //     1, 1, 0,
    //     color,
    //     new Transform('vinculum').scale(1, 1).translate(0, 0),
    //   );
    // }

  }, {
    key: "vinculum",
    value: function vinculum(options) {
      var defaultOptions = {
        color: this.defaultColor,
        lineWidth: null,
        staticHeight: null,
        // not definable by user
        draw: 'dynamic',
        staticWidth: 'first'
      };
      var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, options);
      return new _Symbols_Vinculum__WEBPACK_IMPORTED_MODULE_13__["default"](this.shapes.webgl, optionsToUse.color, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('VinculumSymbol').scale(1, 1).translate(0, 0), this.shapes.limits, optionsToUse, 'strip');
    }
  }, {
    key: "box",
    value: function box(optionsIn) {
      var defaultOptions = {
        color: this.defaultColor,
        fill: false,
        width: null,
        height: null,
        lineWidth: 0.01,
        draw: 'dynamic',
        staticHeight: 'first',
        staticWidth: 'first'
      };
      var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, optionsIn);
      return new _Symbols_Box__WEBPACK_IMPORTED_MODULE_4__["default"](this.shapes.webgl, optionsToUse.color, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('Box').scale(1, 1).translate(0, 0), this.shapes.limits, optionsToUse, 'strip');
    }
  }, {
    key: "arrow",
    value: function arrow(options) {
      var defaultOptions = {
        color: this.defaultColor,
        direction: 'right',
        lineWidth: 0.01,
        arrowWidth: 0.03,
        arrowHeight: 0.04,
        staticHeight: 'first',
        draw: 'static',
        staticWidth: null // not definable by user

      };
      var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, options);

      if (optionsToUse.direction === 'left' || optionsToUse.direction === 'right') {
        optionsToUse.side = 'top';
      } else {
        optionsToUse.side = 'left';
      }

      return new _Symbols_Arrow__WEBPACK_IMPORTED_MODULE_12__["default"](this.shapes.webgl, optionsToUse.color, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('ArrowSymbol').scale(1, 1).translate(0, 0), this.shapes.limits, optionsToUse, 'strip');
    }
  }, {
    key: "sum",
    value: function sum(options) {
      var defaultOptions = {
        color: this.defaultColor,
        lineWidth: null,
        sides: 5,
        staticHeight: 'first',
        draw: 'static',
        staticWidth: null // not definable by user

      };
      var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, options);
      return new _Symbols_Sum__WEBPACK_IMPORTED_MODULE_9__["default"](this.shapes.webgl, optionsToUse.color, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('sum').scale(1, 1).translate(0, 0), this.shapes.limits, optionsToUse, 'strip');
    }
  }, {
    key: "product",
    value: function product(options) {
      var defaultOptions = {
        color: this.defaultColor,
        lineWidth: null,
        sides: 5,
        staticHeight: 'first',
        draw: 'static',
        staticWidth: null // not definable by user

      };
      var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, options);
      return new _Symbols_Product__WEBPACK_IMPORTED_MODULE_10__["default"](this.shapes.webgl, optionsToUse.color, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('Sum').scale(1, 1).translate(0, 0), this.shapes.limits, optionsToUse, 'strip');
    }
  }, {
    key: "integral",
    value: function integral(options) {
      var defaultOptions = {
        color: this.defaultColor,
        lineWidth: null,
        width: null,
        tipWidth: null,
        // percentage: 0.95,
        sides: 30,
        // staticSize: 'first',
        // radius: 0.03,
        serif: true,
        staticHeight: 'first',
        draw: 'static',
        staticWidth: null,
        // not definable by user
        num: 1,
        type: 'generic',
        serifSides: 10,
        lineIntegralSides: 20
      };
      var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, options);
      return new _Symbols_Integral__WEBPACK_IMPORTED_MODULE_11__["default"](this.shapes.webgl, optionsToUse.color, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('Integral').scale(1, 1).translate(0, 0), this.shapes.limits, // optionsToUse.staticSize,
      optionsToUse, 'triangles');
    }
  }, {
    key: "radical",
    value: function radical(optionsIn) {
      var defaultOptions = {
        color: this.defaultColor,
        lineWidth: 0.01,
        staticSize: null,
        startHeight: 0.5,
        startWidth: 0.5,
        maxStartWidth: 0.15,
        maxStartHeight: 0.15,
        proportionalToHeight: true,
        draw: 'dynamic',
        staticHeight: 'first',
        staticWidth: 'first'
      };

      if (optionsIn.proportionalToHeight != null && optionsIn.proportionalToHeight === false) {
        defaultOptions.startHeight = 0.15;
        defaultOptions.startWidth = 0.15; // defaultOptions.maxStartHeight = null;
        // defaultOptions.maxStartWidth = null;
      }

      var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, optionsIn);
      return new _Symbols_Radical__WEBPACK_IMPORTED_MODULE_15__["default"](this.shapes.webgl, optionsToUse.color, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('bracket').scale(1, 1).translate(0, 0), this.shapes.limits, optionsToUse, 'strip');
    }
  }, {
    key: "strike",
    value: function strike(options) {
      var defaultOptions = {
        style: 'cross',
        color: this.defaultColor,
        lineWidth: null,
        draw: 'dynamic',
        staticHeight: 'first',
        width: null,
        height: null,
        staticWidth: 'first'
      };
      var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, options);
      return new _Symbols_Strike__WEBPACK_IMPORTED_MODULE_14__["default"](this.shapes.webgl, optionsToUse.color, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('bracket').scale(1, 1).translate(0, 0), this.shapes.limits, optionsToUse, 'triangles'); // let { color } = options;
      // if (color == null) {
      //   color = this.defaultColor;
      // }
      // return this.shapes.horizontalLine(
      //   new Point(0, 0),
      //   1, 1, 0,
      //   color,
      //   new Transform('strike').scale(1, 1).rotate(0).translate(0, 0),
      // );
    } // xStrike(options: { color?: Array<number> } = {}) {
    //   let { color } = options;
    //   if (color == null) {
    //     color = this.defaultColor;
    //   }
    //   const cross = this.shapes.collection(new Transform('xStrike')
    //     .scale(1, 1).rotate(0).translate(0, 0));
    //   cross.color = color;
    //   const strike1 = this.shapes.horizontalLine(
    //     new Point(0, 0),
    //     1, 1, 0,
    //     color,
    //     new Transform('strikeLine').scale(1, 1).rotate(0).translate(0, 0),
    //   );
    //   const strike2 = strike1._dup();
    //   cross.add('s1', strike1);
    //   cross.add('s2', strike2);
    //   return cross;
    // }

  }, {
    key: "bracket",
    value: function bracket(options) {
      var defaultOptions = {
        side: 'left',
        color: this.defaultColor,
        lineWidth: null,
        sides: 10,
        draw: 'dynamic',
        staticHeight: 'first',
        width: null,
        tipWidth: null,
        staticWidth: null
      };
      var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, options);
      return new _Symbols_Bracket__WEBPACK_IMPORTED_MODULE_3__["default"](this.shapes.webgl, optionsToUse.color, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('bracket').scale(1, 1).translate(0, 0), this.shapes.limits, optionsToUse, 'strip');
    }
  }, {
    key: "angleBracket",
    value: function angleBracket(options) {
      var defaultOptions = {
        side: 'left',
        lineWidth: null,
        width: null,
        color: this.defaultColor,
        draw: 'dynamic',
        staticHeight: 'first'
      };
      var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, options);
      return new _Symbols_AngleBracket__WEBPACK_IMPORTED_MODULE_7__["default"](this.shapes.webgl, optionsToUse.color, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('bar').scale(1, 1).translate(0, 0), this.shapes.limits, optionsToUse, 'strip');
    }
  }, {
    key: "brace",
    value: function brace(options) {
      var defaultOptions = {
        side: 'left',
        color: this.defaultColor,
        lineWidth: null,
        sides: 10,
        draw: 'dynamic',
        staticHeight: 'first',
        width: null,
        tipWidth: null,
        staticWidth: null
      };
      var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, options);
      return new _Symbols_Brace__WEBPACK_IMPORTED_MODULE_5__["default"](this.shapes.webgl, optionsToUse.color, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('brace').scale(1, 1).translate(0, 0), this.shapes.limits, optionsToUse, 'strip');
    }
  }, {
    key: "bar",
    value: function bar(options) {
      var defaultOptions = {
        side: 'left',
        lineWidth: 0.01,
        color: this.defaultColor,
        draw: 'dynamic',
        staticHeight: 'first'
      };
      var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, options);
      return new _Symbols_Bar__WEBPACK_IMPORTED_MODULE_8__["default"](this.shapes.webgl, optionsToUse.color, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('bar').scale(1, 1).translate(0, 0), this.shapes.limits, optionsToUse, 'strip');
    }
  }, {
    key: "squareBracket",
    value: function squareBracket(options) {
      var defaultOptions = {
        side: 'left',
        lineWidth: null,
        color: this.defaultColor,
        width: null,
        draw: 'dynamic',
        staticHeight: 'first',
        radius: 0,
        sides: 5,
        tipWidth: null
      };
      var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, options); // if (optionsToUse.endLineWidth == null) {
      //   optionsToUse.endLineWidth = optionsToUse.lineWidth * 0.7;
      // }

      return new _Symbols_SquareBracket__WEBPACK_IMPORTED_MODULE_6__["default"](this.shapes.webgl, optionsToUse.color, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('bar').scale(1, 1).translate(0, 0), this.shapes.limits, optionsToUse, 'strip');
    }
  }]);

  return EquationSymbols;
}();



/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/HTMLEquation.js":
/*!*****************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/HTMLEquation.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return HTMLEquation; });
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function makeDiv(id, classes, text) {
  var indent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var indentStr = ' '.repeat(indent);
  var idStr = id ? " id=\"".concat(id, "\"") : '';
  var classString = classes ? " ".concat(classes.join(' ')) : '';
  var out = "".concat(indentStr, "<div").concat(idStr, " class=\"equation_element").concat(classString, "\">\n");
  out += "".concat(text, "\n");
  out += "".concat(indentStr, "</div>");
  return out;
} // Most fundamental Equation Element properties includes element size and
// location, as well as html id and classes.


var HTMLElementProperties =
/*#__PURE__*/
function () {
  function HTMLElementProperties() {
    var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var classes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

    _classCallCheck(this, HTMLElementProperties);

    this.id = id;

    if (Array.isArray(classes)) {
      this.classes = classes;
    } else if (classes.length > 0) {
      this.classes = classes.split(' ');
    } else {
      this.classes = [];
    }
  }

  _createClass(HTMLElementProperties, [{
    key: "render",
    value: function render() {
      var indent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var text = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      return makeDiv(this.id, this.classes, text, indent);
    }
  }]);

  return HTMLElementProperties;
}();

var HTMLElement =
/*#__PURE__*/
function (_HTMLElementPropertie) {
  _inherits(HTMLElement, _HTMLElementPropertie);

  function HTMLElement(text) {
    var _this;

    var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    var classes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

    _classCallCheck(this, HTMLElement);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(HTMLElement).call(this, id, classes));

    _this.classes.push('equation_text');

    _this.text = text;
    return _this;
  }

  _createClass(HTMLElement, [{
    key: "render",
    value: function render() {
      var indent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      return _get(_getPrototypeOf(HTMLElement.prototype), "render", this).call(this, indent, "".concat(' '.repeat(indent + 2)).concat(this.text));
    }
  }]);

  return HTMLElement;
}(HTMLElementProperties);

var HTMLElements =
/*#__PURE__*/
function (_HTMLElementPropertie2) {
  _inherits(HTMLElements, _HTMLElementPropertie2);

  function HTMLElements(content) {
    var _this2;

    var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    var classes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

    _classCallCheck(this, HTMLElements);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(HTMLElements).call(this, id, classes));
    var filteredContent = [];
    content.forEach(function (c) {
      if (c !== null) {
        filteredContent.push(c);
      }
    });
    _this2.content = filteredContent;
    return _this2;
  }

  _createClass(HTMLElements, [{
    key: "render",
    value: function render() {
      var indent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      return _get(_getPrototypeOf(HTMLElements.prototype), "render", this).call(this, indent, this.content.map(function (c) {
        return c.render(indent + 2);
      }).join('\n'));
    }
  }]);

  return HTMLElements;
}(HTMLElementProperties);

var Fraction =
/*#__PURE__*/
function (_HTMLElementPropertie3) {
  _inherits(Fraction, _HTMLElementPropertie3);

  function Fraction(numerator, denominator) {
    var _this3;

    var id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
    var classes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];

    _classCallCheck(this, Fraction);

    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(Fraction).call(this, id, classes));

    _this3.classes.push('fraction');

    _this3.numerator = numerator;
    _this3.denominator = denominator;
    return _this3;
  }

  _createClass(Fraction, [{
    key: "render",
    value: function render() {
      var indent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var s = ' '.repeat(indent + 2);
      var out = '';
      out += "".concat(s, "<div class=\"numerator\">\n");
      out += this.numerator.render(indent + 4);
      out += "\n".concat(s, "</div>\n");
      out += "".concat(s, "<div class=\"fraction_line\"> </div>\n");
      out += "".concat(s, "<div class=\"denominator\">\n");
      out += this.denominator.render(indent + 4);
      out += "\n".concat(s, "</div>");
      return _get(_getPrototypeOf(Fraction.prototype), "render", this).call(this, indent, out);
    }
  }]);

  return Fraction;
}(HTMLElementProperties);

var SuperSub =
/*#__PURE__*/
function (_HTMLElementPropertie4) {
  _inherits(SuperSub, _HTMLElementPropertie4);

  function SuperSub(content, superscript, subscript) {
    var _this4;

    var id = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
    var classes = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';

    _classCallCheck(this, SuperSub);

    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(SuperSub).call(this, id, classes));

    _this4.classes.push('supersub');

    _this4.superscript = superscript;
    _this4.subscript = subscript;
    _this4.content = content;
    return _this4;
  }

  _createClass(SuperSub, [{
    key: "render",
    value: function render() {
      var indent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var s = ' '.repeat(indent + 2);
      var out = '';
      out += "".concat(s, "<div class=\"supsub_content element\">\n");
      out += this.content.render(indent + 2);
      out += "\n".concat(s, "</div>\n");
      out += "".concat(s, "<div class=\"super_sub element\">\n");
      out += "".concat(s, "<div class=\"super_sub_super superscript_text element\">\n");

      if (this.superscript !== null) {
        out += this.superscript.render(indent + 4);
      }

      out += "\n".concat(s, "</div>\n");
      out += "".concat(s, "<div class=\"super_sub_sub subscript_text element\">\n");

      if (this.subscript !== null) {
        out += this.subscript.render(indent + 4);
      }

      out += "\n".concat(s, "</div>");
      out += "\n".concat(s, "</div>\n");
      return _get(_getPrototypeOf(SuperSub.prototype), "render", this).call(this, indent, out);
    }
  }]);

  return SuperSub;
}(HTMLElementProperties);

var Subscript =
/*#__PURE__*/
function (_SuperSub) {
  _inherits(Subscript, _SuperSub);

  function Subscript(content, // eslint-disable-line no-use-before-define
  subscript) {
    var _this5;

    var id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
    var classes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';

    _classCallCheck(this, Subscript);

    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(Subscript).call(this, content, null, subscript, id, classes));

    var index = _this5.classes.indexOf('supersub');

    if (index > -1) {
      _this5.classes.splice(index, 1);
    }

    _this5.classes.push('subscript');

    return _this5;
  }

  return Subscript;
}(SuperSub);

var Superscript =
/*#__PURE__*/
function (_SuperSub2) {
  _inherits(Superscript, _SuperSub2);

  function Superscript(content, // eslint-disable-line no-use-before-define
  superscript) {
    var _this6;

    var id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
    var classes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';

    _classCallCheck(this, Superscript);

    _this6 = _possibleConstructorReturn(this, _getPrototypeOf(Superscript).call(this, content, superscript, null, id, classes));

    var index = _this6.classes.indexOf('supersub');

    if (index > -1) {
      _this6.classes.splice(index, 1);
    }

    _this6.classes.push('superscript');

    return _this6;
  }

  return Superscript;
}(SuperSub);

var Root =
/*#__PURE__*/
function (_HTMLElementPropertie5) {
  _inherits(Root, _HTMLElementPropertie5);

  function Root(content) {
    var _this7;

    var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    var classes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

    _classCallCheck(this, Root);

    _this7 = _possibleConstructorReturn(this, _getPrototypeOf(Root).call(this, id, classes));
    _this7.content = content;
    return _this7;
  }

  _createClass(Root, [{
    key: "render",
    value: function render() {
      var indent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var s = ' '.repeat(indent + 2);
      var out = '';
      out += "".concat(s, "<div class=\"square_root element\">\n");
      out += "".concat(s, "  <div class=\"equation_element radical element\">\n");
      out += "".concat(s, "    &radic;\n");
      out += "".concat(s, "  </div>\n");
      out += this.content.render(indent + 4);
      out += "\n".concat(s, "</div>");
      return _get(_getPrototypeOf(Root.prototype), "render", this).call(this, indent, out);
    }
  }]);

  return Root;
}(HTMLElementProperties); // function contentToE(content: string | HTMLElements): HTMLElements {
//   let c;
//   if (typeof content === 'string') {
//     c = new HTMLElements(content);
//   } else {
//     c = content;
//   }
//   return c;
// }


function contentToElement(content) {
  if (content instanceof HTMLElements) {
    return content;
  }

  if (content instanceof HTMLElement || content instanceof HTMLElementProperties) {
    return new HTMLElements([content]);
  }

  if (typeof content === 'string') {
    return new HTMLElements([new HTMLElement(content)]);
  } // Otherwise must be array


  var elementArray = [];
  content.forEach(function (c) {
    if (typeof c === 'string') {
      elementArray.push(new HTMLElement(c));
    } else {
      elementArray.push(c);
    }
  });
  return new HTMLElements(elementArray);
}

var HTMLEquation =
/*#__PURE__*/
function (_HTMLElements) {
  _inherits(HTMLEquation, _HTMLElements);

  function HTMLEquation() {
    var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var classes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    _classCallCheck(this, HTMLEquation);

    return _possibleConstructorReturn(this, _getPrototypeOf(HTMLEquation).call(this, [], id, classes));
  }

  _createClass(HTMLEquation, [{
    key: "createEq",
    value: function createEq(content) {
      var _this8 = this;

      var elements = [];
      content.forEach(function (c) {
        if (typeof c === 'string') {
          elements.push(new HTMLElement(c));
        } else {
          elements.push(c);
        }

        _this8.content = elements;
      });
    }
  }, {
    key: "htmlElement",
    value: function htmlElement() {
      var element = document.createElement('div');
      element.setAttribute('id', this.id);
      element.innerHTML = this.render();
      this.classes.forEach(function (c) {
        if (c) {
          element.classList.add(c);
        }
      });
      return element;
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "el",
    value: function el(content) {
      var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var classes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      return new HTMLElement(content, id, classes);
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "supsub",
    value: function supsub(content, superscript, subscript) {
      var id = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
      var classes = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
      return new SuperSub(contentToElement(content), contentToElement(superscript), contentToElement(subscript), id, classes);
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "sub",
    value: function sub(content, subscript) {
      var id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      var classes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
      return new Subscript(contentToElement(content), contentToElement(subscript), id, classes);
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "sup",
    value: function sup(content, superscript) {
      var id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      var classes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
      return new Superscript(contentToElement(content), contentToElement(superscript), id, classes);
    } // e(
    //   content: string | Array<HTMLElementProperties>,
    //   id: string = '',
    //   classes: string | Array<string> = [],
    // ) {
    //   return new HTMLElements(content, id, classes);
    // }
    // eslint-disable-next-line class-methods-use-this

  }, {
    key: "frac",
    value: function frac(numerator, denominator) {
      var id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      var classes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
      return new Fraction(contentToElement(numerator), contentToElement(denominator), id, classes);
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "sqrt",
    value: function sqrt(content) {
      var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var classes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      return new Root(contentToElement(content), id, classes);
    }
  }]);

  return HTMLEquation;
}(HTMLElements);



/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/Symbols/AngleBracket.js":
/*!*************************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/Symbols/AngleBracket.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Bar; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _Bracket__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bracket */ "./src/js/diagram/DiagramElements/Equation/Symbols/Bracket.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }




var Bar =
/*#__PURE__*/
function (_Bracket) {
  _inherits(Bar, _Bracket);

  function Bar() {
    _classCallCheck(this, Bar);

    return _possibleConstructorReturn(this, _getPrototypeOf(Bar).apply(this, arguments));
  }

  _createClass(Bar, [{
    key: "getLeftPoints",
    // eslint-disable-next-line class-methods-use-this
    // Angle Bracket
    //                         width
    //                      |<------->|
    //                      |         |
    //                      |      ___
    //           A          |     /  /
    //           |          |    /  /
    //           |          |   /  /
    //           |          |  /  /
    //           |            /  /
    //    height |           /  /
    //           |           \  \
    //           |            \  \
    //           |             \  \
    //           |              \  \
    //           |               \  \
    //           |                \  \
    //           V                 \__\
    // To calculate dimensions, need to solve the below where we know:
    //   * height (h)
    //   * width (w)
    //
    // Looking at the bottom half of the bracket:
    //
    //                                 width
    //                   |<------------------------------>|
    //                   |                                |
    //                   |   tip width           Dh       |
    //                   |<-------------->|<------------->|
    //
    //          ______   __________________...............:
    //          A        :\*               \              :
    //          |        : \  *             \             :
    //          |        :  \   *            \            :
    //          |        :   \    *           \           :
    //          |        :    \     *          \          :
    //          |        :     \      *         \         :
    //          |        :      \       * A      \ D      :
    //   h / 2  |        :       \        *       \       :
    //          |        :        \         *      \      :
    //          |        :       C \          *     \     :
    //          |        :          \           *    \    :
    //          |        :           \            *   \   :
    //          |        :            \             *  \  :
    //          |        :             \              * \ :
    //          |        :              \               *\:
    //          V_____   :...............\________________\  B
    //                                    \               *
    //                        C extension  \          *
    //                                      \      *   E
    //                                     R \ *
    //
    //   - Draw a circle at B of radius lineWidth
    //   - This circle will touch an extended line C at a right angle (R)
    //   - Line E is the line from the circle center (B) to the tangent point (R)
    //   - Line A is the secant and the extended line C is the tangent of the
    //     the angle Theta which is angle between the line A and line E
    //   - The angle between lines E and D is also a right angle (as C || D),
    //     therefore we can calculate the angle between A and D (Beta)
    //   - Calculate the angle from the horiontal to A: a = arctan2(h/2, w)
    //   - Calculate the angle from the horizontal to D: alpha = a + Beta
    //   - Calculate the horizontal component of D: Dh = h / 2 / tan(alpha)
    //   - Calculate Tip Width = w - Dh
    // eslint-disable-next-line class-methods-use-this
    value: function getLeftPoints(options, widthIn, height) {
      // const { side } = options;
      var _this$getVerticalDefa = this.getVerticalDefaultValues(height, widthIn, options),
          lineWidth = _this$getVerticalDefa.lineWidth,
          width = _this$getVerticalDefa.width;

      var line = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width, height / 2));
      var theta = Math.acos(lineWidth / line.distance);
      var beta = Math.PI / 2 - theta;
      var alpha = line.ang + beta;
      var tipWidth = width - height / 2 / Math.tan(alpha);
      var leftPoints = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width - tipWidth, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, height / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width - tipWidth, height)];
      var rightPoints = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](tipWidth, height / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width, height)]; // if (side === 'top' || side === 'bottom') {
      //   return this.getBracketPoints(leftPoints, rightPoints, side, height, width);
      // }

      return [leftPoints, rightPoints, width, height]; // return this.getBracketPoints(leftPoints, rightPoints, side, width, height);
    }
    /* eslint-disable class-methods-use-this */
    // $FlowFixMe

  }, {
    key: "getVerticalDefaultValues",
    value: function getVerticalDefaultValues(height, width, options) {
      var out = {};

      if (width == null && options.width == null) {
        out.width = 97570.78 + (0.004958708 - 97570.78) / (1 + Math.pow(height / 2399858, 0.9383909));
      }

      if (width != null) {
        out.width = width;
      }

      if (options.width != null) {
        out.width = options.width;
      }

      if (options.lineWidth == null) {
        out.lineWidth = (0.2933614 + (0.0001418178 - 0.2933614) / (1 + Math.pow(height / 39.01413, 0.618041))) * 0.7;
      } else {
        out.lineWidth = options.lineWidth;
      }

      return out;
    }
  }]);

  return Bar;
}(_Bracket__WEBPACK_IMPORTED_MODULE_1__["default"]);



/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/Symbols/Arrow.js":
/*!******************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/Symbols/Arrow.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Arrow; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _Bracket__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bracket */ "./src/js/diagram/DiagramElements/Equation/Symbols/Bracket.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }




var Arrow =
/*#__PURE__*/
function (_Bracket) {
  _inherits(Arrow, _Bracket);

  function Arrow() {
    _classCallCheck(this, Arrow);

    return _possibleConstructorReturn(this, _getPrototypeOf(Arrow).apply(this, arguments));
  }

  _createClass(Arrow, [{
    key: "getLeftPoints",
    // eslint-disable-next-line class-methods-use-this
    //                      arrow width
    //                 |<--------------->|
    //                 |                 |
    //                 |        6        |
    //          -------|------- 0 -------|---------
    //          A      |      00000      |        A
    //   arrow  |      |     0000000     |        |
    //   height |      |   00000000000   |        |
    //          V      | 000000000000000 |        |
    //          ---- 5 0000000000000000000 4      |
    //                       0000000              |
    //                    3  0000000 2            |
    //                       0000000              |
    //                       0000000              |
    //                       0000000              |  height
    //                       0000000              |
    //                       0000000              |
    //                       0000000              |
    //                       0000000              |
    //                       0000000              |
    //                       0000000              |
    //                       0000000              |
    //                       0000000              |
    //                       0000000              |
    //                       0000000              V
    //                       0000000 --------------
    //                      1       0
    //                       |     |
    //                       |     |
    //                       |<--->|
    //                     Line Width
    // eslint-disable-next-line class-methods-use-this
    value: function getLeftPoints(options, widthIn, height) {
      var direction = options.direction;

      var _this$getVerticalDefa = this.getVerticalDefaultValues(height, widthIn, options),
          lineWidth = _this$getVerticalDefa.lineWidth,
          arrowWidth = _this$getVerticalDefa.arrowWidth,
          arrowHeight = _this$getVerticalDefa.arrowHeight;

      var p0 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](arrowWidth / 2 + lineWidth / 2, 0);
      var p1 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](arrowWidth / 2 - lineWidth / 2, 0);
      var p2 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](p0.x, height - arrowHeight);
      var p3 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](p1.x, p2.y);
      var p4 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](arrowWidth, p2.y);
      var p5 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, p2.y);
      var p6 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](arrowWidth / 2, height);
      var leftPoints = [p1._dup(), p3._dup(), p5._dup(), p6._dup()];
      var rightPoints = [p0._dup(), p2._dup(), p4._dup(), p6._dup()];

      if (direction === 'down' || direction === 'left') {
        var m = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(1, -1).translate(0, height).m(); // $FlowFixMe

        leftPoints = leftPoints.map(function (p) {
          return p.transformBy(m);
        }); // $FlowFixMe

        rightPoints = rightPoints.map(function (p) {
          return p.transformBy(m);
        });
      } // let side = 'left';
      // if (direction === 'up' || direction === 'down') {
      //   side = 'left';
      // } else if (direction === 'left' || direction === 'right') {
      //   side = 'top';
      // }
      // return [points, widthIn, height];


      return [leftPoints, rightPoints, arrowWidth, height];
    }
    /* eslint-disable class-methods-use-this */
    // $FlowFixMe

  }, {
    key: "getVerticalDefaultValues",
    value: function getVerticalDefaultValues(height, width, options) {
      var out = {};

      if (options.lineWidth == null) {
        out.lineWidth = (0.2933614 + (0.0001418178 - 0.2933614) / (1 + Math.pow(height / 39.01413, 0.618041))) * 0.8;
      } else {
        out.lineWidth = options.lineWidth;
      }

      if (options.arrowWidth == null) {
        out.arrowWidth = out.lineWidth * 3;
      } else {
        out.arrowWidth = options.arrowWidth;
      }

      if (options.arrowHeight == null) {
        out.arrowHeight = out.lineWidth * 3;
      } else {
        out.arrowHeight = options.arrowHeight;
      }

      out.width = out.arrowWidth;
      return out;
    }
  }]);

  return Arrow;
}(_Bracket__WEBPACK_IMPORTED_MODULE_1__["default"]);



/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/Symbols/Bar.js":
/*!****************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/Symbols/Bar.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Bar; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _Bracket__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bracket */ "./src/js/diagram/DiagramElements/Equation/Symbols/Bracket.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }




var Bar =
/*#__PURE__*/
function (_Bracket) {
  _inherits(Bar, _Bracket);

  function Bar() {
    _classCallCheck(this, Bar);

    return _possibleConstructorReturn(this, _getPrototypeOf(Bar).apply(this, arguments));
  }

  _createClass(Bar, [{
    key: "getLeftPoints",
    // eslint-disable-next-line class-methods-use-this
    value: function getLeftPoints(options, widthIn, height) {
      var _this$getVerticalDefa = this.getVerticalDefaultValues(height, widthIn, options),
          lineWidth = _this$getVerticalDefa.lineWidth,
          width = _this$getVerticalDefa.width;

      var leftPoints = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, height)];
      var rightPoints = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](lineWidth, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](lineWidth, height)];
      return [leftPoints, rightPoints, width, height];
    }
    /* eslint-disable class-methods-use-this */
    // $FlowFixMe

  }, {
    key: "getVerticalDefaultValues",
    value: function getVerticalDefaultValues(height, width, options) {
      var out = {};

      if (options.lineWidth == null) {
        out.lineWidth = (0.2933614 + (0.0001418178 - 0.2933614) / (1 + Math.pow(height / 39.01413, 0.618041))) * 0.8;
      } else {
        out.lineWidth = options.lineWidth;
      }

      out.width = out.lineWidth;
      return out;
    }
  }]);

  return Bar;
}(_Bracket__WEBPACK_IMPORTED_MODULE_1__["default"]);



/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/Symbols/Box.js":
/*!****************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/Symbols/Box.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Box; });
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _SymbolNew__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SymbolNew */ "./src/js/diagram/DiagramElements/Equation/Symbols/SymbolNew.js");
/* harmony import */ var _Elements_Bounds__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Elements/Bounds */ "./src/js/diagram/DiagramElements/Equation/Elements/Bounds.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }




 // import WebGLInstance from '../../../webgl/webgl';

var Box =
/*#__PURE__*/
function (_Symbol2) {
  _inherits(Box, _Symbol2);

  function Box() {
    _classCallCheck(this, Box);

    return _possibleConstructorReturn(this, _getPrototypeOf(Box).apply(this, arguments));
  }

  _createClass(Box, [{
    key: "getPoints",
    // eslint-disable-next-line class-methods-use-this
    // getTriangles() {
    //   return 'strip';
    // }
    //                                          width
    //                 |<--------------------------------------------------->|
    //                 |                                                     |
    //                 |                                                     |
    //                2                                                       4
    //         ------- 0000000000000000000000000000000000000000000000000000000
    //         A       0000000000000000000000000000000000000000000000000000000
    //         |       0000 3                                           5 0000
    //         |       0000                                               0000
    //         |       0000                                               0000
    //  height |       0000                                               0000
    //         |       0000                                               0000
    //         |       0000                                               0000
    //         |       0000                                               0000
    //         |       0000 1                                           7 0000
    //         |       0000000000000000000000000000000000000000000000000000000
    //         V______ 0000000000000000000000000000000000000000000000000000000
    //                0                                                        6
    // eslint-disable-next-line class-methods-use-this
    value: function getPoints(options, widthIn, heightIn) {
      var fill = options.fill;

      var _this$getDefaultValue = this.getDefaultValues(heightIn, widthIn, options),
          lineWidth = _this$getDefaultValue.lineWidth,
          width = _this$getDefaultValue.width,
          height = _this$getDefaultValue.height;

      var points;

      if (fill) {
        points = [new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](width, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, height), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](width, height)];
      } else {
        points = [new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](lineWidth, lineWidth), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, height), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](lineWidth, height - lineWidth), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](width, height), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](width - lineWidth, height - lineWidth), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](width, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](width - lineWidth, lineWidth), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](lineWidth, lineWidth)];
      }

      return [points, width, height];
    }
    /* eslint-disable class-methods-use-this */

  }, {
    key: "getBounds",
    value: function getBounds(options, leftIn, bottomIn, widthIn, heightIn) {
      var _this$getDefaultValue2 = this.getDefaultValues(heightIn, widthIn, options),
          lineWidth = _this$getDefaultValue2.lineWidth,
          width = _this$getDefaultValue2.width,
          height = _this$getDefaultValue2.height;

      var bounds = new _Elements_Bounds__WEBPACK_IMPORTED_MODULE_3__["default"]();

      if (options.draw === 'static') {
        var staticWidth = options.staticWidth,
            staticHeight = options.staticHeight;

        if (staticWidth === 'first') {
          staticWidth = width + lineWidth * 2;
        }

        if (staticHeight === 'first') {
          staticHeight = height + lineWidth * 2;
        }

        if (staticWidth == null) {
          staticWidth = 1;
        }

        if (staticHeight == null) {
          staticHeight = 1;
        }

        var heightLineWidthRatio = lineWidth / staticHeight;
        var widthLineWidthRatio = lineWidth / staticWidth;
        bounds.width = width / (1 - 2 * widthLineWidthRatio);
        bounds.height = height / (1 - 2 * heightLineWidthRatio);
        var widthLineWidth = bounds.width * widthLineWidthRatio;
        var heightLineWidth = bounds.height * heightLineWidthRatio;
        bounds.left = leftIn - widthLineWidth;
        bounds.right = bounds.left + bounds.width;
        bounds.bottom = bottomIn - heightLineWidth;
        bounds.top = bounds.bottom + bounds.height;
        bounds.ascent = bounds.height;
        bounds.descent = 0;
      } else {
        bounds.left = leftIn + widthIn / 2 - width / 2 - lineWidth;
        bounds.bottom = bottomIn + heightIn / 2 - height / 2 - lineWidth;
        bounds.width = width + lineWidth * 2;
        bounds.height = height + lineWidth * 2;
        bounds.right = bounds.left + bounds.width;
        bounds.top = bounds.bottom + bounds.height;
        bounds.descent = 0;
        bounds.ascent = bounds.height;
      }

      return bounds;
    }
    /* eslint-disable class-methods-use-this */
    // $FlowFixMe

  }, {
    key: "getDefaultValues",
    value: function getDefaultValues(height, width, options) {
      var out = {};

      if (options.lineWidth != null && typeof options.lineWidth === 'number') {
        out.lineWidth = options.lineWidth;
      } else {
        out.lineWidth = 0.01;
      }

      if (options.fill === true) {
        out.lineWidth = 0;
      }

      if (options.height != null && typeof options.height === 'number') {
        out.height = options.height;
      } else if (height != null) {
        out.height = height;
      } else {
        out.height = 1;
      }

      if (options.width != null && typeof options.width === 'number') {
        out.width = options.width;
      } else if (width != null) {
        out.width = width;
      } else {
        out.width = 1;
      }

      return out;
    }
  }, {
    key: "surround",
    value: function surround(parent, children) {
      var spaceIn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var drawingSpace = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'local';
      var elements = [parent];

      if (children != null && children.length !== 0) {
        elements = parent.getElements(children);
      }

      if (elements.length === 0) {
        return;
      }

      var space = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["getPoint"])(spaceIn);
      var maxBounds;

      if (parent instanceof _Element__WEBPACK_IMPORTED_MODULE_0__["DiagramElementCollection"]) {
        maxBounds = parent.getBoundingRect(drawingSpace, children);
      } else {
        maxBounds = parent.getBoundingRect(drawingSpace);
      }

      maxBounds.left -= space.x;
      maxBounds.bottom -= space.y;
      maxBounds.width += 2 * space.x;
      maxBounds.height += 2 * space.y;
      maxBounds.right = maxBounds.left + maxBounds.width;
      maxBounds.top = maxBounds.bottom + maxBounds.height;
      this.custom.setSize(new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](maxBounds.left, maxBounds.bottom), maxBounds.width, maxBounds.height); // this.drawingObject.updateBox(
      //   maxBounds.width,
      //   maxBounds.height,
      // );
      // this.setPosition(
      //   maxBounds.left + maxBounds.width / 2,
      //   maxBounds.bottom + maxBounds.height / 2,
      // );
    } // surround(parent, childrenToUse, space) {
    //   let elements = [parent];
    //   if (childrenToUse !== '' && childrenToUse != null) {
    //     elements = parent.getElements(childrenToUse);
    //   }
    //   maxBounds = elements.
    // }

  }]);

  return Box;
}(_SymbolNew__WEBPACK_IMPORTED_MODULE_2__["default"]);



/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/Symbols/Brace.js":
/*!******************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/Symbols/Brace.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Brace; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _Bracket__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bracket */ "./src/js/diagram/DiagramElements/Equation/Symbols/Bracket.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }




var Brace =
/*#__PURE__*/
function (_Bracket) {
  _inherits(Brace, _Bracket);

  function Brace() {
    _classCallCheck(this, Brace);

    return _possibleConstructorReturn(this, _getPrototypeOf(Brace).apply(this, arguments));
  }

  _createClass(Brace, [{
    key: "getLeftPoints",
    // eslint-disable-next-line class-methods-use-this
    // getWidth() {
    //   return (type: 'static' | 'dynamic', options: Object, height: number) => {
    //     const { width } = options;
    //     if (type === 'static') {
    //       return height * width;
    //     }
    //     return width;
    //   };
    // }
    //  - Curve R1 and R2 are repeated 4 times in brace
    //  - Curve R1 is a full 90 circle
    //  - Curve R2 > R1 and is less than 90
    //                                       width
    //                               |<--------------->|
    //                               |                 |
    //                               |                *|
    //           A                   |              * *
    //           |                   |       R1   *  *
    //           |                   |          *   *  R2
    //           |                   |        *    *
    //           |                   |       *    *
    //           |                   |       *    *
    //           |                   |      *    *
    //           |                   |      *    *
    //           |                   |      *    *
    //           |                   |      *    *
    //           |                   |      *    *
    //           |                   |      *    *
    //           |                   |      *    *
    //           |                   |      *    *
    //           |                   |      *    *
    //           |                   |      *    *
    //           |                   |     *    *
    //           |                   |     *    *
    //           |                   |    *    *
    //           |                      *   *
    //   height  |                    *  *
    //           |                   * *
    //           |          A        * *
    //           |          |          *  *
    //           |          |        |   *   *
    //           |          |        |     *    *
    //           |          |        |      *    *
    //           |          |        |      *    *
    //           |          |        |       *    *
    //           |          |        |       *    *
    //           |          |        |       *    *
    //           |          |        |       *    *
    //           |    h / 2 |        |       *    *
    //           |          |        |       *    *
    //           |          |        |       *    *
    //           |          |        |       *    *
    //           |          |        |       *    *
    //           |          |        |       *    *
    //           |          |        |        *    *
    //           |          |        |        *    *
    //           |          |        |         *    *
    //           |          |        |           *   *
    //           |          |        |             *  *
    //           V          V        |_______________ *
    //                           (0,0)
    //
    // The solution to a circle that intersect at the same
    //
    //                       |OOO ooo
    //                       |       OOo
    //                       |         | OOo              A
    //                       |         |    OOo           |
    //                       |         |      OOo         |
    //                       |         |        OOo       |
    //                       |         |         OOo      | h
    //                       |         |          OOo     |
    //                       |         |           OOo    |
    //                       |         |           OOo    |
    //                       C---------|-----------OOo    V
    //                       |         |      w      |
    //                       |         |<----------->|
    //                       |                       |
    //                       |          r            |
    //                       |<--------------------->|
    // Circle with radius r intersects a vertical line with height h
    // a distance w from the circle horizontal.
    //
    // Calculate r:
    //          w^2 + h^2
    //     r = -----------
    //              2w
    //
    // Calculate angle from center C to intersection with h:
    //
    //     theta = arcsin (h / r))
    //
    //
    //
    //  For the brace case, the outside radius is a full 90 arc
    //  The inside arc is calculated from the top equations where
    //
    //       w = outsideRadius - lineWidth
    //
    //                              width
    //                   <---------------------->
    //
    //           A       OOO ooo
    //  TipWidth |       00o    OOo
    //           V       00o        OOo   ---------------
    //                     00o         OOo              A
    //                       00o           OOo          |
    //                        00o            OOo        |
    //                         00o            OOo       | h
    //                         00o             OOo      |
    //                          00o            OOo      |
    //  Ci              Co      00o            OOo      V
    //  |                |
    //  |                |     |  line width     |
    //  |                |     |<--------------->|
    //  |                |     |                 |
    //  |  inside radius |     |                 |
    //  |<-------------------->|                 |
    //                   |                       |
    //                   |    outside radius     |
    //                   |<--------------------->|
    //
    //
    // eslint-disable-next-line class-methods-use-this
    value: function getLeftPoints(options, widthIn, height) {
      var sides = options.sides;

      var _this$getVerticalDefa = this.getVerticalDefaultValues(height, widthIn, options),
          lineWidth = _this$getVerticalDefa.lineWidth,
          width = _this$getVerticalDefa.width,
          tipWidth = _this$getVerticalDefa.tipWidth;

      var outsideRadius = width / 2 + lineWidth / 2;
      var h = outsideRadius - tipWidth;
      var w = outsideRadius - lineWidth; // const w = lineWidth;

      var insideRadius = (Math.pow(w, 2) + Math.pow(h, 2)) / (2 * w);
      var leftPoints = [];
      var rightPoints = [];
      var outsideStep = Math.PI / 2 / sides;
      var insideStep = Math.asin(h / insideRadius) / sides;
      var insidePoints = [];
      var outsidePoints = [];

      for (var i = 0; i < sides + 1; i += 1) {
        var outsideAngle = i * outsideStep;
        var insideAngle = i * insideStep;
        outsidePoints.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](outsideRadius * Math.cos(outsideAngle), outsideRadius * Math.sin(outsideAngle)));
        insidePoints.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](insideRadius * Math.cos(insideAngle) - insideRadius + outsideRadius - lineWidth, insideRadius * Math.sin(insideAngle)));
      } // const topCurveCenter = new Point(width, height - outsideRadius);


      var m = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(-1, 1).translate(width, height - outsideRadius).m();

      for (var _i = 0; _i < sides + 1; _i += 1) {
        leftPoints.push(outsidePoints[sides - _i].transformBy(m));
        rightPoints.push(insidePoints[sides - _i].transformBy(m));
      }

      m = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(1, -1).translate(0, height / 2 - tipWidth / 2 + outsideRadius).m();

      for (var _i2 = 0; _i2 < sides + 1; _i2 += 1) {
        leftPoints.push(insidePoints[_i2].transformBy(m));
        rightPoints.push(outsidePoints[_i2].transformBy(m));
      }

      m = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().translate(0, height / 2 + tipWidth / 2 - outsideRadius).m();

      for (var _i3 = 0; _i3 < sides + 1; _i3 += 1) {
        leftPoints.push(insidePoints[sides - _i3].transformBy(m));
        rightPoints.push(outsidePoints[sides - _i3].transformBy(m));
      }

      m = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(-1, -1).translate(width, outsideRadius).m();

      for (var _i4 = 0; _i4 < sides + 1; _i4 += 1) {
        leftPoints.push(outsidePoints[_i4].transformBy(m));
        rightPoints.push(insidePoints[_i4].transformBy(m));
      } // if (side === 'top' || side === 'bottom') {
      //   return this.getBracketPoints(leftPoints, rightPoints, side, height, width);
      // }


      return [leftPoints, rightPoints, width, height];
    } // Values that look good:
    // height          width         lineWidth
    //   2              0.2           0.04  0.03
    //   1              0.1           0.03  0.02
    //   0.5            0.05          0.015
    //   0.3            0.05          0.015
    //   0.2            0.03          0.012
    // eslint-disable-next-line class-methods-use-this

  }, {
    key: "getVerticalDefaultValues",
    value: function getVerticalDefaultValues(height, width, options) {
      var out = {};

      if (width == null && options.width == null) {
        out.width = 97570.78 + (0.004958708 - 97570.78) / (1 + Math.pow(height / 2399858, 0.9383909));
      }

      if (width != null) {
        out.width = width;
      }

      if (options.width != null) {
        out.width = options.width;
      }

      if (options.lineWidth == null) {
        out.lineWidth = (0.2933614 + (0.0001418178 - 0.2933614) / (1 + Math.pow(height / 39.01413, 0.618041))) * 0.8;
      } else {
        out.lineWidth = options.lineWidth;
      }

      if (options.tipWidth == null) {
        out.tipWidth = out.lineWidth / 3;
      } else {
        out.tipWidth = options.tipWidth;
      }

      return out;
    }
  }]);

  return Brace;
}(_Bracket__WEBPACK_IMPORTED_MODULE_1__["default"]);



/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/Symbols/Bracket.js":
/*!********************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/Symbols/Bracket.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Bracket; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _SymbolNew__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SymbolNew */ "./src/js/diagram/DiagramElements/Equation/Symbols/SymbolNew.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }


 // import Bounds from '../Elements/Bounds';

var Bracket =
/*#__PURE__*/
function (_Symbol2) {
  _inherits(Bracket, _Symbol2);

  function Bracket() {
    _classCallCheck(this, Bracket);

    return _possibleConstructorReturn(this, _getPrototypeOf(Bracket).apply(this, arguments));
  }

  _createClass(Bracket, [{
    key: "getPoints",
    // This is the same math as for Brace, but the outside radius is only a
    // portion of a half circle
    //                             * *
    //                          *  *
    //                        *   *
    //                      *    *
    //                     *    *
    //                     *    *
    //                    *    *
    //                    *    *
    //                    *    *
    //                     *    *
    //                     *    *
    //                      *    *
    //                        *   *
    //                          *  *
    //                            * *
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //                                     0000000
    //                                0000       |
    //                            000         0000
    //                         00          000
    //                       0           00
    //                      00         000
    //                    0           0
    //                   00         00
    //                 00          0
    //                 0           0
    //                 0           0
    //                 0           0
    //
    //
    // eslint-disable-next-line class-methods-use-this
    value: function getPoints(options, widthIn, heightIn) {
      var side = options.side;
      var leftPoints;
      var rightPoints;
      var width;
      var height;

      if (side === 'left' || side === 'right') {
        var _this$getLeftPoints = this.getLeftPoints(options, widthIn, heightIn);

        var _this$getLeftPoints2 = _slicedToArray(_this$getLeftPoints, 4);

        leftPoints = _this$getLeftPoints2[0];
        rightPoints = _this$getLeftPoints2[1];
        width = _this$getLeftPoints2[2];
        height = _this$getLeftPoints2[3];
      } else {
        var _this$getLeftPoints3 = this.getLeftPoints(options, heightIn, widthIn);

        var _this$getLeftPoints4 = _slicedToArray(_this$getLeftPoints3, 4);

        leftPoints = _this$getLeftPoints4[0];
        rightPoints = _this$getLeftPoints4[1];
        width = _this$getLeftPoints4[2];
        height = _this$getLeftPoints4[3];
      } // The points of the glyph are for side 'left' by default
      // Transform the glyph to the correct side and have it's lower left corner
      // at (0, 0) and be


      var t;

      if (side === 'right') {
        t = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(-1, 1).translate(width, 0);
      } else if (side === 'top') {
        t = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().translate(0, -height / 2).rotate(-Math.PI / 2).translate(height / 2, width);
      } else if (side === 'bottom') {
        t = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().translate(0, -height / 2).rotate(Math.PI / 2).translate(height / 2, 0);
      } else {
        t = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();
      }

      var newPointsLeft = leftPoints.map(function (p) {
        return p.transformBy(t.m());
      });
      var newPointsRight = rightPoints.map(function (p) {
        return p.transformBy(t.m());
      });
      var points = [];
      newPointsLeft.forEach(function (r1p, index) {
        var r2p = newPointsRight[index];
        points.push(r1p);
        points.push(r2p);
      });

      if (side === 'top' || side === 'bottom') {
        return [points, height, width];
      }

      return [points, width, height];
    }
  }, {
    key: "getLeftPoints",
    value: function getLeftPoints(options, widthIn, heightIn) {
      var sides = options.sides;

      var _this$getVerticalDefa = this.getVerticalDefaultValues(heightIn, widthIn, options),
          lineWidth = _this$getVerticalDefa.lineWidth,
          width = _this$getVerticalDefa.width,
          tipWidth = _this$getVerticalDefa.tipWidth; // width of bracket without linewidth - essentially width of inner radius


      var wInnerRadius = width - lineWidth;
      var innerRadius = (Math.pow(wInnerRadius, 2) + Math.pow(heightIn / 2, 2)) / (2 * wInnerRadius); // top line width is half middle line width

      var wOuterRadius = width - tipWidth;
      var outerRadius = (Math.pow(wOuterRadius, 2) + Math.pow(heightIn / 2, 2)) / (2 * wOuterRadius);
      var angleInner = Math.asin(heightIn / 2 / innerRadius);
      var stepAngleInner = angleInner * 2 / sides;
      var angleOuter = Math.asin(heightIn / 2 / outerRadius);
      var stepAngleOuter = angleOuter * 2 / sides;
      var innerPoints = [];
      var outerPoints = [];

      for (var i = 0; i < sides + 1; i += 1) {
        innerPoints.push(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(innerRadius, angleInner - stepAngleInner * i + Math.PI).add(innerRadius + lineWidth, heightIn / 2));
        outerPoints.push(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(outerRadius, angleOuter - stepAngleOuter * i + Math.PI).add(outerRadius, heightIn / 2));
      }

      return [outerPoints, innerPoints, innerPoints[0].x, heightIn];
    } // Default values are values of width, height, lineWidth
    // Values that look good:
    // height          width         lineWidth
    //   2              0.2           0.04
    //   1              0.1           0.03
    //   0.5            0.05          0.015
    //   0.3            0.05          0.015
    //   0.2            0.03          0.012

    /* eslint-disable class-methods-use-this */
    // $FlowFixMe

  }, {
    key: "getDefaultValues",
    value: function getDefaultValues(contentHeight, contentWidth, options) {
      var out = {};

      if (options.side === 'left' || options.side === 'right') {
        out = this.getVerticalDefaultValues(contentHeight, contentWidth, options); // $FlowFixMe

        out.height = contentHeight;
      } else {
        out = this.getVerticalDefaultValues(contentWidth, contentHeight, options);
        var _out = out,
            width = _out.width;
        out.width = contentWidth; // $FlowFixMe

        out.height = width;
      }

      return out;
    }
  }, {
    key: "getVerticalDefaultValues",
    value: function getVerticalDefaultValues(contentHeight, contentWidth, options) {
      var out = {};

      if (contentWidth == null && options.width == null) {
        out.width = 97570.78 + (0.004958708 - 97570.78) / (1 + Math.pow(contentHeight / 2399858, 0.9383909));
      }

      if (contentWidth != null) {
        out.width = contentWidth;
      }

      if (options.width != null) {
        out.width = options.width;
      }

      if (options.lineWidth == null) {
        out.lineWidth = 0.2933614 + (0.0001418178 - 0.2933614) / (1 + Math.pow(contentHeight / 39.01413, 0.618041));
      } else {
        out.lineWidth = options.lineWidth;
      }

      if (options.tipWidth == null) {
        out.tipWidth = out.lineWidth / 3;
      } else {
        out.tipWidth = options.tipWidth;
      }

      return out;
    } // getBounds(
    //   options: Object,
    //   leftIn: number,
    //   bottomIn: number,
    //   widthIn: number,
    //   heightIn: number,
    //   side: 'left' | 'right' | 'bottom' | 'top' = 'left',
    // ) {
    //   const { width, height } = this.getDefaultValues(
    //     heightIn, widthIn, options,
    //   );
    //   const bounds = new Bounds();
    //   const glyphWidth = width;
    //   const glyphHeight = height;
    //   // if (options.draw === 'static') {
    //   //   const { staticWidth, staticHeight } = options;
    //   //   if (options.side === 'left' || options.side === 'right') {
    //   //     console.log(widthIn, heightIn, width, height, staticWidth, staticHeight);
    //   //     glyphWidth = height / staticHeight * width / height;
    //   //     // glyphWidth = staticWidth / staticHeight * height;
    //   //   } else {
    //   //     glyphHeight = staticHeight / staticWidth * width;
    //   //   }
    //   // }
    //   // console.log(glyphWidth, glyphHeight)
    //   if (side === 'left') {
    //     bounds.left = leftIn - glyphWidth;
    //     bounds.bottom = bottomIn;
    //     bounds.top = bounds.bottom + glyphHeight;
    //     bounds.right = bounds.left + glyphWidth;
    //   } else if (side === 'right') {
    //     bounds.left = leftIn;
    //     bounds.bottom = bottomIn;
    //     bounds.top = bounds.bottom + glyphHeight;
    //     bounds.right = bounds.left + glyphWidth;
    //   } else if (side === 'top') {
    //     bounds.bottom = bottomIn;
    //     bounds.top = bottomIn + glyphHeight;
    //     bounds.left = leftIn + widthIn / 2 - glyphWidth / 2;
    //     bounds.right = bounds.left + glyphWidth;
    //   } else {
    //     bounds.top = bottomIn;
    //     bounds.bottom = bottomIn - glyphHeight;
    //     bounds.left = leftIn + widthIn / 2 - glyphWidth / 2;
    //     bounds.right = bounds.left + glyphWidth;
    //   }
    //   bounds.width = glyphWidth;
    //   bounds.height = glyphHeight;
    //   bounds.ascent = glyphHeight;
    //   bounds.descent = 0;
    //   return bounds;
    // }

  }]);

  return Bracket;
}(_SymbolNew__WEBPACK_IMPORTED_MODULE_1__["default"]);



/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/Symbols/Integral.js":
/*!*********************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/Symbols/Integral.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Integral; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../tools/math */ "./src/js/tools/math.js");
/* harmony import */ var _SymbolNew__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SymbolNew */ "./src/js/diagram/DiagramElements/Equation/Symbols/SymbolNew.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

 // import {
//   joinObjects,
// } from '../../../../tools/tools';




var Integral =
/*#__PURE__*/
function (_Symbol2) {
  _inherits(Integral, _Symbol2);

  function Integral() {
    _classCallCheck(this, Integral);

    return _possibleConstructorReturn(this, _getPrototypeOf(Integral).apply(this, arguments));
  }

  _createClass(Integral, [{
    key: "getPoints",
    // eslint-disable-next-line class-methods-use-this
    // getTriangles() {
    //   return 'triangles';
    // }
    // eslint-disable-next-line class-methods-use-this
    // getWidth() {
    //   return (options: Object, height: number) => {
    //     let width;
    //     if (options.draw === 'static') {
    //       let { staticHeight } = options;
    //       if (typeof staticHeight !== 'number') {
    //         staticHeight = height;
    //       }
    //       ({ width } = this.getDefaultValues(staticHeight, null, options));
    //       return width / staticHeight * height;
    //     }
    //     ({ width } = options);
    //     ({ width } = this.getDefaultValues(height, width, options));
    //     return width;
    //   };
    // }
    //     --------------------------------------------------   0000000
    //     A                                              000000011111111
    //     |                                         0000000   111111111111
    //     |                                       0000000    11111111111111
    //     |                                      0000000     11111111111111
    //     |                                     0000000       111111111111
    //     |                                   000000000         11111111
    //     |                                  000000000
    //     |                                 0000000000
    //     |    S curve gradient = k         000000000
    //     |                                0000000000
    //     |                                0000000000
    //     |                               00000000000
    //     |                              00000000000
    //     |                              000000000000
    //     |                             000000000000      lineWidth
    //   h |                     ------->000000000000<----------
    //     |                             000000000000
    //     |                             000000000000
    //     |                            000000000000
    //     |                             00000000000
    //     |                            00000000000
    //     |                            0000000000
    //     |                            0000000000
    //     |                            000000000
    //     |                           000000000
    //     |                          0000000000
    //     |      11111111           000000000
    //     |    111111111111       00000000
    //     |   11111111111111     0000000
    //     |   11111111111111   0000000
    //     |    111111111111   0000000
    //     V      111111110000000
    //     -------  0000000
    // Integral line is generated from a sigmoid function (S-curve) that is
    // thickened more in middle than on ends (square of cosine of normalized
    // height)
    //
    // S (sigmoid) Curve:
    //                    h
    //         s(x) = -----------            (1)
    //                       -kx
    //                  1 + e
    //
    // It's derivative is:
    //
    //        ds
    //       ----  =  h k s (1 - s)          (2)
    //        dx
    //
    // The angle theta of the curve at some given x can is then:
    //
    //     theta = atan(ds/dx)               (3)
    //
    //
    // If you know s, x and want to find k, then can rearrange the above to:
    //
    //      k = -ln((h / s) - 1) / x         (4)
    //
    // Procedure:
    //    - Find gradient where s = 0.999999 of the height and x is w / 2
    //    - Make an xRange from w / 2 to w / 2 (with buffer for serif)
    //    - Go through all x and:
    //        - Find y from (1)
    //        - Find the derivative at x using (2) and theta using (3)
    //        - Find the left and right sides of the line using theta + PI / 2
    //          and add more thickness in the middle
    //
    //    - Find serifs by:
    //        - Go to end outside point and find its theta
    //        - Center of serif is then at vector from end point to
    //          theta + /2 with magnitude of serif radius
    //        - Draw circle at serif
    //
    // eslint-disable-next-line class-methods-use-this
    value: function getPoints(options, widthIn, height) {
      var sides = options.sides,
          serif = options.serif,
          num = options.num,
          type = options.type,
          serifSides = options.serifSides,
          lineIntegralSides = options.lineIntegralSides;

      var _this$getDefaultValue = this.getDefaultValues(height, widthIn, options),
          lineWidth = _this$getDefaultValue.lineWidth,
          width = _this$getDefaultValue.width,
          tipWidth = _this$getDefaultValue.tipWidth;

      var singleWidth = width - (num - 1) * lineWidth * 3;
      var percentage = 0.99999999999;
      var h = height;
      var serifRadius = lineWidth * 0.7;
      var widthWithoutSerifs = singleWidth;

      if (serif) {
        widthWithoutSerifs = singleWidth - serifRadius * 2;
      }

      var xArray = Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["range"])(-widthWithoutSerifs / 2, widthWithoutSerifs / 2, widthWithoutSerifs / sides);
      var targetY = percentage * height;
      var k = -Math.log(height / targetY - 1) / singleWidth / 2;
      var bottomTheta = 0;
      var linePoints = [];
      var prevLeft;
      var prevRight;
      xArray.forEach(function (x, index) {
        var sigmoid = 1 / (1 + Math.exp(-k * x));
        var derivative = h * k * sigmoid * (1 - sigmoid);
        var theta = Math.atan(derivative);
        var y = sigmoid * h;
        var a = (lineWidth / 2 - tipWidth / 2) * Math.pow(Math.cos((y - height / 2) / height * Math.PI), 2) + tipWidth / 2;
        var xDelta = a * Math.cos(theta + Math.PI / 2);
        var yDelta = a * Math.sin(theta + Math.PI / 2);
        var left = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](x + xDelta + singleWidth / 2, y + yDelta);
        var right = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](x - xDelta + singleWidth / 2, y - yDelta);

        if (index > 0) {
          linePoints.push(prevLeft._dup());
          linePoints.push(prevRight._dup());
          linePoints.push(right._dup());
          linePoints.push(prevLeft._dup());
          linePoints.push(right._dup());
          linePoints.push(left._dup());
        }

        prevLeft = left;
        prevRight = right;

        if (index === 0) {
          bottomTheta = theta;
        }
      });
      var points = [];

      if (serif === false) {
        points = linePoints;
      } else {
        var serifPoints = serifSides;
        var bottomCenter = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](linePoints[1].x + serifRadius * Math.cos(bottomTheta + Math.PI / 2), linePoints[1].y + serifRadius * Math.sin(bottomTheta + Math.PI / 2));
        var topCenter = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](linePoints[linePoints.length - 1].x + serifRadius * Math.cos(bottomTheta - Math.PI / 2), linePoints[linePoints.length - 1].y + serifRadius * Math.sin(bottomTheta - Math.PI / 2));
        var bottomSerifPoints = [];
        var topSerifPoints = [];
        var angleDelta = Math.PI * 2 / Math.max(serifPoints, 3);
        var prevBottom = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0); // initialied for flow only

        var prevTop = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0); // initialied for flow only

        for (var i = 0; i < serifPoints + 1; i += 1) {
          var bottom = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](bottomCenter.x + serifRadius * Math.cos(angleDelta * i), bottomCenter.y + serifRadius * Math.sin(angleDelta * i));
          var top = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](topCenter.x + serifRadius * Math.cos(angleDelta * i), topCenter.y + serifRadius * Math.sin(angleDelta * i));

          if (i > 0) {
            bottomSerifPoints.push(linePoints[1]._dup());
            bottomSerifPoints.push(prevBottom._dup());
            bottomSerifPoints.push(bottom._dup());
            topSerifPoints.push(linePoints[linePoints.length - 2]._dup());
            topSerifPoints.push(prevTop._dup());
            topSerifPoints.push(top._dup());
          }

          prevBottom = bottom;
          prevTop = top;
        }

        points = [].concat(bottomSerifPoints, linePoints, topSerifPoints);
      }

      var numPoints = points.length;

      for (var _i = 1; _i < num; _i += 1) {
        for (var j = 0; j < numPoints; j += 1) {
          points.push(points[j].add(lineWidth * 3 * _i, 0));
        } // width = width + lineWidth * 2;

      }

      if (type === 'line') {
        var lineIntegralEllipsePoints = this.getLineIntegralPoints(lineWidth, num, width, height, lineIntegralSides);
        points = [].concat(_toConsumableArray(points), _toConsumableArray(lineIntegralEllipsePoints));
      }

      return [points, width, height];
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "getLineIntegralPoints",
    value: function getLineIntegralPoints(lineWidth, num, width, height, sides) {
      var ellipseHeight = lineWidth * 6;
      var ellipseWidth = Math.max(ellipseHeight, (lineWidth * 3 + (num - 1) * lineWidth * 3 / 2) * 2);
      var center = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width / 2, height / 2);
      var deltaAngle = Math.PI * 2 / sides;
      var prevOuter = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      var prevInner = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      var ellipseLineWidth = lineWidth / 2;
      var points = [];

      for (var i = 0; i < sides + 1; i += 1) {
        var angle = i * deltaAngle;
        var inner = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"]((ellipseWidth / 2 - ellipseLineWidth / 2) * Math.cos(angle), (ellipseHeight / 2 - ellipseLineWidth / 2) * Math.sin(angle)).add(center);
        var outer = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"]((ellipseWidth / 2 + ellipseLineWidth / 2) * Math.cos(angle), (ellipseHeight / 2 + ellipseLineWidth / 2) * Math.sin(angle)).add(center);

        if (i > 0) {
          points.push(prevOuter._dup());
          points.push(prevInner._dup());
          points.push(inner._dup());
          points.push(prevOuter._dup());
          points.push(inner._dup());
          points.push(outer._dup());
        }

        prevOuter = outer;
        prevInner = inner;
      }

      return points;
    }
    /* eslint-disable class-methods-use-this */
    // $FlowFixMe

  }, {
    key: "getDefaultValues",
    value: function getDefaultValues(height, width, options) {
      // at 2:
      //    lw = 0.05 (40)
      //     w = 0.4 (5)
      //     e = 0.01 (200)
      //
      // at 1:
      //    lw = 0.03 (33)
      //     w = 0.25 (4)
      //     e = 0.01 (100)
      //
      // at 0.5:
      //    lw = 0.02 (25)
      //     w = 0.15 (3.3)
      //     e = 0.008 (63)
      //
      // at 0.3:
      //    lw = 0.017 (17)
      //     w = 0.15 (2)
      //     e = 0.006 (50)
      //
      // Using https://mycurvefit.com and add 0 to each to keep values under 0.3 positive
      var defaultLineWidth = 607.73 + (0.0004220802 - 607.73) / (1 + Math.pow(height / 5368595, 0.6370402));
      var defaultSingleWidth = 12277.16 + (0.003737719 - 12277.16) / (1 + Math.pow(height / 36507180, 0.6193363));
      var defaultTotalWidth = defaultSingleWidth + (options.num - 1) * defaultLineWidth * 3;
      var out = {
        lineWidth: defaultLineWidth,
        width: defaultTotalWidth,
        tipWidth: 0.01033455 + (0.000004751934 - 0.01033455) / (1 + Math.pow(height / 0.2588074, 2.024942)),
        height: height
      };

      if (width != null) {
        out.width = width;
      }

      if (options.lineWidth != null) {
        out.lineWidth = options.lineWidth;
      }

      if (options.tipWidth != null) {
        out.tipWidth = options.tipWidth;
      } else {
        out.tipWidth = out.lineWidth / 3;
      }

      return out;
    }
  }]);

  return Integral;
}(_SymbolNew__WEBPACK_IMPORTED_MODULE_2__["default"]);



/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/Symbols/Product.js":
/*!********************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/Symbols/Product.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Product; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _SymbolNew__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SymbolNew */ "./src/js/diagram/DiagramElements/Equation/Symbols/SymbolNew.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }


 // import Bounds from '../Elements/Bounds';

var Product =
/*#__PURE__*/
function (_Symbol2) {
  _inherits(Product, _Symbol2);

  function Product() {
    _classCallCheck(this, Product);

    return _possibleConstructorReturn(this, _getPrototypeOf(Product).apply(this, arguments));
  }

  _createClass(Product, [{
    key: "getPoints",
    // eslint-disable-next-line class-methods-use-this
    // getTriangles() {
    //   return 'strip';
    // }
    // eslint-disable-next-line class-methods-use-this
    // getWidth() {
    //   return (options: Object, height: number) => {
    //     // The width should be 7 times the thick2 linewidth;
    //     // const { lineWidth } = options;
    //     let width;
    //     if (options.draw === 'static') {
    //       let { staticHeight } = options;
    //       if (typeof staticHeight !== 'number') {
    //         staticHeight = height;
    //       }
    //       ({ width } = this.getDefaultValues(staticHeight, null, options));
    //       return width / staticHeight * height;
    //     }
    //     ({ width } = options);
    //     ({ width } = this.getDefaultValues(height, width, options));
    //     return width;
    //   };
    // }
    //                                            w
    //             |<--------------------------------------------------------->|
    //             |                                                           |
    //             |   a                                                       |
    //             |<---->|                                                    |
    //             |      |                     thick1                         |
    //             |      |                     /                              |
    //             |      |                    /                               |
    //       ---- 00000000000000000000000000000000000000000000000000000000000000
    //       A         000000000000000000000000000000000000000000000000000000
    //       |           00000000000000000000000000000000000000000000000000
    //       |            00000000000                         00000000000
    //       |            00000000000                         00000000000
    //       |            00000000000                         00000000000
    //       |            00000000000                         00000000000
    //       |            00000000000                         00000000000
    //       |            00000000000                         00000000000
    //       |            00000000000                         00000000000
    //       |            00000000000                         00000000000
    //       |            00000000000   \                 /   00000000000
    //    h  |            00000000000    \              /     00000000000
    //       |            00000000000      \          /       00000000000
    //       |            00000000000        \      /         00000000000
    //       |            00000000000         thick2          00000000000
    //       |            00000000000                         00000000000
    //       |            00000000000                         00000000000
    //       |            00000000000                         00000000000
    //       |            00000000000                         00000000000
    //       |            00000000000                         00000000000
    //       |            00000000000                         00000000000
    //       |            00000000000                         00000000000
    //       |            00000000000                         00000000000
    //       |           0000000000000                       00000000000000
    //       V         00000000000000000                   000000000000000000
    //       ----- 0000000000000000000000000           00000000000000000000000000
    //
    //                         10 0000000000000000000000000 11
    //                          8 0000000000000000000000000 9
    //                                 6 00000000000 7
    //                                   00000000000
    //                                   00000000000
    //                                   00000000000
    //                                   00000000000
    //                                   00000000000
    //                                   00000000000
    //                                   00000000000
    //                                   00000000000
    //                                   00000000000
    //                                   00000000000
    //                                   00000000000
    //                                   00000000000
    //                                   00000000000
    //                                   00000000000
    //                                   00000000000
    //                                   00000000000
    //                                   00000000000
    //                                   00000000000
    //                                   00000000000
    //                                   00000000000
    //                                   00000000000
    //                                 4 00000000000 5
    //                          2 00000000000000000000000000  3
    //                          0 00000000000000000000000000  1
    //                        (0, 0)
    // eslint-disable-next-line class-methods-use-this
    value: function getPoints(options, widthIn, height) {
      var serif = options.serif,
          sides = options.sides;

      var _this$getDefaultValue = this.getDefaultValues(height, widthIn, options),
          lineWidth = _this$getDefaultValue.lineWidth,
          width = _this$getDefaultValue.width;

      var sidesToUse = sides;

      if (serif === 'false') {
        sidesToUse = 2;
      } // const { lineWidth, sides } = options;
      // let lineWidthToUse = lineWidth;
      // if (lineWidth == null) {
      //   // lineWidthToUse = width / (25 * height + 15);
      //   lineWidthToUse = width / 21;
      // }


      var thick1 = lineWidth * 1.2;
      var thick2 = lineWidth * 3;
      var tipWidth = lineWidth / 2;
      var a = thick2 * 0.9;
      var p0 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      var p1 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](thick2 + a * 2, 0);
      var p2 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](p0.x, tipWidth);
      var p3 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](p1.x, tipWidth);
      var p4 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](a, p2.y);
      var p5 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](a + thick2, p4.y);
      var p6 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](p4.x, height - tipWidth);
      var p7 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](p5.x, height - tipWidth);
      var p8 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](p2.x, height - tipWidth); // const p9 = new Point(p3.x, height - tipWidth);

      var p10 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](p2.x, height);
      var p11 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](p3.x, height);
      var p40 = p2;
      var p41 = p4;
      var p42 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](p4.x, p4.y + a);
      var p50 = p3;
      var p51 = p5;
      var p52 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](p5.x, p4.y + a);
      var p4Curve = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["quadBezierPoints"])(p40, p41, p42, sidesToUse);
      var p5Curve = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["quadBezierPoints"])(p50, p51, p52, sidesToUse);
      var bottomCurve = [];
      p4Curve.forEach(function (p, index) {
        bottomCurve.push(p);
        bottomCurve.push(p5Curve[index]);
      });
      var p60 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](p6.x, p6.y - a);
      var p61 = p6;
      var p62 = p8; // const p70 = new Point(p7.x, p7.y - a);
      // const p71 = p7;
      // const p72 = p9;

      var p6Curve = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["quadBezierPoints"])(p60, p61, p62, sidesToUse); // const p7Curve = quadBezierPoints(p70, p71, p72, sides);

      var topCurve = [];
      p6Curve.forEach(function (p) {
        topCurve.push(p); // topCurve.push(p7Curve[index]);

        topCurve.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](p7.x, p.y));
      });
      var leg = [p0, p1].concat(bottomCurve, topCurve, [p10, p11]);
      var leg2 = [];

      for (var i = leg.length - 1; i > 0; i -= 2) {
        leg2.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width - leg[i - 1].x, leg[i - 1].y));
        leg2.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width - leg[i].x, leg[i].y));
      }

      var transition = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](a + thick2, height), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](a + thick2, height - thick1), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width - a - thick2, height), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width - a - thick2, height - thick1)];
      var points = [].concat(_toConsumableArray(leg), transition, leg2);
      return [points, width, height];
    } // Linewidths that look good:
    // height          width         lineWidth
    //   2              1.6            0.05
    //   1              0.8            0.025
    //   0.5            0.4            0.012
    //   0.3            0.25           0.009
    //   0.2            0.2           0.008

    /* eslint-disable class-methods-use-this */
    // $FlowFixMe

  }, {
    key: "getDefaultValues",
    value: function getDefaultValues(height, width, options) {
      var out = {
        lineWidth: options.lineWidth || 1,
        // height * 0.93 / (25 * height + 15),
        width: width || 1,
        height: height
      };

      if (options.lineWidth == null && width != null) {
        out.lineWidth = width / 7 / 3;
      } else if (options.lineWidth == null && width == null) {
        // out.lineWidth = height * 0.93 / (25 * height + 15);
        out.lineWidth = 12902.65 + (0.001053004 - 12902.65) / (1 + Math.pow(height / 573148, 0.9938213));
        out.width = 1704804 + (0.002184303 - 1704804) / (1 + Math.pow(height / 2234236, 0.9967453));
      } else if (options.lineWidth != null && width == null) {
        out.width = options.lineWidth * 7 * 3;
      }

      return out;
    }
  }]);

  return Product;
}(_SymbolNew__WEBPACK_IMPORTED_MODULE_1__["default"]);



/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/Symbols/Radical.js":
/*!********************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/Symbols/Radical.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Radical; });
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _SymbolNew__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SymbolNew */ "./src/js/diagram/DiagramElements/Equation/Symbols/SymbolNew.js");
/* harmony import */ var _Elements_Bounds__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Elements/Bounds */ "./src/js/diagram/DiagramElements/Equation/Elements/Bounds.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }




 // import WebGLInstance from '../../../webgl/webgl';

var Radical =
/*#__PURE__*/
function (_Symbol2) {
  _inherits(Radical, _Symbol2);

  function Radical() {
    _classCallCheck(this, Radical);

    return _possibleConstructorReturn(this, _getPrototypeOf(Radical).apply(this, arguments));
  }

  _createClass(Radical, [{
    key: "getPoints",
    // eslint-disable-next-line class-methods-use-this
    // getTriangles() {
    //   return 'strip';
    // }
    //   height                      left space                right space
    //   |                             >|--|<                    >|--|<
    //   |                              |  |                      |  |
    //   |                              |  |                      |  |
    //   |_____________________________ XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX____V
    //   A                             X|  |                      |_______|
    //   |   startHeight              X |   CCCCCCCCCCCCCCCCCCCCCCC       A
    //   |   |                       X  |   CCCCCCCCCCCCCCCCCCCCCCC    top space
    //   |   |    tickHeight        X   |   CCCCCCCCCCCCCCCCCCCCCCC
    //   |   |    |                X    |   CCCCCCCCCCCCCCCCCCCCCCC
    //   |   |____V____           X     |   CCCCCCCCCCCCCCCCCCCCCCC
    //   |   A    |    X         X      |   CCCCCCCCCCCCCCCCCCCCCCC
    //   |   |    |__X |X       X       |   CCCCCCCCCCCCCCCCCCCCCCC
    //   |   |    A |  | X     X        |   CCCCCCCCCCCCCCCCCCCCCCC
    //   |   |      |  |  X   X         |   CCCCCCCCCCCCCCCCCCCCCCC   bottom space
    //   |   |      |  |   X X          |   CCCCCCCCCCCCCCCCCCCCCCC_______V
    //   V___V______|__|____X __________|_________________________________|
    //              |  |    |           |                                 A
    //              |  |    |           |
    //        tick >|--|<   |           |
    //       width  |  |    |           |
    //              |  |<-->|down width |
    //              |                   |
    //              |<------------------|
    //                     startWidth
    //
    //
    //
    //  First define bottom line (B), then offset the lines and find intercepts to
    //  get the top line (T)
    //         RRRRRRRRRRRRRRRR                  7                          9
    //         RRRRRRRRRRRRRRRR                    TTTTTTTTTTTTTTTTTTTTTTTTT
    //         RRRRRRRRRRRRRRRR                   T  BBBBBBBBBBBBBBBBBBBBBBB
    //         RRRRRRRRRRRRRRRR                  T  B 6                     8
    //         RRRRRRRRRRRRRRRR                 T  B
    //         RRRRRRRRRRRRRRRR                T  B
    //         RRRRRRRRRRRRRRRR               T  B
    //                        |              T  B
    //                        |             T  B
    //            3           |            T  B
    //            T           |           T  B
    //           T T          |          T  B
    //          T   T   lineWidth2      T  B\
    //         T     T       /|        T  B  \
    //        T  B    T    /  |       T  B    \
    //       T  B B    T /    |      T  B      lineWidth
    //    1 T  B 2 B    T     |     T  B
    //        B     B    T    |    T  B
    //        0      B    T   |   T  B
    //                B    T  |  T  B
    //                 B    T 5 T  B
    //                  B    T T  B
    //                   B    T  B
    //                    B     B
    //                     B   B
    //                      B B
    //                       B
    //                       4
    //
    // Root aligns with downWidth + tickWidth
    //
    // eslint-disable-next-line class-methods-use-this
    value: function getPoints(options, widthIn, heightIn) {
      // const { proportionalToHeight } = options;
      var _this$getDefaultValue = this.getDefaultValues(heightIn, widthIn, options),
          lineWidth = _this$getDefaultValue.lineWidth,
          startWidth = _this$getDefaultValue.startWidth,
          tickWidth = _this$getDefaultValue.tickWidth,
          tickHeight = _this$getDefaultValue.tickHeight,
          downWidth = _this$getDefaultValue.downWidth,
          startHeight = _this$getDefaultValue.startHeight,
          lineWidth2 = _this$getDefaultValue.lineWidth2,
          height = _this$getDefaultValue.height,
          width = _this$getDefaultValue.width;

      var p0 = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, startHeight - tickHeight);
      var p2 = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](tickWidth, startHeight);
      var p4 = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](downWidth + tickWidth, 0);
      var p6 = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](startWidth, height - lineWidth);
      var p8 = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](width, height - lineWidth);
      var line02 = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Line"](p0, p2);
      var line24 = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Line"](p2, p4);
      var line46 = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Line"](p4, p6);
      var line68 = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Line"](p6, p8);
      var line02Offset = line02.offset('top', lineWidth);
      var line24Offset = line24.offset('top', lineWidth2);
      var line46Offset = line46.offset('top', lineWidth);
      var line68Offset = line68.offset('top', lineWidth);

      var p1 = line02Offset.p1._dup();

      var p3 = line02Offset.intersectsWith(line24Offset).intersect;
      var p5 = line24Offset.intersectsWith(line46Offset).intersect;
      var p7 = line46Offset.intersectsWith(line68Offset).intersect;
      var p9 = p8.add(0, lineWidth);
      var points = [p0, p1, p2, p3, p4, p5, p6, p7, p8, p9];
      return [points, widthIn, heightIn];
    } // Get Glyph bounds based on content

    /* eslint-disable class-methods-use-this */

  }, {
    key: "getBounds",
    value: function getBounds(options, contentX, contentY, contentWidthIn, contentHeightIn) {
      // $FlowFixMe
      var height = this.getHeightFromContentHeight(contentHeightIn, options);

      var _this$getDefaultValue2 = this.getDefaultValues( // $FlowFixMe
      height, contentWidthIn, options),
          width = _this$getDefaultValue2.width,
          startWidth = _this$getDefaultValue2.startWidth,
          lineWidth = _this$getDefaultValue2.lineWidth,
          startHeight = _this$getDefaultValue2.startHeight,
          downWidth = _this$getDefaultValue2.downWidth,
          tickWidth = _this$getDefaultValue2.tickWidth,
          lineWidth2 = _this$getDefaultValue2.lineWidth2;

      var bounds = new _Elements_Bounds__WEBPACK_IMPORTED_MODULE_3__["default"]();

      if (options.draw === 'static') {
        var staticWidth = options.staticWidth,
            staticHeight = options.staticHeight;

        if (staticWidth === 'first') {
          staticWidth = width + startWidth;
        }

        if (staticHeight === 'first') {
          staticHeight = height + lineWidth;
        }

        if (staticWidth == null) {
          staticWidth = 1;
        }

        if (staticHeight == null) {
          staticHeight = 1;
        }

        var heightLineWidthRatio = lineWidth / staticHeight;
        var widthStartWidthRatio = startWidth / staticWidth;
        var heightStartHeightRatio = startHeight / staticHeight;
        bounds.width = width / (1 - widthStartWidthRatio);
        bounds.height = height / (1 - heightLineWidthRatio);
        var widthStartWidth = bounds.width * widthStartWidthRatio;
        var heightStartHeight = bounds.height * heightStartHeightRatio;
        var heightLineWidth = bounds.height * heightLineWidthRatio;
        bounds.left = contentX - widthStartWidth;
        bounds.right = bounds.left + bounds.width;
        bounds.bottom = contentY;
        bounds.top = bounds.bottom + bounds.height;
        bounds.ascent = bounds.height;
        bounds.descent = 0; // $FlowFixMe

        bounds.annotations = {
          root: {
            xPosition: 'left',
            yPosition: 'bottom',
            xAlign: 'right',
            yAlign: 'bottom',
            offset: new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](widthStartWidth * 0.5, heightStartHeight + heightLineWidth * 2)
          }
        };
      } else {
        bounds.left = contentX + contentWidthIn / 2 - width / 2 - startWidth;
        bounds.bottom = contentY;
        bounds.width = width + startWidth;
        bounds.height = height;
        bounds.right = bounds.left + bounds.width;
        bounds.top = bounds.bottom + bounds.height;
        bounds.descent = 0;
        bounds.ascent = bounds.height; // $FlowFixMe

        bounds.annotations = {
          root: {
            xPosition: 'left',
            yPosition: 'bottom',
            xAlign: 'right',
            yAlign: 'bottom',
            offset: new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](downWidth + tickWidth, startHeight + lineWidth2)
          }
        };
      }

      return bounds;
    }
    /* eslint-disable class-methods-use-this */

  }, {
    key: "getHeightFromContentHeight",
    value: function getHeightFromContentHeight(contentHeightIn, options) {
      var lineWidth;
      var contentHeight;

      if (options.lineWidth != null && typeof options.lineWidth === 'number') {
        lineWidth = options.lineWidth;
      } else {
        lineWidth = 0.01;
      }

      if (contentHeightIn != null) {
        contentHeight = contentHeightIn;
      } else {
        contentHeight = 1;
      }

      return contentHeight + lineWidth;
    }
    /* eslint-disable class-methods-use-this */
    // $FlowFixMe

  }, {
    key: "getDefaultValues",
    value: function getDefaultValues(height, width, options) {
      var out = {};

      if (options.lineWidth != null && typeof options.lineWidth === 'number') {
        out.lineWidth = options.lineWidth;
      } else {
        out.lineWidth = 0.01;
      }

      if (options.lineWidth2 != null && typeof options.lineWidth2 === 'number') {
        out.lineWidth2 = options.lineWidth2;
      } else {
        out.lineWidth2 = out.lineWidth * 2;
      }

      if (options.height != null && typeof options.height === 'number') {
        out.height = options.height;
      } else if (height != null) {
        out.height = height;
      } else {
        out.height = 1;
      }

      if (options.startHeight != null && typeof options.startHeight === 'number') {
        out.startHeight = options.startHeight;

        if (options.proportionalToHeight) {
          // $FlowFixMe
          out.startHeight = options.startHeight * out.height;
        }
      } else {
        out.startHeight = out.height / 3;
      }

      if (options.maxStartHeight != null && options.maxStartHeight < out.startHeight) {
        out.startHeight = options.maxStartHeight;
      }

      if (options.tickHeight != null && typeof options.tickHeight === 'number') {
        out.tickHeight = options.tickHeight;

        if (options.proportionalToHeight) {
          // $FlowFixMe
          out.tickHeight = options.tickHeight * out.startHeight;
        }
      } else {
        out.tickHeight = out.startHeight * 0.1;
      }

      if (options.startWidth != null && typeof options.startWidth === 'number') {
        out.startWidth = options.startWidth;

        if (options.proportionalToHeight) {
          // $FlowFixMe
          out.startWidth = options.startWidth * out.height;
        }
      } else {
        out.startWidth = out.startHeight / 2;
      }

      if (options.maxStartWidth != null && options.maxStartWidth < out.startWidth) {
        out.startWidth = options.maxStartWidth;
      }

      if (options.tickWidth != null && typeof options.tickWidth === 'number') {
        out.tickWidth = options.tickWidth;

        if (options.proportionalToHeight) {
          // $FlowFixMe
          out.tickWidth = options.tickWidth * out.startWidth;
        }
      } else {
        out.tickWidth = out.startWidth / 5;
      }

      if (options.downWidth != null && typeof options.downWidth === 'number') {
        out.downWidth = options.downWidth;

        if (options.proportionalToHeight) {
          // $FlowFixMe
          out.downWidth = options.downWidth * out.startWidth;
        }
      } else {
        out.downWidth = out.startWidth / 5 * 2;
      }

      if (options.width != null && typeof options.width === 'number') {
        out.width = options.width;
      } else if (width != null) {
        out.width = width;
      } else {
        out.width = 1;
      }

      return out;
    }
  }]);

  return Radical;
}(_SymbolNew__WEBPACK_IMPORTED_MODULE_2__["default"]);



/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/Symbols/SquareBracket.js":
/*!**************************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/Symbols/SquareBracket.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SquareBracket; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _Bracket__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bracket */ "./src/js/diagram/DiagramElements/Equation/Symbols/Bracket.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }




var SquareBracket =
/*#__PURE__*/
function (_Bracket) {
  _inherits(SquareBracket, _Bracket);

  function SquareBracket() {
    _classCallCheck(this, SquareBracket);

    return _possibleConstructorReturn(this, _getPrototypeOf(SquareBracket).apply(this, arguments));
  }

  _createClass(SquareBracket, [{
    key: "getLeftPoints",
    // eslint-disable-next-line class-methods-use-this
    // getWidth() {
    //   return (type: 'static' | 'dynamic', options: Object, height: number) => {
    //     const { width } = options;
    //     if (type === 'static') {
    //       return height * width;
    //     }
    //     return width;
    //   };
    // }
    //                            width
    //                  |<--------------------->|
    //
    //            ___   ._______________________    ____
    //           A      |                       |      A
    //           |      |                       |      | tipWidth
    //           |      |      .________________|   ___V
    //           |      |      |
    //           |      |      |
    //           |      |      |
    //           |      |      |
    //  height   |      |      |
    //           |      |      |
    //           |      |      |
    //           |      |      |
    //           |      |      |
    //           |      |      |________________
    //           |      |                       |
    //           |      |                       |
    //           V___   |_______________________|
    //
    //                  |      |
    //                  |      |
    //                  |<---->|
    //                 line width
    //
    // If radius is defined, then lineEndWidth = lineWidth
    //
    // eslint-disable-next-line class-methods-use-this
    value: function getLeftPoints(options, widthIn, height) {
      // const {
      //   lineWidth, width, endLineWidth, radius, sides,
      // } = options;
      var sides = options.sides,
          radius = options.radius;

      var _this$getVerticalDefa = this.getVerticalDefaultValues(height, widthIn, options),
          lineWidth = _this$getVerticalDefa.lineWidth,
          width = _this$getVerticalDefa.width,
          tipWidth = _this$getVerticalDefa.tipWidth;

      if (radius === 0) {
        var _outsidePoints = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, height), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width, height)];
        var _insidePoints = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width, tipWidth), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](lineWidth, tipWidth), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](lineWidth, height - tipWidth), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width, height - tipWidth)];
        return [_outsidePoints, _insidePoints, width, height];
      }

      var radiusToUse = Math.min(radius, width, height / 2);
      var rOutside = radiusToUse;
      var rInside = radiusToUse - lineWidth;
      var outsidePoints = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width, 0)];
      var insidePoints = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width, lineWidth)];
      var lowCenter = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](rOutside, rOutside);
      var highCenter = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](rOutside, height - rOutside);

      for (var i = 0; i <= sides; i += 1) {
        var angle = Math.PI / 2 / sides * i;
        outsidePoints.push(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(rOutside, Math.PI / 2 * 3 - angle).add(lowCenter));
        insidePoints.push(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(rInside, Math.PI / 2 * 3 - angle).add(lowCenter));
      }

      for (var _i = 0; _i <= sides; _i += 1) {
        var _angle = Math.PI / 2 / sides * _i;

        outsidePoints.push(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(rOutside, Math.PI - _angle).add(highCenter));
        insidePoints.push(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(rInside, Math.PI - _angle).add(highCenter));
      }

      outsidePoints.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width, height));
      insidePoints.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width, height - lineWidth)); // if (side === 'top' || side === 'bottom') {
      //   return this.getBracketPoints(outsidePoints, insidePoints, side, height, width);
      // }

      return [outsidePoints, insidePoints, width, height];
    }
    /* eslint-disable class-methods-use-this */

  }, {
    key: "getVerticalDefaultValues",
    value: function getVerticalDefaultValues(height, width, options) {
      var out = {};

      if (width == null && options.width == null) {
        out.width = (97570.78 + (0.004958708 - 97570.78) / (1 + Math.pow(height / 2399858, 0.9383909))) * 0.8;
      }

      if (width != null) {
        out.width = width;
      }

      if (options.width != null) {
        out.width = options.width;
      }

      if (options.lineWidth == null) {
        out.lineWidth = (0.2933614 + (0.0001418178 - 0.2933614) / (1 + Math.pow(height / 39.01413, 0.618041))) * 0.8;
      } else {
        out.lineWidth = options.lineWidth;
      }

      if (options.tipWidth == null) {
        out.tipWidth = out.lineWidth * 0.7;
      } else {
        out.tipWidth = options.tipWidth;
      }

      return out;
    }
  }]);

  return SquareBracket;
}(_Bracket__WEBPACK_IMPORTED_MODULE_1__["default"]);



/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/Symbols/Strike.js":
/*!*******************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/Symbols/Strike.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Strike; });
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _SymbolNew__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SymbolNew */ "./src/js/diagram/DiagramElements/Equation/Symbols/SymbolNew.js");
/* harmony import */ var _Elements_Bounds__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Elements/Bounds */ "./src/js/diagram/DiagramElements/Equation/Elements/Bounds.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }




 // import WebGLInstance from '../../../webgl/webgl';

var Strike =
/*#__PURE__*/
function (_Symbol2) {
  _inherits(Strike, _Symbol2);

  function Strike() {
    _classCallCheck(this, Strike);

    return _possibleConstructorReturn(this, _getPrototypeOf(Strike).apply(this, arguments));
  }

  _createClass(Strike, [{
    key: "getPoints",
    // eslint-disable-next-line class-methods-use-this
    // getTriangles() {
    //   return 'strip';
    // }
    //                             X Strike
    //               2    3                  4      5
    //             --- 000                     000
    //             A     000                 000
    //             |       000             000
    //             |         000         000
    //             |           000     000
    //             |             000 000
    //     height  |               000
    //             |             000 000
    //             |           000     000
    //             |         000         000
    //             |       000             000
    //             V     000                 000
    //             --- 000                     000
    //               0 |   1                 6   |  7
    //                 |                         |
    //                 |<----------------------->|
    //                           width
    //
    //
    //                          Forward Strike
    //
    //                                         000
    //                                       000
    //                                     000
    //                                   000
    //                                 000
    //                               000
    //                             000
    //                           000
    //                         000
    //                       000
    //                     000
    //                   000
    //                 000
    //                          Back Strike
    //                 000
    //                   000
    //                     000
    //                       000
    //                         000
    //                           000
    //                             000
    //                               000
    //                                 000
    //                                   000
    //                                     000
    //                                       000
    //                                         000
    //                1      Horizontal Strike     3
    //                 000000000000000000000000000
    //                 000000000000000000000000000
    //                0                            2
    //
    //              |
    //              |           \      00000000000000
    //              |             \  00000000000000
    //              |              00000000000000
    //              |            00000000000000
    //              |          00000000000000
    //              |        00000000000000
    //              |      00000000000000  \
    //              |    00000000000000      \ LineWidth
    //              |  00000000000000   o
    //           -- |00000000000000       o   theta
    //           A  |  0000000000          o
    //         b |  |    000000             o
    //           V  |    g 00               o
    //           --- -------------------------------
    //              |       |
    //              |<----->|
    //                  a
    //
    // theta = atan(height / width)
    //
    // angle g = 180 - theta - 90
    // b = lineWidth * sin(g)
    // a = lineWidth * cos(g)
    // eslint-disable-next-line class-methods-use-this
    value: function getPoints(options, widthIn, heightIn) {
      var style = options.style;

      var _this$getDefaultValue = this.getDefaultValues(heightIn, widthIn, options),
          lineWidth = _this$getDefaultValue.lineWidth,
          width = _this$getDefaultValue.width,
          height = _this$getDefaultValue.height;

      var points;
      var theta = Math.atan2(height, width);
      var g = Math.PI / 2 - theta;
      var a = lineWidth * Math.cos(g);
      var b = lineWidth * Math.sin(g);
      var p0 = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, b);
      var p1 = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](a, 0);
      var p2 = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, height - b);
      var p3 = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](a, height);
      var p4 = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](width - a, height);
      var p5 = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](width, height - b);
      var p6 = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](width - a, 0);
      var p7 = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](width, b);
      var h0 = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, height / 2 - lineWidth / 2);
      var h1 = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, height / 2 + lineWidth / 2);
      var h2 = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](width, height / 2 - lineWidth / 2);
      var h3 = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](width, height / 2 + lineWidth / 2);

      if (style === 'forward') {
        points = [p0, p1, p5, p0, p5, p4];
      } else if (style === 'back') {
        points = [p2, p3, p7, p2, p7, p6];
      } else if (style === 'cross') {
        points = [p0, p1, p5, p0, p5, p4, p2, p3, p7, p2, p7, p6];
      } else {
        points = [h0, h2, h3, h0, h3, h1];
      }

      return [points, width, height];
    }
    /* eslint-disable class-methods-use-this */

  }, {
    key: "getBounds",
    value: function getBounds(options, leftIn, bottomIn, widthIn, heightIn) {
      var _this$getDefaultValue2 = this.getDefaultValues(heightIn, widthIn, options),
          width = _this$getDefaultValue2.width,
          height = _this$getDefaultValue2.height;

      var bounds = new _Elements_Bounds__WEBPACK_IMPORTED_MODULE_3__["default"]();
      bounds.left = leftIn;
      bounds.bottom = bottomIn;
      bounds.width = width;
      bounds.height = height;
      bounds.right = bounds.left + bounds.width;
      bounds.top = bounds.bottom + bounds.height;
      bounds.descent = 0;
      bounds.ascent = bounds.height;
      return bounds;
    }
    /* eslint-disable class-methods-use-this */
    // $FlowFixMe

  }, {
    key: "getDefaultValues",
    value: function getDefaultValues(height, width, options) {
      var out = {};

      if (options.lineWidth != null && typeof options.lineWidth === 'number') {
        out.lineWidth = options.lineWidth;
      } else {
        out.lineWidth = 0.015;
      }

      if (options.height != null && typeof options.height === 'number') {
        out.height = options.height;
      } else if (height != null) {
        out.height = height;
      } else {
        out.height = 1;
      }

      if (options.width != null && typeof options.width === 'number') {
        out.width = options.width;
      } else if (width != null) {
        out.width = width;
      } else {
        out.width = 1;
      }

      return out;
    }
  }]);

  return Strike;
}(_SymbolNew__WEBPACK_IMPORTED_MODULE_2__["default"]);



/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/Symbols/Sum.js":
/*!****************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/Symbols/Sum.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Sum; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _SymbolNew__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SymbolNew */ "./src/js/diagram/DiagramElements/Equation/Symbols/SymbolNew.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }


 // import Bounds from '../Elements/Bounds';

var Sum =
/*#__PURE__*/
function (_Symbol2) {
  _inherits(Sum, _Symbol2);

  function Sum() {
    _classCallCheck(this, Sum);

    return _possibleConstructorReturn(this, _getPrototypeOf(Sum).apply(this, arguments));
  }

  _createClass(Sum, [{
    key: "getPoints",
    // eslint-disable-next-line class-methods-use-this
    // getTriangles() {
    //   return 'strip';
    // }
    // // eslint-disable-next-line class-methods-use-this
    // getWidth() {
    //   return (type: 'static' | 'dynamic', options: Object, height: number) => {
    //     const { width } = options;
    //     if (type === 'static') {
    //       return height * width;
    //     }
    //     return width;
    //   };
    // }
    // eslint-disable-next-line class-methods-use-this
    // getWidth() {
    //   return (options: Object, height: number) => {
    //     let width;
    //     if (options.draw === 'static') {
    //       let { staticHeight } = options;
    //       if (typeof staticHeight !== 'number') {
    //         staticHeight = height;
    //       }
    //       ({ width } = this.getDefaultValues(staticHeight, null, options));
    //       return width / staticHeight * height;
    //     }
    //     ({ width } = options);
    //     ({ width } = this.getDefaultValues(height, width, options));
    //     return width;
    //   };
    // }
    //                   8                                    10
    //          ---------- 00000000000000000000000000000000000_______________
    //          A            0000000 9         \      11 000000           *
    //          |              0000000          \           000           *
    //          |                0000000         thick2       00  12     *
    //          |                  0000000  D             13    \       * tipAngle
    //          |                    0000000                     \    *
    //          |                  B   0000000       thick1        \*
    //          |                        0000000    /
    //          |                          0000000 /
    //          |                            0000000
    //          |                              0000000
    //          |                                000000  -- 7
    //          |      -------------------------6  000
    //          |      A                         00|0
    //       h  |      |                       0000|
    //          |      |                     0000  |\
    //          |      |                   0000    | \
    //          |      | e               0000      |  thick2
    //          |      |               0000  C     |
    //          |      |         A   0000          |             0
    //          |      |           0000            |         1   |____
    //          |      |         0000       thick3 |           00    A
    //          |      |       0000        /       |      3  000|    |
    //          |      |     0000  5      /        |      000000|    |  c
    //          V      V   000000000000000000000000|00000000000 |    |
    //          --------  0000000000000000000000000|0000000000__|____V
    //                 4 |                         |        2|  |
    //                   |                         |         |  |
    //                   |                         |         |  |
    //                   |<----------------------->|         |  |
    //                   |           a                       |  |
    //                   |                                   |  |
    //                   |                                   |  |  b
    //                   |                              ---->|  |<---
    //                   |                                      |
    //                   |                                      |
    //                   |                  w                   |
    //                   |<------------------------------------>|
    //
    // Linewidths that look good:
    // height = 0.2, linewWidth = width / 20
    // height = 0.6, linewWidth = width / 30
    // height = 1, linewWidth = width / 40
    // height = 1.4, linewWidth = width / 50
    // height = 1.8, linewWidth = width / 60
    // Therefore default lineWidth =  width / (25 * height + 15)
    // eslint-disable-next-line class-methods-use-this
    value: function getPoints(options, widthIn, height) {
      var sides = options.sides; // let lineWidthToUse = lineWidth;

      var _this$getDefaultValue = this.getDefaultValues(height, widthIn, options),
          lineWidth = _this$getDefaultValue.lineWidth,
          width = _this$getDefaultValue.width; // if (lineWidth == null) {
      //   lineWidthToUse = width / (25 * height + 15);
      // }


      var bottomTipAngle = Math.PI / 2 * 0.9;
      var topTipAngle = Math.PI / 2 * 0.95;
      var a = 0.431 * width;
      var e = height / 2 - lineWidth;
      var cBottom = 0.176 * height;
      var cTop = 0.153 * height;
      var bBottom = cBottom / Math.tan(bottomTipAngle);
      var bTop = cTop / Math.tan(topTipAngle);
      var thick2 = lineWidth;
      var thick3 = lineWidth * 2;
      var thick1 = lineWidth * 3;
      var tipWidth = lineWidth * 0.6;
      var lineA = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](a, e));
      var CxOffset = thick2 / Math.sin(lineA.ang);
      var lineC = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](CxOffset, 0), height, lineA.ang);
      var lineB = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, height), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](a, e));
      var DxOffset = -thick1 / Math.sin(lineB.ang);
      var lineD = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](DxOffset, height), height, lineB.ang);
      var intersection = lineC.intersectsWith(lineD).intersect;
      var p0 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width, cBottom);
      var p1 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width - tipWidth, cBottom);
      var p2 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width - bBottom, 0);
      var p3 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](p1.x - (cBottom - thick3) / Math.tan(bottomTipAngle), thick3);
      var p4 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      var p5 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](thick2 / Math.sin(lineA.ang) + thick3 / Math.tan(lineA.ang), thick3);
      var p6 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](a, e);
      var p7 = intersection;
      var p8 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, height);
      var p9 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-thick1 / Math.sin(lineB.ang) - thick2 / Math.tan(lineB.ang), height - thick2);
      var p10 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width - bTop, height);
      var p12 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width, height - cTop);
      var p13 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width - tipWidth, height - cTop);
      var p11 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](p13.x - (cTop - thick2) / Math.tan(topTipAngle), height - thick2);
      var p30 = p1;
      var p31 = p3;
      var p32 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](p31.x - (cBottom - thick3), thick3);
      var bottomCurve = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["quadBezierPoints"])(p30, p31, p32, sides);
      var bottomCurvePairs = [];
      bottomCurve.forEach(function (p) {
        bottomCurvePairs.push(p2);
        bottomCurvePairs.push(p);
      });
      var p111 = p11;
      var p110 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](p111.x - cTop + thick2, height - thick2);
      var p112 = p13;
      var topCurve = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["quadBezierPoints"])(p110, p111, p112, sides);
      var topCurvePairs = [];
      topCurve.forEach(function (p) {
        topCurvePairs.push(p10);
        topCurvePairs.push(p);
      });
      var points = [p0, p1].concat(bottomCurvePairs, [p4, p5, p6, p7, p8, p9], topCurvePairs, [p12, p13]);
      return [points, width, height];
    }
    /* eslint-disable class-methods-use-this */
    // $FlowFixMe

  }, {
    key: "getDefaultValues",
    value: function getDefaultValues(height, width, options) {
      var out = {
        lineWidth: height * 0.88 / (25 * height + 15),
        width: height * 0.88,
        height: height
      };

      if (options.lineWidth != null) {
        out.lineWidth = options.lineWidth;
      }

      if (options.width != null) {
        out.width = options.width;
      }

      return out;
    } // getBounds(options: Object,
    //   leftIn: number,
    //   bottomIn: number,
    //   widthIn: number,
    //   heightIn: number,
    // ) {
    //   const { width, height } = this.getDefaultValues(
    //     heightIn, widthIn, options,
    //   );
    //   const bounds = new Bounds();
    //   bounds.left = leftIn - width;
    //   bounds.bottom = bottomIn;
    //   bounds.width = width;
    //   bounds.right = bounds.left + width;
    //   bounds.ascent = height;
    //   bounds.descent = 0;
    //   bounds.height = height;
    //   bounds.top = bounds.bottom + bounds.height;
    //   return bounds;
    // }

  }]);

  return Sum;
}(_SymbolNew__WEBPACK_IMPORTED_MODULE_1__["default"]);



/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/Symbols/SymbolNew.js":
/*!**********************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/Symbols/SymbolNew.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _Symbol; });
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _VertexSymbol__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VertexSymbol */ "./src/js/diagram/DiagramElements/Equation/Symbols/VertexSymbol.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _Elements_Bounds__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Elements/Bounds */ "./src/js/diagram/DiagramElements/Equation/Elements/Bounds.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }







var _Symbol =
/*#__PURE__*/
function (_DiagramElementPrimit) {
  _inherits(_Symbol, _DiagramElementPrimit);

  function _Symbol(webgl, color, transformOrLocation, diagramLimits, symbolOptions, triangles) {
    var _this;

    _classCallCheck(this, _Symbol);

    var vertexObject = new _VertexSymbol__WEBPACK_IMPORTED_MODULE_2__["default"](webgl, triangles);
    var initialT;

    if (transformOrLocation instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Transform"]) {
      initialT = transformOrLocation;
    } else {
      initialT = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Transform"]('Symbol').scale(1, 1).translate(0, 0);
    }

    _this = _possibleConstructorReturn(this, _getPrototypeOf(_Symbol).call(this, vertexObject, initialT, color, diagramLimits));
    _this.custom.options = symbolOptions;

    if (_this.custom.options.draw === 'dynamic') {
      _this.custom.scale = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](1, 1);

      _this.internalSetTransformCallback = function () {
        var s = _this.getScale();

        if (_this.custom.scale.isNotEqualTo(s, 8)) {
          var _this$getPoints = _this.getPoints(_this.custom.options, s.x, s.y),
              _this$getPoints2 = _slicedToArray(_this$getPoints, 3),
              pointsNew = _this$getPoints2[0],
              widthNew = _this$getPoints2[1],
              heightNew = _this$getPoints2[2]; // $FlowFixMe


          _this.drawingObject.updatePoints(pointsNew, widthNew, heightNew);

          _this.custom.scale = s;
        }
      };
    } // eslint-disable-next-line max-len


    _this.custom.setSize = function (location, widthIn, heightIn) {
      var t = _this.transform._dup();

      if (_this.custom.options.draw === 'static' // && this.drawingObject.points.length === 0
      ) {
          var points;
          var width = 0;
          var height = 0;

          if (_this.custom.options.staticHeight === 'first' || _this.custom.options.staticWidth === 'first') {
            var _this$getPoints3 = _this.getPoints(symbolOptions, widthIn, heightIn);

            var _this$getPoints4 = _slicedToArray(_this$getPoints3, 3);

            points = _this$getPoints4[0];
            width = _this$getPoints4[1];
            height = _this$getPoints4[2];
          } else if (_this.custom.options.staticHeight != null || _this.custom.options.staticWidth != null) {
            var _this$getPoints5 = _this.getPoints(symbolOptions, _this.custom.options.staticWidth, _this.custom.options.staticHeight);

            var _this$getPoints6 = _slicedToArray(_this$getPoints5, 3);

            points = _this$getPoints6[0];
            width = _this$getPoints6[1];
            height = _this$getPoints6[2];
          } // $FlowFixMe


          _this.drawingObject.updatePoints(points, width, height);

          _this.custom.options.staticHeight = height;
          _this.custom.options.staticWidth = width;
          t.updateScale(width, height);
        } else {
        var _this$getPoints7 = _this.getPoints(_this.custom.options, widthIn, heightIn),
            _this$getPoints8 = _slicedToArray(_this$getPoints7, 3),
            pointsNew = _this$getPoints8[0],
            widthNew = _this$getPoints8[1],
            heightNew = _this$getPoints8[2]; // $FlowFixMe


        _this.drawingObject.updatePoints(pointsNew, widthNew, heightNew);

        _this.custom.scale = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](widthIn, heightIn);
        t.updateScale(widthIn, heightIn);
      }

      t.updateTranslation(location.x, location.y);

      _this.setTransform(t);
    };

    return _this;
  }

  _createClass(_Symbol, [{
    key: "getTransform",
    value: function getTransform() {
      if (this.custom.options.draw === 'static') {
        var _t = this.transform._dup();

        var s = _t.s();

        if (s != null) {
          _t.updateScale(s.x / this.custom.options.staticWidth, s.y / this.custom.options.staticHeight);
        }

        return _t;
      }

      var t = this.transform._dup();

      t.updateScale(1, 1);
      return t;
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "getWidth",
    value: function getWidth(options, height) {
      var width;

      if (options.draw === 'static') {
        var staticHeight = options.staticHeight;
        var staticWidth = options.staticWidth;

        if (staticHeight === 'first') {
          staticHeight = height;
        }

        var _this$getDefaultValue = this.getDefaultValues(staticHeight, staticWidth, options);

        width = _this$getDefaultValue.width;

        if (width == null) {
          width = height;
        }

        return width / staticHeight * height;
      }

      width = options.width;

      var _this$getDefaultValue2 = this.getDefaultValues(height, width, options);

      width = _this$getDefaultValue2.width;
      return width;
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "getHeight",
    value: function getHeight(options, width) {
      var height;

      if (options.draw === 'static') {
        var staticWidth = options.staticWidth;
        var staticHeight = options.staticHeight;

        if (staticWidth === 'first') {
          staticWidth = width;
        } // ????


        var _this$getDefaultValue3 = this.getDefaultValues(staticHeight, staticWidth, options);

        height = _this$getDefaultValue3.height;

        if (height == null) {
          height = width;
        }

        return height / staticWidth * width;
      }

      height = options.height;

      var _this$getDefaultValue4 = this.getDefaultValues(height, width, options);

      height = _this$getDefaultValue4.height;
      return height;
    } // eslint-disable-next-line class-methods-use-this, no-unused-vars

  }, {
    key: "getBounds",
    value: function getBounds(options, contentX, contentY, widthIn, heightIn, side) {
      var _this$getDefaultValue5 = this.getDefaultValues(heightIn, widthIn, options),
          width = _this$getDefaultValue5.width,
          height = _this$getDefaultValue5.height;

      var bounds = new _Elements_Bounds__WEBPACK_IMPORTED_MODULE_4__["default"]();

      if (side === 'left') {
        bounds.left = contentX - width;
        bounds.bottom = contentY;
        bounds.top = bounds.bottom + height;
        bounds.right = bounds.left + width;
      } else if (side === 'right') {
        bounds.left = contentX;
        bounds.bottom = contentY;
        bounds.top = bounds.bottom + height;
        bounds.right = bounds.left + width;
      } else if (side === 'top') {
        bounds.bottom = contentY;
        bounds.top = contentY + height;
        bounds.left = contentX + widthIn / 2 - width / 2;
        bounds.right = bounds.left + width;
      } else {
        bounds.top = contentY;
        bounds.bottom = contentY - height;
        bounds.left = contentX + widthIn / 2 - width / 2;
        bounds.right = bounds.left + width;
      }

      bounds.width = width;
      bounds.height = height;
      bounds.ascent = height;
      bounds.descent = 0;
      return bounds;
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "getPoints",
    value: function getPoints(options, width, height) {
      var points = [new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](width, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](width, height), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, height)];
      return [points, width, height];
    } // eslint-disable-next-line class-methods-use-this, no-unused-vars

  }, {
    key: "getDefaultValues",
    value: function getDefaultValues(height, width, options) {
      // const out: {
      //   height?: number,
      //   width?: number,
      //   lineWidth?: number,
      //   tipWidth?: number,
      //   arrowWidth?: number,
      //   arrowHeight?: number,
      // } = {};
      // return out;
      return {};
    }
  }]);

  return _Symbol;
}(_Element__WEBPACK_IMPORTED_MODULE_0__["DiagramElementPrimitive"]);



/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/Symbols/VertexSymbol.js":
/*!*************************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/Symbols/VertexSymbol.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _DrawingObjects_VertexObject_VertexObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../DrawingObjects/VertexObject/VertexObject */ "./src/js/diagram/DrawingObjects/VertexObject/VertexObject.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





var VertexSymbol =
/*#__PURE__*/
function (_VertexObject) {
  _inherits(VertexSymbol, _VertexObject);

  _createClass(VertexSymbol, [{
    key: "updatePoints",
    value: function updatePoints(points, width, height) {
      var _this2 = this;

      var initialize = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      // let t;
      this.points = [];
      points.forEach(function (p) {
        _this2.points.push(p.x);

        _this2.points.push(p.y);
      });
      this.border[0] = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width, height), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, height)];

      if (initialize) {
        this.setupBuffer();
      } else {
        this.resetBuffer();
      }
    }
  }]);

  function VertexSymbol(webgl, type) {
    var _this;

    _classCallCheck(this, VertexSymbol);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(VertexSymbol).call(this, webgl));

    if (type === 'strip') {
      _this.glPrimitive = _this.gl[0].TRIANGLE_STRIP;
    } else if (type === 'fan') {
      _this.glPrimitive = _this.gl[0].TRIANGLE_FAN;
    } else {
      _this.glPrimitive = _this.gl[0].TRIANGLES;
    }

    _this.points = [];
    return _this;
  }

  return VertexSymbol;
}(_DrawingObjects_VertexObject_VertexObject__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (VertexSymbol);

/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/Symbols/Vinculum.js":
/*!*********************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/Symbols/Vinculum.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Bracket; });
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _SymbolNew__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SymbolNew */ "./src/js/diagram/DiagramElements/Equation/Symbols/SymbolNew.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }



 // import WebGLInstance from '../../../webgl/webgl';

var Bracket =
/*#__PURE__*/
function (_Symbol2) {
  _inherits(Bracket, _Symbol2);

  function Bracket() {
    _classCallCheck(this, Bracket);

    return _possibleConstructorReturn(this, _getPrototypeOf(Bracket).apply(this, arguments));
  }

  _createClass(Bracket, [{
    key: "getPoints",
    // eslint-disable-next-line class-methods-use-this
    // getTriangles() {
    //   return 'strip';
    // }
    //                             width
    //          |<---------------------------------------->|
    //          |                                          |  3
    //        1 |                                          | ____
    //          00000000000000000000000000000000000000000000   A
    //          00000000000000000000000000000000000000000000   |  Line Width
    //          00000000000000000000000000000000000000000000 __V_
    //         0                                            2
    //
    // eslint-disable-next-line class-methods-use-this
    value: function getPoints(options, widthIn, heightIn) {
      var _this$getDefaultValue = this.getDefaultValues(heightIn, widthIn, options),
          lineWidth = _this$getDefaultValue.lineWidth,
          width = _this$getDefaultValue.width,
          height = _this$getDefaultValue.height;

      var points = [new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, lineWidth), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](width, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](width, lineWidth)];
      return [points, width, height];
    }
    /* eslint-disable class-methods-use-this */
    // $FlowFixMe

  }, {
    key: "getDefaultValues",
    value: function getDefaultValues(height, width, options) {
      var out = {};

      if (options.lineWidth != null) {
        out.lineWidth = options.lineWidth;
      } else {
        out.lineWidth = 0.01;
      }

      out.height = out.lineWidth;

      if (width != null) {
        out.width = width;
      } else {
        out.width = 1;
      }

      return out;
    }
  }]);

  return Bracket;
}(_SymbolNew__WEBPACK_IMPORTED_MODULE_2__["default"]);



/***/ }),

/***/ "./src/js/diagram/DiagramElements/Fan.js":
/*!***********************************************!*\
  !*** ./src/js/diagram/DiagramElements/Fan.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _DrawingObjects_VertexObject_VertexFan__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../DrawingObjects/VertexObject/VertexFan */ "./src/js/diagram/DrawingObjects/VertexObject/VertexFan.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");





function Fan(webgl, points, color, transformOrLocation, diagramLimits) {
  var vertexLine = new _DrawingObjects_VertexObject_VertexFan__WEBPACK_IMPORTED_MODULE_0__["default"](webgl, points);
  var transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Transform"]();

  if (transformOrLocation instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"]) {
    transform = transform.translate(transformOrLocation.x, transformOrLocation.y);
  } else {
    transform = transformOrLocation._dup();
  }

  return new _Element__WEBPACK_IMPORTED_MODULE_1__["DiagramElementPrimitive"](vertexLine, transform, color, diagramLimits);
}

/* harmony default export */ __webpack_exports__["default"] = (Fan);

/***/ }),

/***/ "./src/js/diagram/DiagramElements/Generic.js":
/*!***************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Generic.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Generic; });
/* harmony import */ var _DrawingObjects_VertexObject_VertexGeneric__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../DrawingObjects/VertexObject/VertexGeneric */ "./src/js/diagram/DrawingObjects/VertexObject/VertexGeneric.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");




function Generic(webgl, vertices, border, holeBorder, drawType, color, transformOrLocation, diagramLimits) {
  var textureLocation = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : '';
  var textureVertexSpace = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Rect"](-1, -1, 2, 2);
  var textureCoords = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Rect"](0, 0, 1, 1);
  var textureRepeat = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : false;
  var onLoad = arguments.length > 12 && arguments[12] !== undefined ? arguments[12] : null;
  var copy = arguments.length > 13 ? arguments[13] : undefined;
  var generic = new _DrawingObjects_VertexObject_VertexGeneric__WEBPACK_IMPORTED_MODULE_0__["default"](webgl, vertices, border, holeBorder, drawType, textureLocation, textureVertexSpace, textureCoords, textureRepeat, copy);

  if (textureLocation) {
    generic.onLoad = onLoad;
  }

  var transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Transform"]();

  if (transformOrLocation instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"]) {
    transform = transform.translate(transformOrLocation.x, transformOrLocation.y);
  } else {
    transform = transformOrLocation._dup();
  } // $FlowFixMe


  return new _Element__WEBPACK_IMPORTED_MODULE_1__["DiagramElementPrimitive"](generic, transform, color, diagramLimits);
}

/***/ }),

/***/ "./src/js/diagram/DiagramElements/HorizontalLine.js":
/*!**********************************************************!*\
  !*** ./src/js/diagram/DiagramElements/HorizontalLine.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _DrawingObjects_VertexObject_VertexHorizontalLine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../DrawingObjects/VertexObject/VertexHorizontalLine */ "./src/js/diagram/DrawingObjects/VertexObject/VertexHorizontalLine.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");





function HorizontalLine(webgl, start, length, width, rotation, color, transformOrLocation, diagramLimits) {
  var vertexLine = new _DrawingObjects_VertexObject_VertexHorizontalLine__WEBPACK_IMPORTED_MODULE_0__["default"](webgl, start, length, width, rotation);
  var transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Transform"]();

  if (transformOrLocation instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"]) {
    transform = transform.translate(transformOrLocation.x, transformOrLocation.y);
  } else {
    transform = transformOrLocation._dup();
  }

  return new _Element__WEBPACK_IMPORTED_MODULE_1__["DiagramElementPrimitive"](vertexLine, transform, color, diagramLimits);
}

/* harmony default export */ __webpack_exports__["default"] = (HorizontalLine);

/***/ }),

/***/ "./src/js/diagram/DiagramElements/Lines.js":
/*!*************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Lines.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _DrawingObjects_VertexObject_VertexLines__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../DrawingObjects/VertexObject/VertexLines */ "./src/js/diagram/DrawingObjects/VertexObject/VertexLines.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");





function Lines(webgl, linePairs, numLinesThick, color, transformOrLocation, diagramLimits) {
  var vertexLine = new _DrawingObjects_VertexObject_VertexLines__WEBPACK_IMPORTED_MODULE_0__["default"](webgl, linePairs, numLinesThick);
  var transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Transform"]();

  if (transformOrLocation instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"]) {
    transform = transform.translate(transformOrLocation.x, transformOrLocation.y);
  } else {
    transform = transformOrLocation._dup();
  }

  return new _Element__WEBPACK_IMPORTED_MODULE_1__["DiagramElementPrimitive"](vertexLine, transform, color, diagramLimits);
}

/* harmony default export */ __webpack_exports__["default"] = (Lines);

/***/ }),

/***/ "./src/js/diagram/DiagramElements/Plot/Axis.js":
/*!*****************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Plot/Axis.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _VertexObjects_VAxis__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./VertexObjects/VAxis */ "./src/js/diagram/DiagramElements/Plot/VertexObjects/VAxis.js");
/* harmony import */ var _VertexObjects_VTickMarks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./VertexObjects/VTickMarks */ "./src/js/diagram/DiagramElements/Plot/VertexObjects/VTickMarks.js");
/* harmony import */ var _AxisProperties__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./AxisProperties */ "./src/js/diagram/DiagramElements/Plot/AxisProperties.js");
/* harmony import */ var _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../DrawingObjects/TextObject/TextObject */ "./src/js/diagram/DrawingObjects/TextObject/TextObject.js");
/* harmony import */ var _DrawContext2D__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../DrawContext2D */ "./src/js/diagram/DrawContext2D.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }






 // import TextObject from '../../textObjects/TextObject';




var Axis =
/*#__PURE__*/
function (_DiagramElementCollec) {
  _inherits(Axis, _DiagramElementCollec);

  function Axis(webgl, drawContext2D) {
    var _this;

    var axisProperties = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new _AxisProperties__WEBPACK_IMPORTED_MODULE_5__["AxisProperties"]();
    var transform = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Transform"]();
    var diagramLimits = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Rect"](-1, 1, 2, 2);

    _classCallCheck(this, Axis);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Axis).call(this, transform, diagramLimits));
    _this.props = axisProperties;
    _this.webgl = webgl;
    _this.diagramLimits = diagramLimits;
    _this.drawContext2D = drawContext2D;

    _this.build();

    return _this;
  }

  _createClass(Axis, [{
    key: "rebuild",
    value: function rebuild() {
      this.drawOrder = [];
      this.build();
    }
  }, {
    key: "build",
    value: function build() {
      var _this$props = this.props,
          minorTicks = _this$props.minorTicks,
          majorTicks = _this$props.majorTicks,
          minorGrid = _this$props.minorGrid,
          majorGrid = _this$props.majorGrid;

      if (majorTicks.mode === 'auto') {
        this.props.generateAutoMajorTicks();
      }

      if (minorTicks.mode === 'auto') {
        this.props.generateAutoMinorTicks();
      }

      var xRatio = 2 / this.diagramLimits.width; // const xRatio = 1;
      // const yRatio = 2 / diagramLimits.height;

      var cMajorTicksStart = this.props.valueToClip(majorTicks.start);
      var cMinorTicksStart = this.props.valueToClip(minorTicks.start);
      var majorTicksNum = this.props.getMajorNum();
      var minorTicksNum = this.props.getMinorNum(); // Grid

      this.addTicksOrGrid('minorGrid', this.webgl, minorGrid, minorTicksNum, minorTicks.step, cMinorTicksStart, xRatio, this.diagramLimits);
      this.addTicksOrGrid('majorGrid', this.webgl, majorGrid, majorTicksNum, majorTicks.step, cMajorTicksStart, xRatio, this.diagramLimits); // Ticks

      this.addTicksOrGrid('minorTicks', this.webgl, minorTicks, minorTicksNum, minorTicks.step, cMinorTicksStart, xRatio, this.diagramLimits);
      this.addTicksOrGrid('majorTicks', this.webgl, majorTicks, majorTicksNum, majorTicks.step, cMajorTicksStart, xRatio, this.diagramLimits); // Axis Line

      var axis = new _VertexObjects_VAxis__WEBPACK_IMPORTED_MODULE_3__["default"](this.webgl, this.props);
      this.add('line', new _Element__WEBPACK_IMPORTED_MODULE_0__["DiagramElementPrimitive"](axis, new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Transform"](), this.props.color, this.diagramLimits));
      var font = new _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_6__["DiagramFont"](this.props.titleFontFamily, 'normal', this.props.titleFontSize, this.props.titleFontWeight, 'center', 'middle', this.props.titleFontColor);
      var titleText = [new _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_6__["DiagramText"](new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, 0).transformBy(new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Transform"]().rotate(this.props.rotation).matrix()), this.props.title, font)];
      var title = new _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_6__["TextObject"](this.drawContext2D[0], titleText);
      this.add('title', new _Element__WEBPACK_IMPORTED_MODULE_0__["DiagramElementPrimitive"](title, new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Transform"]().rotate(this.props.rotation).translate(this.props.titleOffset.x, this.props.titleOffset.y), [0.5, 0.5, 0.5, 1], this.diagramLimits)); // Labels

      this.addTickLabels('major', this.drawContext2D[0], majorTicks, this.props.generateMajorLabels.bind(this.props), this.diagramLimits, this.props.majorTicks.labelOffset);
      this.addTickLabels('minor', this.drawContext2D[0], minorTicks, this.props.generateMinorLabels.bind(this.props), this.diagramLimits, this.props.minorTicks.labelOffset);
    }
  }, {
    key: "toClip",
    value: function toClip(value) {
      return this.props.toClip(value);
    }
  }, {
    key: "valueToClip",
    value: function valueToClip(value) {
      return this.props.valueToClip(value);
    }
  }, {
    key: "addTicksOrGrid",
    value: function addTicksOrGrid(name, webgl, ticksOrGrid, num, step, clipStart, xRatio, diagramLimits) {
      if (ticksOrGrid.mode !== 'off') {
        var ticks = new _VertexObjects_VTickMarks__WEBPACK_IMPORTED_MODULE_4__["default"](webgl, new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"]( // clipStart - ticksOrGrid.width / 2 * xRatio,
        clipStart, this.props.start.y), this.props.rotation, num, this.toClip(step), ticksOrGrid.length, ticksOrGrid.width, ticksOrGrid.offset);
        this.add(name, new _Element__WEBPACK_IMPORTED_MODULE_0__["DiagramElementPrimitive"](ticks, new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Transform"]().scale(1, 1).rotate(0).translate(0, 0), ticksOrGrid.color, diagramLimits)); // if (name === 'majorTicks') {
        //   console.log(ticks)
        // }
      }
    }
  }, {
    key: "addTickLabels",
    value: function addTickLabels(name, drawContext2D, ticks, labelGenerator, diagramLimits, offset) {
      if (ticks.labelMode === 'auto') {
        labelGenerator();
      }

      var font = new _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_6__["DiagramFont"](ticks.fontFamily, 'normal', ticks.fontSize, ticks.fontWeight, ticks.labelsHAlign, ticks.labelsVAlign, ticks.fontColor);

      if (this.props.rotation > Math.PI / 2 * 0.95) {
        font.yAlign = 'middle';
        font.xAlign = 'right';
      }

      var dText = [];

      for (var i = 0; i < ticks.labels.length; i += 1) {
        dText.push(new _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_6__["DiagramText"](new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](this.valueToClip(ticks.start + i * ticks.step), 0).transformBy(new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Transform"]().rotate(this.props.rotation).matrix()), ticks.labels[i], font));
      }

      var axisLabels = new _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_6__["TextObject"](drawContext2D, dText);
      this.add("label_".concat(name), new _Element__WEBPACK_IMPORTED_MODULE_0__["DiagramElementPrimitive"](axisLabels, new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Transform"]().scale(1, 1).rotate(0).translate(offset.x, offset.y), [0.5, 0.5, 0.5, 1], diagramLimits)); // const label = new TextObject(
      //   drawContext2D,
      //   ticks.labels[i],
      //   new Point(
      //     this.valueToClip(ticks.start + i * ticks.step),
      //     0,
      //   ).transformBy(new Transform().rotate(this.props.rotation).matrix()),
      //   [ticks.labelsHAlign, ticks.labelsVAlign],
      //   ticks.labelOffset,
      // );
      // label.fontSize = ticks.fontSize;
      // label.fontFamily = ticks.fontFamily;
      // label.fontWeight = ticks.fontWeight;
      // this.add(`label_${name}_${i}`, new DiagramElementPrimitive(
      //   label,
      //   new Transform().scale(1, 1).rotate(0).translate(0, 0),
      //   [0.5, 0.5, 0.5, 1],
      //   diagramLimits,
      // ));
    }
  }]);

  return Axis;
}(_Element__WEBPACK_IMPORTED_MODULE_0__["DiagramElementCollection"]);

/* harmony default export */ __webpack_exports__["default"] = (Axis);

/***/ }),

/***/ "./src/js/diagram/DiagramElements/Plot/AxisProperties.js":
/*!***************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Plot/AxisProperties.js ***!
  \***************************************************************/
/*! exports provided: AxisProperties, GridProperties, TickProperties */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AxisProperties", function() { return AxisProperties; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GridProperties", function() { return GridProperties; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TickProperties", function() { return TickProperties; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tools/math */ "./src/js/tools/math.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }



var defaultColor = [0.7, 0.7, 0.7, 1];

var GridProperties = // Clip Space
// General
function GridProperties() {
  _classCallCheck(this, GridProperties);

  this.length = 1;
  this.width = 0.01;
  this.color = defaultColor;
  this.mode = 'on';
  this.offset = 0;
};

var TickProperties =
/*#__PURE__*/
function (_GridProperties) {
  _inherits(TickProperties, _GridProperties);

  // Axis Space
  // Clip Space;
  // General
  function TickProperties() {
    var _this;

    _classCallCheck(this, TickProperties);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(TickProperties).call(this));
    _this.start = 0;
    _this.step = 0.1;
    _this.length = 0.05;
    _this.width = 0.01;
    _this.offset = 0;
    _this.labelOffset = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
    _this.color = defaultColor;
    _this.labels = [];
    _this.labelMode = 'auto';
    _this.labelsHAlign = 'center';
    _this.labelsVAlign = 'middle';
    _this.mode = 'on';
    _this.fontFamily = 'Helvetica Neue';
    _this.fontWeight = '400';
    _this.fontSize = 0.1;
    _this.fontColor = defaultColor;
    return _this;
  }

  return TickProperties;
}(GridProperties);

var AxisProperties =
/*#__PURE__*/
function () {
  function AxisProperties() {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var rotation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    _classCallCheck(this, AxisProperties);

    this.name = name; // Clip Space

    this.start = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
    this.length = 1;
    this.width = 0.01;
    this.rotation = rotation;
    this.color = [0.5, 0.5, 0.5, 1];
    this.title = '';
    this.titleOffset = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](this.length / 2, -0.1);
    this.titleRotation = 0;
    this.limits = {
      min: 0,
      max: 1
    };
    this.logarithmic = false;
    this.majorTicks = new TickProperties();
    this.minorTicks = new TickProperties();
    this.minorTicks.labelMode = 'off';
    this.majorGrid = new GridProperties();
    this.minorGrid = new GridProperties();
    this.titleFontFamily = 'Helvetica Neue';
    this.titleFontWeight = '400';
    this.titleFontSize = 0.13;
    this.titleFontColor = defaultColor;
  }

  _createClass(AxisProperties, [{
    key: "getNum",
    value: function getNum(start, step) {
      return Math.floor((this.limits.max - start) / step) + 1;
    }
  }, {
    key: "getMajorNum",
    value: function getMajorNum() {
      return this.getNum(this.majorTicks.start, this.majorTicks.step);
    }
  }, {
    key: "getMinorNum",
    value: function getMinorNum() {
      return this.getNum(this.minorTicks.start, this.minorTicks.step);
    }
  }, {
    key: "generateAuto",
    value: function generateAuto() {
      var approximateNum = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
      // const approximateNum = 10;
      var range = this.limits.max - this.limits.min;
      var step = range / approximateNum;
      var orderOfMagnitude = Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["roundNum"])(Math.floor(Math.log10(step)), 0);
      step = Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["roundNum"])(step, -orderOfMagnitude);
      var start = Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["roundNum"])(this.limits.min, -orderOfMagnitude);

      if (start < this.limits.min) {
        start += Math.pow(10, orderOfMagnitude);
      }

      if (this.getNum(start, step) > 11) {
        step *= 2;
      }

      return {
        start: start,
        step: step
      };
    }
  }, {
    key: "generateAutoMajorTicks",
    value: function generateAutoMajorTicks() {
      var approximateNum = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;

      var _this$generateAuto = this.generateAuto(approximateNum),
          start = _this$generateAuto.start,
          step = _this$generateAuto.step;

      this.majorTicks.start = start;
      this.majorTicks.step = step;
    }
  }, {
    key: "generateAutoMinorTicks",
    value: function generateAutoMinorTicks() {
      var approximateNum = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;

      var _this$generateAuto2 = this.generateAuto(approximateNum),
          start = _this$generateAuto2.start,
          step = _this$generateAuto2.step;

      this.minorTicks.start = start;
      this.minorTicks.step = step;
    }
  }, {
    key: "toClip",
    value: function toClip(value) {
      var ratio = this.length / (this.limits.max - this.limits.min);
      return value * ratio;
    }
  }, {
    key: "valueToClip",
    value: function valueToClip(value) {
      return this.toClip(value - this.limits.min) + this.start.x;
    }
  }, {
    key: "getMajorLabels",
    value: function getMajorLabels() {
      var labels = [];

      for (var i = 0, j = this.getMajorNum(); i < j; i += 1) {
        var value = this.majorTicks.start + i * this.majorTicks.step;
        labels.push(value.toString());
      }

      return labels;
    }
  }, {
    key: "generateMajorLabels",
    value: function generateMajorLabels() {
      this.majorTicks.labels = this.getMajorLabels();
    }
  }, {
    key: "getMinorLabels",
    value: function getMinorLabels() {
      var labels = [];

      for (var i = 0, j = this.getMinorNum(); i < j; i += 1) {
        var value = this.minorTicks.start + i * this.minorTicks.step;
        labels.push(value.toString());
      }

      return labels;
    }
  }, {
    key: "generateMinorLabels",
    value: function generateMinorLabels() {
      this.minorTicks.labels = this.getMinorLabels();
    }
  }]);

  return AxisProperties;
}();



/***/ }),

/***/ "./src/js/diagram/DiagramElements/Plot/VertexObjects/VAxis.js":
/*!********************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Plot/VertexObjects/VAxis.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _DrawingObjects_VertexObject_Triangles_TRIHoriztonalLine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../DrawingObjects/VertexObject/Triangles/TRIHoriztonalLine */ "./src/js/diagram/DrawingObjects/VertexObject/Triangles/TRIHoriztonalLine.js");
/* harmony import */ var _AxisProperties__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../AxisProperties */ "./src/js/diagram/DiagramElements/Plot/AxisProperties.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _DrawingObjects_VertexObject_VertexObject__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../DrawingObjects/VertexObject/VertexObject */ "./src/js/diagram/DrawingObjects/VertexObject/VertexObject.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }







var VAxis =
/*#__PURE__*/
function (_VertexObject) {
  _inherits(VAxis, _VertexObject);

  function VAxis(webgl) {
    var _this;

    var axisProperties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _AxisProperties__WEBPACK_IMPORTED_MODULE_1__["AxisProperties"]();

    _classCallCheck(this, VAxis);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(VAxis).call(this, webgl));
    var a = axisProperties;
    var t = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Transform"]().rotate(a.rotation).translate(a.start.x, a.start.y).matrix();

    if (a.width > 0) {
      var result = Object(_DrawingObjects_VertexObject_Triangles_TRIHoriztonalLine__WEBPACK_IMPORTED_MODULE_0__["default"])(new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"](0, 0), a.length, a.width, 0);
      var points = result.points,
          border = result.border;
      _this.points = points;
      _this.border = [border];
    }

    _this.transform(t);

    _this.setupBuffer();

    return _this;
  }

  return VAxis;
}(_DrawingObjects_VertexObject_VertexObject__WEBPACK_IMPORTED_MODULE_4__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (VAxis);

/***/ }),

/***/ "./src/js/diagram/DiagramElements/Plot/VertexObjects/VTickMarks.js":
/*!*************************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Plot/VertexObjects/VTickMarks.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _DrawingObjects_VertexObject_Triangles_TRIParallelLines__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../DrawingObjects/VertexObject/Triangles/TRIParallelLines */ "./src/js/diagram/DrawingObjects/VertexObject/Triangles/TRIParallelLines.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _DrawingObjects_VertexObject_VertexObject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../DrawingObjects/VertexObject/VertexObject */ "./src/js/diagram/DrawingObjects/VertexObject/VertexObject.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }






var VTickMarks =
/*#__PURE__*/
function (_VertexObject) {
  _inherits(VTickMarks, _VertexObject);

  function VTickMarks(webgl, start, rotation, num, spacing, length, width, offset) {
    var _this;

    _classCallCheck(this, VTickMarks);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(VTickMarks).call(this, webgl));
    var t = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Transform"]().rotate(rotation).translate(0, 0).matrix();
    var result = Object(_DrawingObjects_VertexObject_Triangles_TRIParallelLines__WEBPACK_IMPORTED_MODULE_0__["default"])(num, spacing, new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](start.x, start.y + offset), length, width, false, false);
    var points = result.points,
        border = result.border;
    _this.points = points;
    _this.border = border;

    _this.transform(t);

    _this.setupBuffer();

    return _this;
  }

  return VTickMarks;
}(_DrawingObjects_VertexObject_VertexObject__WEBPACK_IMPORTED_MODULE_3__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (VTickMarks);

/***/ }),

/***/ "./src/js/diagram/DiagramElements/RadialLines.js":
/*!*******************************************************!*\
  !*** ./src/js/diagram/DiagramElements/RadialLines.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _DrawingObjects_VertexObject_VertexRadialLines__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../DrawingObjects/VertexObject/VertexRadialLines */ "./src/js/diagram/DrawingObjects/VertexObject/VertexRadialLines.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");





function RadialLines(webgl) {
  var innerRadius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var outerRadius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var width = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.05;
  var dAngle = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Math.PI / 4;
  var maxAngle = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : Math.PI * 2;
  var color = arguments.length > 6 ? arguments[6] : undefined;
  var transformOrLocation = arguments.length > 7 ? arguments[7] : undefined;
  var diagramLimits = arguments.length > 8 ? arguments[8] : undefined;
  var vertexLine = new _DrawingObjects_VertexObject_VertexRadialLines__WEBPACK_IMPORTED_MODULE_0__["default"](webgl, innerRadius, outerRadius, width, dAngle, maxAngle);
  var transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Transform"]();

  if (transformOrLocation instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"]) {
    transform = transform.translate(transformOrLocation.x, transformOrLocation.y);
  } else {
    transform = transformOrLocation._dup();
  }

  return new _Element__WEBPACK_IMPORTED_MODULE_1__["DiagramElementPrimitive"](vertexLine, transform, color, diagramLimits);
}

/* harmony default export */ __webpack_exports__["default"] = (RadialLines);

/***/ }),

/***/ "./src/js/diagram/DiagramElements/Rectangle.js":
/*!*****************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Rectangle.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Rectangle; });
/* harmony import */ var _DrawingObjects_VertexObject_VertexRectangle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../DrawingObjects/VertexObject/VertexRectangle */ "./src/js/diagram/DrawingObjects/VertexObject/VertexRectangle.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");




function Rectangle(webgl, xAlign, yAlign, width, height, lineWidth, cornerRadius, cornerSides, color, transformOrLocation, diagramLimits) {
  var vertexRectangle = new _DrawingObjects_VertexObject_VertexRectangle__WEBPACK_IMPORTED_MODULE_0__["default"](webgl, xAlign, yAlign, width, height, lineWidth, cornerRadius, cornerSides);
  var transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Transform"]();

  if (transformOrLocation instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"]) {
    transform = transform.translate(transformOrLocation.x, transformOrLocation.y);
  } else {
    transform = transformOrLocation._dup();
  }

  return new _Element__WEBPACK_IMPORTED_MODULE_1__["DiagramElementPrimitive"](vertexRectangle, transform, color, diagramLimits);
}

/***/ }),

/***/ "./src/js/diagram/DiagramElements/RectangleFilled.js":
/*!***********************************************************!*\
  !*** ./src/js/diagram/DiagramElements/RectangleFilled.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RectangleFilled; });
/* harmony import */ var _DrawingObjects_VertexObject_VertexRectangleFilled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../DrawingObjects/VertexObject/VertexRectangleFilled */ "./src/js/diagram/DrawingObjects/VertexObject/VertexRectangleFilled.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");




function RectangleFilled(webgl, xAlign, yAlign, width, height, cornerRadius, cornerSides, color, transformOrLocation, diagramLimits) {
  var vertexRectangle = new _DrawingObjects_VertexObject_VertexRectangleFilled__WEBPACK_IMPORTED_MODULE_0__["default"](webgl, xAlign, yAlign, width, height, cornerRadius, cornerSides);
  var transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Transform"]();

  if (transformOrLocation instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"]) {
    transform = transform.translate(transformOrLocation.x, transformOrLocation.y);
  } else {
    transform = transformOrLocation._dup();
  }

  return new _Element__WEBPACK_IMPORTED_MODULE_1__["DiagramElementPrimitive"](vertexRectangle, transform, color, diagramLimits);
}

/***/ }),

/***/ "./src/js/diagram/DiagramElements/Text.js":
/*!************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Text.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _DrawingObjects_VertexObject_VertexText__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../DrawingObjects/VertexObject/VertexText */ "./src/js/diagram/DrawingObjects/VertexObject/VertexText.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
// import VertexPolygon from '../DrawingObjects/VertexObject/VertexPolygon';
 // import VertexPolygonLine from '../DrawingObjects/VertexObject/VertexPolygonLine';






function Text(webgl, diagramLimits, optionsIn) {
  var defaultOptions = {
    position: new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"](0, 0),
    color: [1, 0, 0, 1]
  };
  var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_4__["joinObjects"])({}, defaultOptions, optionsIn);

  if (options.transform == null) {
    options.transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Transform"]('Text').translate(0, 0);
  }

  if (options.position != null) {
    options.transform.updateTranslation(options.position);
  }

  var vertexText = new _DrawingObjects_VertexObject_VertexText__WEBPACK_IMPORTED_MODULE_0__["default"](webgl, options); // let transform = new Transform();
  // if (transformOrLocation instanceof Point) {
  //   transform = transform.translate(transformOrLocation.x, transformOrLocation.y);
  // } else {
  //   transform = transformOrLocation._dup();
  // }

  return new _Element__WEBPACK_IMPORTED_MODULE_1__["DiagramElementPrimitive"](vertexText, options.transform, options.color, diagramLimits);
}

/* harmony default export */ __webpack_exports__["default"] = (Text);

/***/ }),

/***/ "./src/js/diagram/DiagramEquation/DiagramEquation.js":
/*!***********************************************************!*\
  !*** ./src/js/diagram/DiagramEquation/DiagramEquation.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DiagramEquation; });
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _DrawContext2D__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../DrawContext2D */ "./src/js/diagram/DrawContext2D.js");
/* harmony import */ var _DiagramElements_Equation_Equation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../DiagramElements/Equation/Equation */ "./src/js/diagram/DiagramElements/Equation/Equation.js");
/* harmony import */ var _DiagramObjects_EqnNavigator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../DiagramObjects/EqnNavigator */ "./src/js/diagram/DiagramObjects/EqnNavigator.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }









var DiagramEquation =
/*#__PURE__*/
function () {
  function DiagramEquation(shapes, animateNextFrame) {
    _classCallCheck(this, DiagramEquation);

    this.webgl = shapes.webgl;
    this.draw2D = shapes.draw2D;
    this.limits = shapes.limits;
    this.shapes = shapes;
    this.animateNextFrame = animateNextFrame;
  }

  _createClass(DiagramEquation, [{
    key: "equation",
    value: function equation(options) {
      var equation = new _DiagramElements_Equation_Equation__WEBPACK_IMPORTED_MODULE_5__["Equation"](this.shapes, options);
      return equation;
    }
  }, {
    key: "addEquation",
    value: function addEquation(parent, name) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      // $FlowFixMe
      var equation = new _DiagramElements_Equation_Equation__WEBPACK_IMPORTED_MODULE_5__["Equation"](this.shapes, options);
      parent.add(name, equation);
      return equation;
    }
  }, {
    key: "addNavigator",
    value: function addNavigator(parent, name, options) {
      var navNameToUse = name;
      var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_3__["joinObjects"])({}, options);

      if (optionsToUse.equation == null) {
        // $FlowFixMe
        var equation = this.addEquation(parent, "".concat(name, "Eqn"), options);
        optionsToUse.equation = equation;
        navNameToUse = "".concat(name, "Nav");
      } else if (!(optionsToUse.equation instanceof _DiagramElements_Equation_Equation__WEBPACK_IMPORTED_MODULE_5__["Equation"])) {
        // let methodPathToUse;
        var nameToUse; // let pathToUse;

        var eqnOptions;
        var elementModsToUse; // let addElementsToUse;

        var firstScenario;

        if (Array.isArray(optionsToUse.equation)) {
          var _optionsToUse$equatio = _slicedToArray(optionsToUse.equation, 7);

          nameToUse = _optionsToUse$equatio[1];
          eqnOptions = _optionsToUse$equatio[3];
          elementModsToUse = _optionsToUse$equatio[4];
          firstScenario = _optionsToUse$equatio[6];
        } else {
          nameToUse = optionsToUse.equation.name; // pathToUse = optionsToUse.equation.path;

          eqnOptions = optionsToUse.equation.options; // methodPathToUse = optionsToUse.equation.method;

          elementModsToUse = optionsToUse.equation.mods;
          firstScenario = optionsToUse.equation.scenario;
        }

        var _equation;

        if (Array.isArray(eqnOptions)) {
          _equation = this.addEquation.apply(this, [parent, nameToUse].concat(_toConsumableArray(eqnOptions)));
        } else {
          _equation = this.addEquation(parent, nameToUse, eqnOptions);
        }

        if (elementModsToUse != null && elementModsToUse !== {}) {
          _equation.setProperties(elementModsToUse);
        }

        if (firstScenario != null && firstScenario in _equation.scenarios) {
          _equation.setScenario(firstScenario);
        }

        optionsToUse.equation = _equation;
      } // $FlowFixMe


      var navigator = new _DiagramObjects_EqnNavigator__WEBPACK_IMPORTED_MODULE_6__["default"](this.shapes, this.animateNextFrame, optionsToUse);
      parent.add(navNameToUse, navigator);
      return navigator;
    }
  }]);

  return DiagramEquation;
}();



/***/ }),

/***/ "./src/js/diagram/DiagramObjects/Angle.js":
/*!************************************************!*\
  !*** ./src/js/diagram/DiagramObjects/Angle.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/math */ "./src/js/tools/math.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _EquationLabel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./EquationLabel */ "./src/js/diagram/DiagramObjects/EquationLabel.js");
/* harmony import */ var _DiagramElements_Equation_Equation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../DiagramElements/Equation/Equation */ "./src/js/diagram/DiagramElements/Equation/Equation.js");
function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

// import Diagram from '../Diagram';







// Angle is a class that manages:
//   A angle curve
//   Label
//   Arrows
//   Straight Lines
//
// The angle collection comprises:
//   * Positioned at 0, 0 in vertex space
//   * Curve from 0 to angle size (where 0 is along x axis in vertex space)
//   * Label in center of curve
//   * Arrows at ends of curve
//   * Straight lines forming the corner
//
// To give the angle a custom position and rotation from 0, the main class's
// transform is used:
//   - Translation for position
//   - Rotation for rotation
//
// An angle can be defined in two ways:
//   - Angle, rotation, position
//   - p1, p2, p3
var AngleLabel =
/*#__PURE__*/
function (_EquationLabel) {
  _inherits(AngleLabel, _EquationLabel);

  function AngleLabel(equation, labelText, color, radius) {
    var _this;

    var curvePosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;
    var curveOffset = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
    var showRealAngle = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
    var units = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 'degrees';
    var precision = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;
    var autoHide = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : null;
    var autoHideMax = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : null;
    var orientation = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : 'horizontal';
    var scale = arguments.length > 12 && arguments[12] !== undefined ? arguments[12] : 0.7;

    _classCallCheck(this, AngleLabel);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(AngleLabel).call(this, equation, {
      label: labelText,
      color: color,
      scale: scale
    }));
    _this.radius = radius;
    _this.curvePosition = curvePosition;
    _this.curveOffset = curveOffset;
    _this.showRealAngle = showRealAngle;
    _this.units = units;
    _this.orientation = orientation;
    _this.precision = precision;
    _this.autoHide = autoHide;
    _this.autoHideMax = autoHideMax;
    return _this;
  }

  return AngleLabel;
}(_EquationLabel__WEBPACK_IMPORTED_MODULE_4__["default"]);

var DiagramObjectAngle =
/*#__PURE__*/
function (_DiagramElementCollec) {
  _inherits(DiagramObjectAngle, _DiagramElementCollec);

  _createClass(DiagramObjectAngle, [{
    key: "calculateFromP1P2P3",
    // Diagram elements
    // Objects that may or may not exist
    // angle properties - pulic read only
    // rotation: number;
    // position: Point;
    // angle properties - pulic read/write
    // angle properties - private internal use only
    // Pulic Angle methods
    // nextAngle: ?number;
    // eslint-disable-next-line class-methods-use-this
    value: function calculateFromP1P2P3(p1, p2, p3) {
      var direction = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

      var position = p2._dup();

      var angle = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["threePointAngle"])(p1, p2, p3);

      if (direction === 1) {
        var L21 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](p2, p1);

        var _rotation = L21.angle();

        return {
          position: position,
          rotation: _rotation,
          angle: angle
        };
      }

      var L23 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](p2, p1);
      var rotation = L23.angle();
      return {
        position: position,
        rotation: rotation,
        angle: Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["clipAngle"])(Math.PI * 2 - angle, '0to360')
      };
    }
  }]);

  function DiagramObjectAngle(shapes, equation, isTouchDevice, animateNextFrame) {
    var _this2;

    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

    _classCallCheck(this, DiagramObjectAngle);

    var defaultOptions = {
      position: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
      rotation: 0,
      angle: 1,
      // radius: 0.1,
      color: [0, 1, 0, 1],
      // clockwise: false,
      direction: 1,
      autoRightAngle: false,
      rightAngleRange: 0.001,
      curve: null,
      sides: null,
      sideStart: null,
      sideStop: null,
      arrows: null,
      arrow1: null,
      arrow2: null,
      label: null,
      p1: null,
      // if p1, p2 and p3 are defined, position, angle and
      p2: null,
      // rotation will be overridden
      p3: null,
      pulse: {
        curve: 1,
        label: 1,
        arrow: 1,
        side: 1,
        collection: 1.8
      },
      mods: {}
    };
    var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, defaultOptions, options);
    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(DiagramObjectAngle).call(this, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('Line').scale(1, 1).rotate(0).translate(0, 0), shapes.limits));

    _this2.setColor(optionsToUse.color);

    _this2.shapes = shapes;
    _this2.equation = equation;
    _this2.largerTouchBorder = optionsToUse.largerTouchBorder;
    _this2.isTouchDevice = isTouchDevice;
    _this2.animateNextFrame = animateNextFrame; // Calculate and store the angle geometry

    _this2.nextPosition = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(optionsToUse.position);
    _this2.nextRotation = optionsToUse.rotation;
    _this2.direction = optionsToUse.direction;
    _this2.angle = optionsToUse.angle;
    _this2.lastLabelRotationOffset = 0;
    _this2.autoRightAngle = optionsToUse.autoRightAngle;
    _this2.rightAngleRange = optionsToUse.rightAngleRange; // this.clockwise = optionsToUse.clockwise;
    // this.radius = optionsToUse.radius;

    if (optionsToUse.p1 != null && optionsToUse.p2 != null && optionsToUse.p3 != null) {
      var _this2$calculateFromP = _this2.calculateFromP1P2P3(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(optionsToUse.p1), Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(optionsToUse.p2), Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(optionsToUse.p3), _this2.direction),
          position = _this2$calculateFromP.position,
          rotation = _this2$calculateFromP.rotation,
          angle = _this2$calculateFromP.angle;

      _this2.angle = angle;
      _this2.nextRotation = rotation;
      _this2.nextPosition = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(position);
    }

    _this2.setNextPositionAndRotation(); // if (this.nextPosition != null) {
    //   this.transform.updateTranslation(this.nextPosition);
    // }
    // if (this.nextRotation != null) {
    //   this.transform.updateRotation(this.nextRotation);
    // }
    // this.nextPosition = null;
    // this.nextRotation = null;
    // Setup default values for sides, arrows, curve and label


    _this2.side1 = null;
    _this2.side2 = null;
    _this2.arrow1 = null;
    _this2.arrow2 = null;
    _this2.curve = null;
    _this2.label = null; // If the curve is to be shown (and not just a label) then make it

    _this2._curve = null;

    if (optionsToUse.curve) {
      _this2.addCurve(optionsToUse.curve);
    } // Arrows


    if (optionsToUse.arrow1 || optionsToUse.arrows) {
      _this2.addArrow(1, Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, optionsToUse.arrow1, optionsToUse.arrows));
    }

    if (optionsToUse.arrow2 || optionsToUse.arrows) {
      _this2.addArrow(2, Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, optionsToUse.arrow2, optionsToUse.arrows));
    } // Label


    if (optionsToUse.label) {
      _this2.addLabel(optionsToUse.label);
    } // Sides


    var defaultSideLength = 0.5;

    if (_this2.curve) {
      defaultSideLength = _this2.curve.radius * 2;
    }

    var defaultSideWidth = 0.01;

    if (_this2.curve) {
      defaultSideWidth = _this2.curve.width;
    }

    var defaultSideOptions = {
      length: defaultSideLength,
      width: defaultSideWidth,
      color: _this2.color
    };

    if (optionsToUse.side1) {
      var sideOptions = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, defaultSideOptions, optionsToUse.side1);

      _this2.addSide(1, sideOptions.length, sideOptions.width, sideOptions.color);
    }

    if (optionsToUse.side2) {
      var _sideOptions = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, defaultSideOptions, optionsToUse.side2);

      _this2.addSide(2, _sideOptions.length, _sideOptions.width, _sideOptions.color);
    } // Sides overrides side1 and side2


    if (optionsToUse.sides) {
      var sides = {};

      if (_typeof(optionsToUse.sides) === 'object') {
        sides = optionsToUse.sides;
      }

      var _sideOptions2 = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, defaultSideOptions, sides);

      _this2.addSide(1, _sideOptions2.length, _sideOptions2.width, _sideOptions2.color);

      _this2.addSide(2, _sideOptions2.length, _sideOptions2.width, _sideOptions2.color);
    }

    if (typeof optionsToUse.pulse === 'number') {
      _this2.pulseDefaultSettings = {
        curve: defaultOptions.pulse.curve,
        label: defaultOptions.pulse.label,
        arrow: defaultOptions.pulse.arrow,
        side: defaultOptions.pulse.side,
        collection: optionsToUse.pulse
      };
    } else {
      _this2.pulseDefaultSettings = {
        curve: optionsToUse.pulse.curve || 1,
        label: optionsToUse.pulse.label || 1,
        arrow: optionsToUse.pulse.arrow || 1,
        side: optionsToUse.pulse.side || 1,
        collection: optionsToUse.pulse.collection || 1
      };
    } // this.pulseDefault = (done) => {
    //   this.pulseScaleNow(1, 1.7, 0, done);
    // };


    _this2.pulseDefault = function (done) {
      var doneToUse = done;
      var pulseSettings = _this2.pulseDefaultSettings;

      if (typeof pulseSettings.curve === 'number') {
        if (pulseSettings.curve !== 1 && _this2._curve != null) {
          _this2._curve.pulseScaleNow(1, pulseSettings.curve, 0, doneToUse);

          doneToUse = null;
        }
      } else if (_this2._curve != null && pulseSettings.curve != null) {
        var defaultCurveThickOptions = {
          width: 2,
          num: 5
        };
        var curveOptions = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])(defaultCurveThickOptions, pulseSettings.curve); // $FlowFixMe

        _this2._curve.pulseThickNow(1, curveOptions.width, curveOptions.num, doneToUse);

        doneToUse = null;
      }

      if (pulseSettings.label !== 1 && _this2._label != null) {
        _this2._label.pulseScaleNow(1, pulseSettings.label, 0, doneToUse);

        doneToUse = null;
      }

      if (pulseSettings.arrow !== 1) {
        if (_this2._arrow1 != null) {
          _this2._arrow1.pulseScaleNow(1, pulseSettings.arrow, 0, doneToUse);

          doneToUse = null;
        }

        if (_this2._arrow2 != null) {
          _this2._arrow2.pulseScaleNow(1, pulseSettings.arrow, 0, doneToUse);

          doneToUse = null;
        }
      }

      if (pulseSettings.side !== 1) {
        if (_this2._side1 != null) {
          _this2._side1.pulseScaleNow(1, pulseSettings.side, 0, doneToUse);

          doneToUse = null;
        }

        if (_this2._side2 != null) {
          _this2._side2.pulseScaleNow(1, pulseSettings.side, 0, doneToUse);

          doneToUse = null;
        }
      }

      if (pulseSettings.collection !== 1) {
        _this2.pulseScaleNow(1, pulseSettings.collection, 0, doneToUse);
      }
    };

    _this2.update();

    if (optionsToUse.mods != null && optionsToUse.mods !== {}) {
      _this2.setProperties(optionsToUse.mods);
    }

    return _this2;
  }

  _createClass(DiagramObjectAngle, [{
    key: "setNextPositionAndRotation",
    value: function setNextPositionAndRotation() {
      if (this.nextPosition != null) {
        this.transform.updateTranslation(this.nextPosition);
      }

      if (this.nextRotation != null) {
        this.transform.updateRotation(this.nextRotation);
      }

      this.nextPosition = null;
      this.nextRotation = null;
    }
  }, {
    key: "setAngle",
    value: function setAngle() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (options.position != null) {
        this.nextPosition = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(options.position);
      }

      if (options.rotation != null) {
        this.nextRotation = options.rotation;
      }

      if (options.angle != null) {
        this.angle = options.angle;
      }

      var p1 = options.p1,
          p2 = options.p2,
          p3 = options.p3;

      if (p1 != null && p2 != null && p3 != null) {
        var _this$calculateFromP = this.calculateFromP1P2P3(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(p1), Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(p2), Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(p3), this.direction),
            position = _this$calculateFromP.position,
            rotation = _this$calculateFromP.rotation,
            angle = _this$calculateFromP.angle;

        this.angle = angle;
        this.nextRotation = rotation;
        this.nextPosition = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(position);
      }

      if (options.rotationOffset != null) {
        this.update(options.rotationOffset);
      } else {
        this.update();
      }
    }
  }, {
    key: "addSide",
    value: function addSide(index) {
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var color = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.color;
      var line = this.shapes.horizontalLine(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), 1, width, 0, color, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(1, 1).rotate(0)); // $FlowFixMe

      this["side".concat(index)] = {
        length: length,
        width: width
      };
      this.add("side".concat(index), line);
    }
  }, {
    key: "addLabel",
    value: function addLabel() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var defaultLabelOptions = {
        text: null,
        radius: 0.4,
        curvePosition: 0.5,
        curveOffset: 0,
        showRealAngle: false,
        units: 'degrees',
        precision: 0,
        orientation: 'horizontal',
        autoHide: null,
        autoHideMax: null,
        scale: 0.7,
        color: this.color
      };

      if (this.curve) {
        defaultLabelOptions.radius = this.curve.radius;
      }

      var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, defaultLabelOptions, options);

      if (optionsToUse.text === null) {
        optionsToUse.text = '';
        optionsToUse.showRealAngle = true;
      }

      this.label = new AngleLabel(this.equation, optionsToUse.text, optionsToUse.color, optionsToUse.radius, optionsToUse.curvePosition, optionsToUse.curveOffset, optionsToUse.showRealAngle, optionsToUse.units, optionsToUse.precision, optionsToUse.autoHide, optionsToUse.autoHideMax, optionsToUse.orientation, optionsToUse.scale);

      if (this.label != null) {
        this.add('label', this.label.eqn);
      } // this.updateLabel();

    }
  }, {
    key: "addCurve",
    value: function addCurve() {
      var curveOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var defaultCurveOptions = {
        width: 0.01,
        sides: 50,
        radius: 0.5,
        num: 1,
        step: 0,
        autoHideMin: null,
        autoHideMax: null
      };
      var optionsToUse = Object.assign({}, defaultCurveOptions, curveOptions);

      for (var i = 0; i < optionsToUse.num; i += 1) {
        var curve = this.shapes.polygonSweep({
          sides: optionsToUse.sides,
          radius: optionsToUse.radius + i * optionsToUse.step,
          width: optionsToUse.width,
          color: this.color,
          fill: false,
          transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('AngleCurve').rotate(0)
        });
        this.curve = optionsToUse;
        var name = 'curve';

        if (i > 0) {
          name = "".concat(name).concat(i);
        }

        this.add(name, curve);
      } // Right Angle


      if (this.autoRightAngle) {
        var right = this.shapes.collection();
        var rightLength = optionsToUse.radius * 0.707; // / Math.sqrt(2);

        right.add('line1', this.shapes.horizontalLine(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](rightLength, 0), rightLength + optionsToUse.width / 2, optionsToUse.width, Math.PI / 2, this.color));
        right.add('line2', this.shapes.horizontalLine(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, rightLength), rightLength - optionsToUse.width / 2, optionsToUse.width, 0, this.color));
        this.add('curveRight', right);
      }
    }
  }, {
    key: "change",
    value: function change(options) {
      if (this._curve != null && options.radius != null) {
        this._curve.drawingObject.update({
          radius: options.radius
        });
      }

      if (this.label != null) {
        if (options.curveRadius != null) {
          this.label.radius = options.curveRadius;
        }

        if (options.curvePosition != null) {
          this.label.curvePosition = options.curvePosition;
        }

        if (options.curveOffset != null) {
          this.label.curveOffset = options.curveOffset;
        }
      } // // this._curve.drawingObject.radius = radius;
      // // this._curve.drawingObject.makePolygon();
      // // this._curve.drawingObject.change();
      // if (curveRadius != null && this.label != null) {
      //   this.label.radius = curveRadius;
      // }
      // if (curvePosition != null && this.label != null) {
      //   this.label.curvePosition = curvePosition;
      // }

    } // pulseWidth() {
    //   const line = this._line;
    //   if (line != null) {
    //     line.stopPulsing();
    //     const oldTransformMethod = line.pulse.transformMethod;
    //     const oldPulseCallback = line.pulse.callback;
    //     const finishPulsing = () => {
    //       line.pulse.transformMethod = oldTransformMethod;
    //       line.pulse.callback = oldPulseCallback;
    //     };
    //     line.pulse.callback = finishPulsing;
    //     line.pulse.transformMethod = s => new Transform().scale(1, s);
    //     line.pulseScaleNow(1, 3);
    //   }
    //   const arrow1 = this._arrow1;
    //   const arrow2 = this._arrow2;
    //   if (arrow1 != null) {
    //     arrow1.pulseScaleNow(1, 2);
    //   }
    //   if (arrow2 != null) {
    //     arrow2.pulseScaleNow(1, 2);
    //   }
    //   const label = this._label;
    //   if (label != null) {
    //     label.pulseScaleNow(1, 1.5);
    //   }
    //   this.animateNextFrame();
    // }

  }, {
    key: "addArrow",
    value: function addArrow(index) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var defaultArrowDimension = 0.04;

      if (this.curve) {
        defaultArrowDimension = this.curve.width * 4;
      }

      var defaultArrowRadius = 0.1;

      if (this.curve) {
        defaultArrowRadius = this.curve.radius;
      }

      var defaultArrowOptions = {
        width: defaultArrowDimension,
        height: defaultArrowDimension,
        radius: defaultArrowRadius,
        autoHide: true,
        curveOverlap: 0.3
      };
      var optionsToUse = {};

      if (options != null) {
        optionsToUse = options;
      }

      var arrowOptions = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, defaultArrowOptions, optionsToUse);
      var width = arrowOptions.width,
          height = arrowOptions.height;
      var r = Math.PI / 2;

      if (index === 2) {
        r = Math.PI / 2 * 3;
      }

      var a = this.shapes.arrowLegacy(width, 0, height, 0, this.color, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().rotate(0).translate(0, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), r); // $FlowFixMe

      this["arrow".concat(index)] = arrowOptions;
      this.add("arrow".concat(index), a);
      this.update();
    }
  }, {
    key: "updateCurve",
    value: function updateCurve(primaryCurveAngle, angle, rotation, show) {
      var curve = this.curve;

      if (curve) {
        for (var i = 0; i < curve.num; i += 1) {
          var name = '_curve';

          if (i > 0) {
            name = "_curve".concat(i);
          } // $FlowFixMe


          var element = this[name]; // console.log(element)

          if (element) {
            if (show) {
              element.show();

              if (i === 0) {
                var delta = 0;

                if (this.curve) {
                  delta = primaryCurveAngle % (2 * Math.PI / this.curve.sides);
                }

                element.angleToDraw = primaryCurveAngle;
                element.transform.updateRotation(rotation + delta / 2);
              } else {
                var _delta = 0;

                if (this.curve) {
                  _delta = angle % (2 * Math.PI / this.curve.sides);
                }

                element.angleToDraw = angle;
                element.transform.updateRotation(_delta / 2);
              }
            } else {
              element.hide();
            }
          }
        }
      }
    }
  }, {
    key: "update",
    value: function update() {
      var labelRotationOffset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var _arrow1 = this._arrow1,
          arrow1 = this.arrow1;
      var _arrow2 = this._arrow2,
          arrow2 = this.arrow2;
      var arrow1Hide = false;
      var arrow2Hide = false;
      var rotationForArrow1 = 0;
      var curveAngle = this.angle;
      var trueCurveAngle = this.angle; // const arrow2LengthModifier = 0.5;
      // const arrowLengthMod = 0.9;

      var arrow1Angle = 0;
      var arrow2Angle = 0;

      if (arrow1 && this.arrow1) {
        arrow1Angle = arrow1.height / arrow1.radius * (1 - this.arrow1.curveOverlap);
        curveAngle -= arrow1Angle;
        trueCurveAngle -= arrow1.height / arrow1.radius;
      }

      if (arrow2 && this.arrow2) {
        arrow2Angle = arrow2.height / arrow2.radius * (1 - this.arrow2.curveOverlap);
        curveAngle -= arrow2Angle;
        trueCurveAngle -= arrow2.height / arrow2.radius;
      }

      if (trueCurveAngle < 0) {
        if (arrow1 && arrow1.autoHide) {
          arrow1Hide = true;
          trueCurveAngle += arrow1.height / arrow1.radius;
          curveAngle += arrow1Angle;
        }

        if (arrow2 && arrow2.autoHide) {
          arrow2Hide = true;
          trueCurveAngle += arrow2.height / arrow2.radius;
          curveAngle += arrow2Angle;
        }
      }

      if (_arrow1 && arrow1) {
        if (arrow1Hide) {
          _arrow1.hide();
        } else {
          _arrow1.show();

          _arrow1.transform.updateTranslation(arrow1.radius, 0);

          var arrowLengthAngle = arrow1.height / arrow1.radius;

          _arrow1.transform.updateRotation(Math.PI / 2 + arrowLengthAngle);

          rotationForArrow1 = arrow1Angle;
        }
      }

      if (_arrow2 && arrow2) {
        if (arrow2Hide) {
          _arrow2.hide();
        } else {
          _arrow2.show();

          _arrow2.transform.updateTranslation(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(arrow2.radius, this.angle));

          var _arrowLengthAngle = arrow2.height / arrow2.radius;

          _arrow2.transform.updateRotation(this.angle + Math.PI / 2 - _arrowLengthAngle); // curveAngle += arrowLengthAngle * (1 - arrow2LengthModifier);

        }
      }

      if (labelRotationOffset != null) {
        this.lastLabelRotationOffset = labelRotationOffset;
      }

      this.setNextPositionAndRotation(); // this.transform.updateTranslation(this.position);
      // this.transform.updateRotation(this.rotation);

      var _curve = this._curve,
          curve = this.curve,
          _curveRight = this._curveRight;

      if (_curve != null && curve != null) {
        if (curve.autoHideMin != null && this.angle < curve.autoHideMin || curve.autoHideMax != null && this.angle > curve.autoHideMax) {
          if (_curveRight != null) {
            _curveRight.hide();
          }

          _curve.hide();

          if (_arrow1 != null) {
            _arrow1.hide();
          }

          if (_arrow2 != null) {
            _arrow2.hide();
          }
        } else if (this.autoRightAngle && this.angle >= Math.PI / 2 - this.rightAngleRange / 2 && this.angle <= Math.PI / 2 + this.rightAngleRange / 2) {
          if (_curveRight != null) {
            _curveRight.showAll();
          }

          _curve.hide();

          if (_arrow1 != null) {
            _arrow1.hide();
          }

          if (_arrow2 != null) {
            _arrow2.hide();
          }
        } else {
          if (_curveRight != null) {
            _curveRight.hide();
          }

          if (_arrow1 != null && arrow1Hide === false) {
            _arrow1.show();
          }

          if (_arrow2 != null && arrow2Hide === false) {
            _arrow2.show();
          } // _curve.show();


          curveAngle = Math.max(curveAngle, 0); // _curve.angleToDraw = curveAngle;
          // _curve.transform.updateRotation(rotationForArrow1);

          this.updateCurve(curveAngle, this.angle, rotationForArrow1, true);
        }
      } // const { _label, label } = this;
      // if (_label && label) {
      //   if (label.autoHide > this.angle) {
      //     _label.hide();
      //   } else {
      //     _label.show();
      //     if (label.showRealAngle) {
      //       let angleText = roundNum(this.angle, label.precision)
      //         .toFixed(label.precision);
      //       if (label.units === 'degrees') {
      //         angleText = roundNum(
      //           this.angle * 180 / Math.PI,
      //           label.precision,
      //         ).toFixed(label.precision);
      //         angleText = `${angleText}`;
      //       }
      //       label.setText(angleText);
      //       // _label._base.drawingObject.setText(`${angleText}`);
      //       // label.eqn.reArrangeCurrentForm();
      //     }
      //     const labelPosition = polarToRect(label.radius, this.angle * label.curvePosition);
      //     if (label.orientation === 'horizontal') {
      //       label.updateRotation(
      //         -this.rotation - this.lastLabelRotationOffset,
      //         labelPosition,
      //         label.radius / 5,
      //         this.angle * label.curvePosition,
      //       );
      //     }
      //     if (label.orientation === 'tangent') {
      //       label.updateRotation(
      //         this.angle * label.curvePosition - Math.PI / 2,
      //         labelPosition,
      //         label.radius / 50,
      //         this.angle * label.curvePosition,
      //       );
      //     }
      //   }
      // }


      this.updateLabel();
      var _side1 = this._side1,
          side1 = this.side1;

      if (_side1 && side1) {
        // _side1.transform.updateRotation(this.rotation);
        _side1.transform.updateScale(side1.length, 1);
      }

      var _side2 = this._side2,
          side2 = this.side2;

      if (_side2 && side2) {
        _side2.transform.updateRotation(this.angle);

        _side2.transform.updateScale(side2.length, 1);
      }
    }
  }, {
    key: "checkLabelForRightAngle",
    value: function checkLabelForRightAngle() {
      if (this.autoRightAngle === false) {
        return;
      }

      var label = this.label;
      var setRight = false;

      if (label != null) {
        var angle = parseFloat(label.getText());

        if (angle === 90) {
          setRight = true;
        }
      }

      if (setRight === false) {
        return;
      }

      var _curveRight = this._curveRight,
          _curve = this._curve,
          _arrow1 = this._arrow1,
          _arrow2 = this._arrow2;

      if (_curveRight != null) {
        _curveRight.showAll();
      }

      if (_curve != null) {
        _curve.hide();
      }

      if (_arrow1 != null) {
        _arrow1.hide();
      }

      if (_arrow2 != null) {
        _arrow2.hide();
      }
    }
  }, {
    key: "getAngle",
    value: function getAngle() {
      var units = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'rad';

      if (units === 'deg') {
        return this.angle * 180 / Math.PI;
      }

      return this.angle;
    }
  }, {
    key: "setLabel",
    value: function setLabel(text) {
      var label = this.label;

      if (label != null) {
        label.setText(text);
        label.showRealAngle = false;
      }

      this.updateLabel();
    }
  }, {
    key: "getLabel",
    value: function getLabel() {
      if (this.label != null) {
        return this.label.getText();
      }

      return '';
    }
  }, {
    key: "setLabelToRealAngle",
    value: function setLabelToRealAngle() {
      var label = this.label;

      if (label != null) {
        label.showRealAngle = true;
      }

      this.updateLabel();
    }
  }, {
    key: "updateLabel",
    value: function updateLabel() {
      var rotationOffset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (rotationOffset != null) {
        this.lastLabelRotationOffset = rotationOffset;
      }

      var _label = this._label,
          label = this.label;

      if (_label && label) {
        if (label.autoHide != null && label.autoHide > this.angle || label.autoHideMax != null && this.angle > label.autoHideMax) {
          _label.hide();
        } else {
          _label.show();

          if (label.showRealAngle) {
            var angleText = Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["roundNum"])(this.angle, label.precision).toFixed(label.precision);

            if (label.units === 'degrees') {
              var a = Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["roundNum"])(this.angle * 180 / Math.PI, label.precision);

              if (a === 360) {
                a = 0;
              }

              angleText = a.toFixed(label.precision);
              angleText = "".concat(angleText, "\xBA");
            }

            label.setText(angleText); // _label._base.drawingObject.setText(`${angleText}`);
            // label.eqn.reArrangeCurrentForm();
          }

          var labelPosition = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(label.radius, this.angle * label.curvePosition + label.curveOffset);

          if (label.orientation === 'horizontal') {
            label.updateRotation(-this.getRotation() - this.lastLabelRotationOffset, labelPosition, label.radius / 5, this.angle * label.curvePosition + label.curveOffset);
          }

          if (label.orientation === 'tangent') {
            label.updateRotation(this.angle * label.curvePosition + label.curveOffset - Math.PI / 2, labelPosition, label.radius / 50, this.angle * label.curvePosition + label.curveOffset);
          }
        }
      }
    }
  }, {
    key: "showAll",
    value: function showAll() {
      _get(_getPrototypeOf(DiagramObjectAngle.prototype), "showAll", this).call(this);

      this.update();
    }
  }]);

  return DiagramObjectAngle;
}(_Element__WEBPACK_IMPORTED_MODULE_3__["DiagramElementCollection"]);

/* harmony default export */ __webpack_exports__["default"] = (DiagramObjectAngle);

/***/ }),

/***/ "./src/js/diagram/DiagramObjects/DiagramObjects.js":
/*!*********************************************************!*\
  !*** ./src/js/diagram/DiagramObjects/DiagramObjects.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DiagramObjects; });
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _DrawContext2D__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../DrawContext2D */ "./src/js/diagram/DrawContext2D.js");
/* harmony import */ var _Line__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Line */ "./src/js/diagram/DiagramObjects/Line.js");
/* harmony import */ var _Angle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Angle */ "./src/js/diagram/DiagramObjects/Angle.js");
/* harmony import */ var _PolyLine__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./PolyLine */ "./src/js/diagram/DiagramObjects/PolyLine.js");
/* harmony import */ var _EquationLabel__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./EquationLabel */ "./src/js/diagram/DiagramObjects/EquationLabel.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }



 // import {
//   DiagramElementCollection,
// } from '../Element';

 // import EquationNavigator from './EquationNavigator';


 // eslint-disable-next-line import/no-cycle




var DiagramObjects =
/*#__PURE__*/
function () {
  function DiagramObjects(shapes, equation, isTouchDevice, animateNextFrame) {
    _classCallCheck(this, DiagramObjects);

    this.webgl = shapes.webgl;
    this.draw2D = shapes.draw2D;
    this.limits = shapes.limits;
    this.shapes = shapes;
    this.isTouchDevice = isTouchDevice;
    this.animateNextFrame = animateNextFrame;
    this.equation = equation;
  }

  _createClass(DiagramObjects, [{
    key: "line",
    value: function line() {
      for (var _len = arguments.length, options = new Array(_len), _key = 0; _key < _len; _key++) {
        options[_key] = arguments[_key];
      }

      // const optionsToUse = Object.assign({}, ...options);
      // console.log(Object.assign({}, ...options))
      var optionsToUse = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}].concat(options));
      return new _Line__WEBPACK_IMPORTED_MODULE_4__["default"](this.shapes, this.equation, this.isTouchDevice, this.animateNextFrame, optionsToUse);
    }
  }, {
    key: "angle",
    value: function angle() {
      for (var _len2 = arguments.length, options = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        options[_key2] = arguments[_key2];
      }

      var optionsToUse = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}].concat(options));
      return new _Angle__WEBPACK_IMPORTED_MODULE_5__["default"](this.shapes, this.equation, this.isTouchDevice, this.animateNextFrame, optionsToUse);
    }
  }, {
    key: "label",
    value: function label() {
      for (var _len3 = arguments.length, options = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        options[_key3] = arguments[_key3];
      }

      // const optionsToUse = Object.assign({}, ...options);
      var optionsToUse = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}].concat(options));
      return new _EquationLabel__WEBPACK_IMPORTED_MODULE_7__["default"](this.equation, optionsToUse);
    }
  }, {
    key: "polyline",
    value: function polyline() {
      for (var _len4 = arguments.length, options = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        options[_key4] = arguments[_key4];
      }

      var optionsToUse = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}].concat(options));
      return new _PolyLine__WEBPACK_IMPORTED_MODULE_6__["default"](this.shapes, this.equation, this, this.isTouchDevice, this.animateNextFrame, optionsToUse);
    }
  }]);

  return DiagramObjects;
}();



/***/ }),

/***/ "./src/js/diagram/DiagramObjects/EqnNavigator.js":
/*!*******************************************************!*\
  !*** ./src/js/diagram/DiagramObjects/EqnNavigator.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EqnNavigator; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _DiagramElements_Equation_EquationForm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../DiagramElements/Equation/EquationForm */ "./src/js/diagram/DiagramElements/Equation/EquationForm.js");
/* harmony import */ var _tools_htmlGenerator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../tools/htmlGenerator */ "./src/js/tools/htmlGenerator.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _DiagramElements_Equation_Equation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../DiagramElements/Equation/Equation */ "./src/js/diagram/DiagramElements/Equation/Equation.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }






 // eslint-disable-next-line no-use-before-define
// export type TypeEquationNavigator = EquationNavigator;

function updateDescription(eqn, subForm, descriptionElement, index) {
  var setClicks = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  var prefix = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : '';
  var element = descriptionElement;

  if (element == null) {
    return;
  }

  var form = null; // $FlowFixMe
  // form = eqn.eqn.formSeries[index][formType];
  // form = eqn.getForm(eqn.eqn.currentFormSeries[index], subForm);

  form = eqn.getCurrentForm();

  if (form == null) {
    return;
  }

  if (form.description == null) {
    if (element != null) {
      element.innerHTML = '';
    }

    return;
  }

  var monochrome = !setClicks;

  if (descriptionElement) {
    if (setClicks) {
      // eslint-disable-next-line no-param-reassign
      descriptionElement.innerHTML = _tools_htmlGenerator__WEBPACK_IMPORTED_MODULE_3__["applyModifiers"]("".concat(prefix).concat(form.description), form.modifiers);
      _tools_htmlGenerator__WEBPACK_IMPORTED_MODULE_3__["setOnClicks"](form.modifiers);
    } else {
      // eslint-disable-next-line no-param-reassign
      descriptionElement.innerHTML = _tools_htmlGenerator__WEBPACK_IMPORTED_MODULE_3__["applyModifiers"]("".concat(prefix).concat(form.description), form.modifiers, '', monochrome);
    }
  }
}

function enableTouch(element) {
  if (element) {
    element.classList.remove('figureone__eqn_nav__not_touchable');
  }
}

function disableTouch(element) {
  if (element) {
    element.classList.add('figureone__eqn_nav__not_touchable');
  }
}

function _updateButtons( // eslint-disable-next-line no-use-before-define
nav) {
  var includeNextPrevPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var nextPrefix = '';
  var prevPrefix = '';

  if (includeNextPrevPrefix) {
    nextPrefix = 'NEXT: ';
    prevPrefix = 'PREV: ';
  }

  var currentForm = nav.eqn.getCurrentForm();

  if (currentForm != null) {
    var index = nav.eqn.getFormIndex(currentForm);

    if (index === 0) {
      disableTouch(nav.refresh);
      disableTouch(nav.prev);
      disableTouch(nav.prevDescription);
      disableTouch(nav.description); // enableTouch(nav.nextDescription, true);
    } else {
      enableTouch(nav.refresh);
      enableTouch(nav.prev);
      enableTouch(nav.prevDescription);
      enableTouch(nav.description);
    }

    if (nav.eqn.eqn.currentFormSeries.length > 1) {
      enableTouch(nav.next);
      enableTouch(nav.nextDescription);

      if (nav.navType === '1Button') {
        enableTouch(nav.description);
      }
    } else {
      disableTouch(nav.next);
      disableTouch(nav.nextDescription);

      if (nav.navType === '1Button') {
        var next = nav.next;

        if (next) {
          next.classList.remove('figureone__eqn_nav__next_form');
          next.classList.remove('figureone__eqn_nav__reset');
          next.classList.remove('interactive_top_right');
        }
      }
    }

    var nextIndex = index + 1;

    if (nextIndex > nav.eqn.eqn.currentFormSeries.length - 1) {
      if (nav.nextDescription) {
        // eslint-disable-next-line no-param-reassign
        nav.nextDescription.innerHTML = 'RESTART from begining';
      }

      if (nav.navType === '1Button' && nav.eqn.eqn.currentFormSeries.length > 1) {
        var _next = nav.next;

        if (_next) {
          _next.classList.add('figureone__eqn_nav__reset');

          _next.classList.remove('figureone__eqn_nav__next_form');
        }
      }
    } else {
      updateDescription(nav.eqn, currentForm.subForm, nav.nextDescription, nextIndex, false, nextPrefix);

      if (nav.navType === '1Button' && nav.eqn.eqn.currentFormSeries.length > 1) {
        var _next2 = nav.next;

        if (_next2) {
          _next2.classList.add('figureone__eqn_nav__next_form');

          _next2.classList.remove('figureone__eqn_nav__reset');
        }
      }
    }

    updateDescription(nav.eqn, currentForm.subForm, nav.description, index, true); // nav.eqn.updateDescription(currentForm);

    var prevIndex = index - 1;

    if (prevIndex >= 0) {
      updateDescription(nav.eqn, currentForm.subForm, nav.prevDescription, prevIndex, false, prevPrefix);
    } else if (nav.prevDescription) {
      // eslint-disable-next-line no-param-reassign
      nav.prevDescription.innerHTML = '';
    }
  }
} // eslint-disable-next-line no-use-before-define


function updateButtonsDescriptionOnly(nav) {
  var currentForm = nav.eqn.getCurrentForm();

  if (currentForm != null) {
    var index = nav.eqn.getFormIndex(currentForm);
    enableTouch(nav.description);
    updateDescription(nav.eqn, currentForm.subForm, nav.description, index, true);
  }
}

// Nav3Line
function makeType3Line(prevMethod, refreshMethod, nextMethod, options) {
  var table = document.createElement('table');
  var prevGroup = document.createElement('tr');
  var currentGroup = document.createElement('tr');
  var nextGroup = document.createElement('tr');
  var prev = document.createElement('td');
  var refresh = document.createElement('td');
  var next = document.createElement('td');
  var prevDescription = document.createElement('td');
  var description = document.createElement('td');
  var nextDescription = document.createElement('td');
  prevGroup.appendChild(prev);
  prevGroup.appendChild(prevDescription);
  nextGroup.appendChild(next);
  nextGroup.appendChild(nextDescription);
  currentGroup.appendChild(refresh);
  currentGroup.appendChild(description);
  table.appendChild(prevGroup);
  table.appendChild(currentGroup);
  table.appendChild(nextGroup);
  table.classList.add('figureone__eqn_nav__table');
  prevGroup.classList.add('figureone__eqn_nav__3line__prevRow');
  currentGroup.classList.add('figureone__eqn_nav__3line__currentRow');
  nextGroup.classList.add('figureone__eqn_nav__3line__nextRow');
  prev.classList.add('figureone__eqn_nav__3line__prevRow__button');
  refresh.classList.add('figureone__eqn_nav__3line__currentRow__button');
  next.classList.add('figureone__eqn_nav__3line__nextRow__button');
  prevDescription.classList.add('figureone__eqn_nav__3line__prevRow__description');
  description.classList.add('figureone__eqn_nav__3line__currentRow__description');
  description.classList.add('figureone__eqn_nav__description');
  nextDescription.classList.add('figureone__eqn_nav__3line__nextRow__description');
  var defaultOptions = {
    forceTwoLines: false,
    arrows: false
  };
  var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_4__["joinObjects"])({}, defaultOptions, options); // if (!Array.isArray(options)) {
  //   optionsToUse = [options];
  // }
  // Use two lines to stop jittering when transitioning from one line to two
  // lines

  if (optionsToUse.forceTwoLines) {
    prevGroup.classList.add('figureone__eqn_nav__3line__prev_twoLines');
    currentGroup.classList.add('figureone__eqn_nav__3line__current_twoLines');
    nextGroup.classList.add('figureone__eqn_nav__3line__next_twoLines');
  }

  prevGroup.onclick = prevMethod;
  currentGroup.onclick = refreshMethod;
  nextGroup.onclick = nextMethod;
  next.innerHTML = 'Next';
  prev.innerHTML = 'Prev';
  refresh.innerHTML = 'Refresh';
  return {
    table: table,
    prevGroup: prevGroup,
    currentGroup: currentGroup,
    nextGroup: nextGroup,
    prev: prev,
    refresh: refresh,
    next: next,
    prevDescription: prevDescription,
    description: description,
    nextDescription: nextDescription
  };
} // NavDescriptionOnly


function makeTypeDescriptionOnly(nextMethod) {
  var table = document.createElement('table');
  var currentGroup = document.createElement('tr');
  var description = document.createElement('td');
  currentGroup.appendChild(description);
  table.appendChild(currentGroup);
  table.classList.add('figureone__eqn_nav__table');
  currentGroup.classList.add('figureone__eqn_nav__description_only__currentRow');
  description.classList.add('figureone__eqn_nav__description_only__currentRow__description');
  description.classList.add('figureone__eqn_nav__description');
  currentGroup.onclick = nextMethod;
  return {
    table: table,
    currentGroup: currentGroup,
    description: description
  };
} // Nav1Button


function makeTypeOneButton(nextMethod) // options: TypeNavTypeOptions,  // can be: 'twoLines'
{
  var table = document.createElement('table');
  var currentGroup = document.createElement('tr');
  var next = document.createElement('td');
  var description = document.createElement('td');
  currentGroup.appendChild(next);
  currentGroup.appendChild(description);
  table.appendChild(currentGroup);
  table.classList.add('figureone__eqn_nav__table');
  currentGroup.classList.add('figureone__eqn_nav__1button__currentRow');
  next.classList.add('figureone__eqn_nav__1button__button');
  description.classList.add('figureone__eqn_nav__1line__currentRow__description');
  description.classList.add('figureone__eqn_nav__description');
  next.classList.add('interactive_top_right'); // const defaultOptions = {
  //   icons: true,
  // };
  // const optionsToUse = joinObjects({}, defaultOptions, options);

  next.onclick = nextMethod;
  description.onclick = nextMethod; // if (optionsToUse.icons) {

  next.classList.add('figureone__eqn_nav__next_form'); // }

  return {
    table: table,
    currentGroup: currentGroup,
    next: next,
    description: description
  };
} // Nav1Line


function makeType1Line(prevMethod, refreshMethod, nextMethod, options) // can be: 'twoLines'
{
  var table = document.createElement('table');
  var currentGroup = document.createElement('tr');
  var prev = document.createElement('td');
  var next = document.createElement('td');
  var description = document.createElement('td');
  currentGroup.appendChild(prev);
  currentGroup.appendChild(description);
  currentGroup.appendChild(next);
  table.appendChild(currentGroup);
  table.classList.add('figureone__eqn_nav__table');
  currentGroup.classList.add('figureone__eqn_nav__1line__currentRow');
  prev.classList.add('figureone__eqn_nav__1line__prev__button');
  next.classList.add('figureone__eqn_nav__1line__next__button');
  description.classList.add('figureone__eqn_nav__1line__currentRow__description');
  description.classList.add('figureone__eqn_nav__description');
  var defaultOptions = {
    forceTwoLines: false,
    arrows: false
  };
  var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_4__["joinObjects"])({}, defaultOptions, options); // Use two lines to stop jittering when transitioning from one line to two
  // lines

  if (optionsToUse.forceTwoLines) {
    currentGroup.classList.add('figureone__eqn_nav__1line__current_twoLines');
  }

  prev.onclick = prevMethod;
  description.onclick = refreshMethod;
  next.onclick = nextMethod;

  if (optionsToUse.arrows) {
    var nextArrow = document.createElement('div');
    nextArrow.classList.add('figureone__eqn_nav__arrow_right');
    next.appendChild(nextArrow);
    var prevArrow = document.createElement('div');
    prevArrow.classList.add('figureone__eqn_nav__arrow_left');
    prev.appendChild(prevArrow);
  } else {
    next.innerHTML = 'Next';
    prev.innerHTML = 'Prev';
  }

  return {
    table: table,
    currentGroup: currentGroup,
    prev: prev,
    next: next,
    description: description
  };
} // Nav2Line


function makeType2Line(prevMethod, refreshMethod, nextMethod, options) {
  var table = document.createElement('table');
  var row = document.createElement('tr');
  var descriptionRows = document.createElement('tr');
  var currentGroup = document.createElement('tr');
  var prev = document.createElement('td');
  var next = document.createElement('td');
  var nextGroup = document.createElement('tr'); // const descriptionRows = document.createElement('td');
  // const descriptionRow = document.createElement('tr');
  // const nextDescriptionRow = document.createElement('tr');

  var description = document.createElement('td');
  var nextDescription = document.createElement('td');
  currentGroup.appendChild(description);
  nextGroup.appendChild(nextDescription);
  descriptionRows.appendChild(currentGroup);
  descriptionRows.appendChild(nextGroup);
  row.appendChild(prev);
  row.appendChild(descriptionRows);
  row.appendChild(next);
  table.appendChild(row);
  table.classList.add('figureone__eqn_nav__table');
  currentGroup.classList.add('figureone__eqn_nav__2lines__currentRow');
  nextGroup.classList.add('figureone__eqn_nav__2lines__nextRow');
  prev.classList.add('figureone__eqn_nav__2lines__prev__button');
  next.classList.add('figureone__eqn_nav__2lines__next__button');
  description.classList.add('figureone__eqn_nav__2lines__currentRow__description');
  description.classList.add('figureone__eqn_nav__description');
  nextDescription.classList.add('figureone__eqn_nav__2lines__nextRow__description');
  var defaultOptions = {
    forceTwoLines: false,
    arrows: false
  };
  var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_4__["joinObjects"])({}, defaultOptions, options); // Use two lines to stop jittering when transitioning from one line to two
  // lines

  if (optionsToUse.forceTwoLines > -1) {
    currentGroup.classList.add('figureone__eqn_nav__2lines__current_twoLines');
  }

  prev.onclick = prevMethod;
  description.onclick = refreshMethod;
  next.onclick = nextMethod;
  nextDescription.onclick = nextMethod;

  if (optionsToUse.arrows) {
    var nextArrow = document.createElement('div');
    nextArrow.classList.add('figureone__eqn_nav__arrow_right');
    next.appendChild(nextArrow);
    var prevArrow = document.createElement('div');
    prevArrow.classList.add('figureone__eqn_nav__arrow_left');
    prev.appendChild(prevArrow);
  } else {
    next.innerHTML = 'Next';
    prev.innerHTML = 'Prev';
  }

  return {
    table: table,
    currentGroup: currentGroup,
    nextGroup: nextGroup,
    prev: prev,
    next: next,
    nextDescription: nextDescription,
    description: description
  };
}

// A Navigator is a DiagramElementCollection that is a html table that has
// the possible html elements of:
//   next: a next form button
//   prev: a prev form button
//   refresh: a button that shows animation to current form again
//   description: description of current form
//   nextDescription: description of next form
//   prevDescription: description of prev form
//   nextGroup: a html parent that holds nextDescription and nextButton
//   prevGroup: a html parent that holds prevDescription and prevButton
//
// Equation navigators
var EqnNavigator =
/*#__PURE__*/
function (_DiagramElementCollec) {
  _inherits(EqnNavigator, _DiagramElementCollec);

  // setEquation: (Equation) => void;
  function EqnNavigator(shapes, // eqn: Equation,
  animateNextFrame) {
    var _this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, EqnNavigator);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(EqnNavigator).call(this, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('Eqn Nav').scale(1, 1).translate(0, 0), shapes.limits)); // super(shapes, eqnOptions);

    _this.shapes = shapes; // this.setEquation(equation);

    _this.prev = null;
    _this.next = null;
    _this.refresh = null;
    _this.description = null;
    _this.nextDescription = null;
    _this.prevDescription = null;
    _this.table = null;
    _this.prevGroup = null;
    _this.currentGroup = null;
    _this.nextGroup = null;
    _this.animateNextFrame = animateNextFrame;
    var defaultOptions = {
      offset: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
      navType: 'twoLine',
      navTypeOptions: {
        forceTwoLines: false,
        arrows: false
      },
      xAlign: 'center',
      yAlign: 'middle',
      interactive: true,
      id: Object(_tools_tools__WEBPACK_IMPORTED_MODULE_4__["generateUniqueId"])('id_figureone__equation_navigator_')
    };
    var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_4__["joinObjects"])({}, defaultOptions, options);
    _this.options = optionsToUse;

    if (optionsToUse.equation != null) {
      // this.eqn = optionsToUse.equation;
      // this.eqn.onClick = this.clickNext.bind(this);
      // this.eqn.hasTouchableElements = true;
      // this.eqn.isTouchable = true;
      // this.eqn.touchInBoundingRect = true;
      _this.connectToEquation(optionsToUse.equation, optionsToUse.interactive);
    }

    _this.navType = optionsToUse.navType;
    var navigatorHTMLElement = null;

    if (_this.navType === '3Line') {
      navigatorHTMLElement = makeType3Line(_this.clickPrev.bind(_assertThisInitialized(_this)), _this.clickRefresh.bind(_assertThisInitialized(_this)), _this.clickNext.bind(_assertThisInitialized(_this)), optionsToUse.navTypeOptions);
    }

    if (_this.navType === 'description') {
      navigatorHTMLElement = makeTypeDescriptionOnly(_this.clickNext.bind(_assertThisInitialized(_this)));
    }

    if (_this.navType === '1Line') {
      navigatorHTMLElement = makeType1Line(_this.clickPrev.bind(_assertThisInitialized(_this)), _this.clickRefresh.bind(_assertThisInitialized(_this)), _this.clickNext.bind(_assertThisInitialized(_this)), optionsToUse.navTypeOptions);
    }

    if (_this.navType === '1Button') {
      navigatorHTMLElement = makeTypeOneButton(_this.clickNext.bind(_assertThisInitialized(_this)) // optionsToUse.navTypeOptions,
      );
    }

    if (_this.navType === '2Line') {
      navigatorHTMLElement = makeType2Line(_this.clickPrev.bind(_assertThisInitialized(_this)), _this.clickRefresh.bind(_assertThisInitialized(_this)), _this.clickNext.bind(_assertThisInitialized(_this)), optionsToUse.navTypeOptions);
    } // const eqnCollectionPosition = this.eqn.getPosition();


    if (navigatorHTMLElement != null) {
      var offsetToUse = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["parsePoint"])(optionsToUse.offset, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0));
      Object.assign(_assertThisInitialized(_this), navigatorHTMLElement);

      var table = _this.shapes.htmlElement(navigatorHTMLElement.table, "".concat(optionsToUse.id, "_table"), '', offsetToUse, optionsToUse.yAlign, optionsToUse.xAlign);

      _this.add('table', table);
    }

    return _this;
  }

  _createClass(EqnNavigator, [{
    key: "connectToEquation",
    value: function connectToEquation(eqn, interactive) {
      this.eqn = eqn;

      if (interactive) {
        this.eqn.onClick = this.clickNext.bind(this);
        this.eqn.hasTouchableElements = true;
        this.eqn.isTouchable = true;
        this.eqn.touchInBoundingRect = true;
      } // this.setTransformCallback = () => {
      //   const p = this.getPosition();
      //   this.eqn.setPosition(p);
      // }

    } // const navigator = shapes.collection(;
    // setEquation(eqn: Equation) {
    //   this.eqn = eqn;
    //   // this._eqn = [];
    //   this.add('eqn', eqn.collection);
    // }
    // setWidth(width) {
    // }

  }, {
    key: "clickNext",
    value: function clickNext() {
      this.eqn.nextForm(1.5);
      this.updateButtons();
      this.animateNextFrame();
    }
  }, {
    key: "clickPrev",
    value: function clickPrev() {
      this.eqn.prevForm(1.5);
      this.updateButtons();
      this.animateNextFrame();
    }
  }, {
    key: "clickRefresh",
    value: function clickRefresh() {
      var currentForm = this.eqn.getCurrentForm();

      if (currentForm != null) {
        var index = this.eqn.getFormIndex(currentForm);

        if (index > 0) {
          this.eqn.replayCurrentForm(1.5);
          this.animateNextFrame();
        }
      }

      this.updateButtons();
    }
  }, {
    key: "updateButtons",
    value: function updateButtons() {
      if (this.navType === 'equationOnly') {
        return;
      }

      if (this.navType === 'description') {
        updateButtonsDescriptionOnly(this);
      } else if (this.navType === '2Line') {
        _updateButtons(this, true);
      } else {
        _updateButtons(this);
      }
    }
  }, {
    key: "showForm",
    value: function showForm(formOrName) {
      var formType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      this.show();
      this.eqn.showForm(formOrName, formType); // this.showForm(formOrName, formType);

      if (this._table) {
        this._table.show();

        this.updateButtons();
      }
    }
  }]);

  return EqnNavigator;
}(_Element__WEBPACK_IMPORTED_MODULE_1__["DiagramElementCollection"]);



/***/ }),

/***/ "./src/js/diagram/DiagramObjects/EquationLabel.js":
/*!********************************************************!*\
  !*** ./src/js/diagram/DiagramObjects/EquationLabel.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EquationLabel; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _DiagramElements_Equation_Equation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../DiagramElements/Equation/Equation */ "./src/js/diagram/DiagramElements/Equation/Equation.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// import Diagram from '../Diagram';


 // export type TypeEquationLabel = {
//   eqn: Equation;
//   updateRotation: (number, Point, number, number) => void;
//   setText: (string) => {};
//   getText: void => string;
//   // updateScale: (Point) => void;
// };

var EquationLabel =
/*#__PURE__*/
function () {
  function EquationLabel(equations) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, EquationLabel);

    var defaultOptions = {
      label: '',
      color: [0, 0, 1, 1],
      scale: 0.7,
      position: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
      form: '0',
      formType: 'base',
      xAlign: 'center',
      yAlign: 'middle'
    };
    var optionsToUse = Object.assign({}, defaultOptions, options);
    var labelTextOrEquation = optionsToUse.label;
    var color = optionsToUse.color,
        scale = optionsToUse.scale,
        position = optionsToUse.position;
    var form = optionsToUse.form,
        formType = optionsToUse.formType;
    var yAlign = optionsToUse.yAlign,
        xAlign = optionsToUse.xAlign;
    var eqn;

    if (typeof labelTextOrEquation === 'string') {
      eqn = equations.equation({
        elements: {
          base: labelTextOrEquation
        },
        color: color,
        defaultFormAlignment: {
          fixTo: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
          xAlign: xAlign,
          yAlign: yAlign
        },
        scale: scale,
        forms: {
          base: ['base']
        },
        position: position
      });
      eqn.setCurrentForm('base');
    } else if (labelTextOrEquation instanceof _DiagramElements_Equation_Equation__WEBPACK_IMPORTED_MODULE_1__["Equation"]) {
      eqn = labelTextOrEquation;
    } else if (Array.isArray(labelTextOrEquation)) {
      var elements = {};
      var forms = {};
      labelTextOrEquation.forEach(function (labelText, index) {
        elements["_".concat(index)] = labelText;
        forms[index] = [labelText];
      });
      eqn = equations.equation({
        elements: elements,
        forms: forms,
        color: color,
        position: position,
        defaultFormAlignment: {
          fixTo: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
          xAlign: xAlign,
          yAlign: yAlign
        },
        scale: scale
      });
      eqn.setCurrentForm(form, formType);
    } else {
      var defaultEqnOptions = {
        color: color
      };
      eqn = equations.equation(Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])(defaultEqnOptions, labelTextOrEquation));
    }

    this.eqn = eqn;
  } // TODO
  // setEqn() {
  // }


  _createClass(EquationLabel, [{
    key: "setText",
    value: function setText(text) {
      var form = this.eqn.getCurrentForm();

      if (form != null) {
        var key = Object.keys(form.elements)[0]; // This is ok to fix for flow because all the elements of the
        // simple equation created by Equationlabel will be Primitives
        // $FlowFixMe

        var textObject = form.elements[key].drawingObject;

        if (textObject != null) {
          textObject.setText(text);
        }

        form.arrange(this.eqn.eqn.scale, this.eqn.eqn.defaultFormAlignment.xAlign, this.eqn.eqn.defaultFormAlignment.yAlign, this.eqn.eqn.defaultFormAlignment.fixTo);
      }
    }
  }, {
    key: "getText",
    value: function getText() {
      var textToReturn = '';
      var form = this.eqn.getCurrentForm();

      if (form != null) {
        var key = Object.keys(form.elements)[0]; // This is ok to fix for flow because all the elements of the
        // simple equation created by Equationlabel will be Primitives
        // $FlowFixMe

        var textObject = form.elements[key].drawingObject; // This is ok to fix for flow because all the elements of the
        // simple equation created by Equationlabel will be Primitives
        // that are text objects

        if (textObject != null) {
          // $FlowFixMe
          textToReturn = textObject.text[0].text;
        }
      }

      return textToReturn;
    }
  }, {
    key: "updateRotation",
    value: function updateRotation(labelAngle, position) {
      var offsetMag = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var offsetAngle = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

      if (offsetMag !== 0) {
        var labelWidth = 0;
        var labelHeight = 0;
        var currentForm = this.eqn.getCurrentForm();

        if (currentForm != null) {
          labelWidth = currentForm.width / 2 + 0.04;
          labelHeight = currentForm.height / 2 + 0.04;
        }

        var a = labelWidth + offsetMag;
        var b = labelHeight + offsetMag;
        var r = a * b / Math.sqrt(Math.pow(b * Math.cos(labelAngle - offsetAngle), 2) + Math.pow(a * Math.sin(labelAngle - offsetAngle), 2));
        this.eqn.setPosition(position.add(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(r, offsetAngle)));
      } else {
        this.eqn.setPosition(position);
      }

      this.eqn.transform.updateRotation(labelAngle);
    } // const label = {
    //   eqn,
    //   updateRotation,
    //   setText,
    //   getText,
    //   // updateScale,
    // };
    // return label;

  }]);

  return EquationLabel;
}();



/***/ }),

/***/ "./src/js/diagram/DiagramObjects/Line.js":
/*!***********************************************!*\
  !*** ./src/js/diagram/DiagramObjects/Line.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DiagramObjectLine; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/math */ "./src/js/tools/math.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _EquationLabel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EquationLabel */ "./src/js/diagram/DiagramObjects/EquationLabel.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _DiagramElements_Equation_Equation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../DiagramElements/Equation/Equation */ "./src/js/diagram/DiagramElements/Equation/Equation.js");
function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

// import Diagram from '../Diagram';





 // top - text is on top of line (except when line is vertical)
// bottom - text is on bottom of line (except when line is vertical)
// left - text is to left of line (except when line is horiztonal)
// right - text is to right of line (except when line is horiztonal)
// end1 - text is on first end of line
// end2 - text is on second end of line
// outside - text is on left of line when line is vertical from 0 to 1
//           or, if a polygon is defined clockwise, outside will be outside.
// inside - text is on right of line when line is vertical from 0 to 1
//           or, if a polygon is defined anti-clockwise, outside will be outside.

// Line is a class that manages:
//   A straight line
//   Arrows
//   Label
//   Future: Dimension posts
//
// In vertex space, a line is defined as:
//   - horizontal
//   - length 1
//   - width defined by user
//   - left side (start) of line defined at a point by user
//
// To give the line a custom position, length and angle, the main
// class's transform is used:
//   - Translation for vertex space origin position
//   - Scale for line length
//   - Rotation for line angle
//
// In vertex space, a line would normally be positioned along the x axis.
//
//
// A line can be defined in three ways:
//   - p1, p2, width, vertexSpaceStart
//      - width and vertexSpaceStart used to calculate vertex line
//      - p1, p2 used to calculate length, angle, position
//      - length, angle, position used to modify transform
//   - Length, angle, width, vertexSpaceStart, position of vertexSpaceOrigin
//      - width and vertexSpaceStart used to calculate vertex line
//      - Length, angle, position used to modify transform
//   - p1, length, angle, width, vertexSpaceStart
//      - width and vertexSpaceStart used to calculate vertex line
//      - p1 used to calculate position
//      - length, angle, position used to modify transform
var LineLabel =
/*#__PURE__*/
function (_EquationLabel) {
  _inherits(LineLabel, _EquationLabel);

  function LineLabel(equation, labelText, color, offset) {
    var _this;

    var location = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'top';
    var subLocation = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'left';
    var orientation = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 'horizontal';
    var linePosition = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0.5;
    var scale = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0.7;
    var precision = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 1;

    _classCallCheck(this, LineLabel);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(LineLabel).call(this, equation, {
      label: labelText,
      color: color,
      scale: scale
    }));
    _this.offset = offset;
    _this.location = location;
    _this.subLocation = subLocation;
    _this.orientation = orientation;
    _this.linePosition = linePosition;
    _this.precision = precision;
    return _this;
  }

  return LineLabel;
}(_EquationLabel__WEBPACK_IMPORTED_MODULE_3__["default"]);

function makeStraightLine(shapes, length, width, position, color, dashStyle, largerTouchBorder, isTouchDevice) {
  var straightLine = shapes.horizontalLine(position, length, width, 0, color, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(1, 1).translate(0, 0));

  if (dashStyle) {
    straightLine = shapes.dashedLine({
      position: position,
      length: dashStyle.maxLength,
      width: width,
      rotation: 0,
      dashStyle: dashStyle.style,
      color: color,
      transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(1, 1).translate(0, 0)
    }); //   position,
    //   dashStyle.maxLength, width,
    //   0, dashStyle.style, color, new Transform().scale(1, 1).translate(0, 0),
    // );
    // straightLine = shapes.dashedLine(
    //   position,
    //   dashStyle.maxLength, width,
    //   0, dashStyle.style, color, new Transform().scale(1, 1).translate(0, 0),
    // );
  }

  if (largerTouchBorder) {
    var multiplier = isTouchDevice ? 16 : 8;

    if (typeof largerTouchBorder === 'number') {
      multiplier = largerTouchBorder;
    }

    var increaseBorderSize = function increaseBorderSize(element) {
      for (var i = 0; i < element.drawingObject.border[0].length; i += 1) {
        // eslint-disable-next-line no-param-reassign
        element.drawingObject.border[0][i].y *= multiplier;
      }
    };

    increaseBorderSize(straightLine);
  }

  return straightLine;
} // export type TypeLine = {
//   _line: DiagramElementPrimitive;
//   currentLength: number;
//   setLength: (number) => void;
//   setEndPoints: (Point, Point, number) => void;
//   animateLengthTo: (number, number, boolean, ?() => void) => void;
//   grow: (number, number, boolean, ?() => void) => void;
//   reference: 'center' | 'end';
//   showRealLength: boolean;
//   label: ?LineLabel;
//   _label: DiagramElementCollection;
//   arrow1: null | {
//     height: number;
//   };
//   arrow2: null | {
//     height: number;
//   };
//   setMovable: (?boolean) => void;
//   addArrow1: (number, number) => void;
//   addArrow2: (number, number) => void;
//   addLabel: (string, number, TypeLineLabelLocation,
//              TypeLineLabelSubLocation, TypeLineLabelOrientation, number
//             ) => void;
//   setEndPoints: (Point, Point, ?number) => void;
//   animateLengthTo: (number, number, boolean, ?() => void) => void;
//   grow: (number, number, boolean, ?() => void) => void;
//   pulseWidth: () => void;
//   updateLabel: (?number) => {};
//   offset: number;
// } & DiagramElementCollection;
// A line is always defined as horiztonal with length 1 in vertex space
// The line's position and rotation is the line collection transform
// translation and rotation respectively.
// The line's length is the _line primative x scale.


var DiagramObjectLine =
/*#__PURE__*/
function (_DiagramElementCollec) {
  _inherits(DiagramObjectLine, _DiagramElementCollec);

  _createClass(DiagramObjectLine, [{
    key: "calculateFromP1LengthAngle",
    // Diagram elements
    // label and arrow objects that exist if labels and arrows exist
    // line properties - read only
    // deprecate
    // line properties - read/write
    // line properties - private internal use only
    // line methods
    // eslint-disable-next-line max-len
    value: function calculateFromP1LengthAngle(p1, length, angle) {
      var t = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(length, 1).rotate(angle);
      var startTransformed = this.vertexSpaceStart.transformBy(t.matrix());
      var position = p1.sub(startTransformed);
      return {
        length: length,
        angle: angle,
        position: position
      };
    }
  }, {
    key: "calculateFromP1P2",
    value: function calculateFromP1P2(p1, p2) {
      var line = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](p1, p2);
      var length = line.length();
      var angle = line.angle();
      var t = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(length, 1).rotate(angle);
      var startTransformed = this.vertexSpaceStart.transformBy(t.matrix());
      var position = p1.sub(startTransformed);
      return {
        length: length,
        angle: angle,
        position: position
      };
    }
  }]);

  function DiagramObjectLine(shapes, equation, isTouchDevice, animateNextFrame) {
    var _this2;

    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

    _classCallCheck(this, DiagramObjectLine);

    var defaultOptions = {
      position: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
      length: 1,
      angle: 0,
      width: 0.01,
      vertexSpaceStart: 'start',
      color: [0, 0, 1, 1],
      showLine: true,
      largerTouchBorder: true,
      offset: 0,
      dashStyle: null,
      mods: {},
      pulse: {
        line: 6,
        label: 2,
        arrow: 3,
        collection: 1
      }
    };
    var optionsToUse = Object.assign({}, defaultOptions, options);
    var dashStyle = optionsToUse.dashStyle;

    if (dashStyle) {
      var defaultMaxLength = optionsToUse.length;

      if (optionsToUse.p1 != null && optionsToUse.p2 != null) {
        optionsToUse.p1 = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(optionsToUse.p1);
        optionsToUse.p2 = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(optionsToUse.p2);
        defaultMaxLength = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["distance"])(optionsToUse.p1, optionsToUse.p2);
      }

      dashStyle = Object.assign({}, {
        maxLength: defaultMaxLength,
        dashStyle: [0.1]
      }, options.dashStyle);
    }

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(DiagramObjectLine).call(this, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('Line').scale(1, 1).rotate(0).translate(0, 0), shapes.limits));

    _this2.setColor(optionsToUse.color);

    _this2.shapes = shapes;
    _this2.equation = equation;
    _this2.largerTouchBorder = optionsToUse.largerTouchBorder;
    _this2.isTouchDevice = isTouchDevice;
    _this2.animateNextFrame = animateNextFrame;
    _this2.dashStyle = dashStyle; // Calculate and store the line geometry
    //    The length, angle, p1 and p2 properties also exist in this.line,
    //    but are at this level for convenience

    _this2.offset = optionsToUse.offset;
    _this2.width = optionsToUse.width;
    _this2.position = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(optionsToUse.position);
    _this2.length = optionsToUse.length;
    _this2.angle = optionsToUse.angle;

    _this2.transform.updateTranslation(_this2.position);

    _this2.transform.updateRotation(_this2.angle); // Line is defined in vertex space as horiztonal along the x axis.
    // The reference will define how it is offset where:
    //    - start: line extends from 0 to length in x
    //    - end: line extends from -length to 0 in length
    //    - middle: line extends from -length / 2 to length / 2
    //    - percent: line extends from -length * % to length * (1 - %)


    _this2.vertexSpaceLength = 1;
    _this2.vertexSpaceStart = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);

    if (optionsToUse.vertexSpaceStart === 'end') {
      _this2.vertexSpaceStart = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-1, 0);
    } else if (optionsToUse.vertexSpaceStart === 'center') {
      _this2.vertexSpaceStart = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-0.5, 0);
    } else if (typeof optionsToUse.vertexSpaceStart === 'number') {
      _this2.vertexSpaceStart = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-optionsToUse.vertexSpaceStart, 0);
    } else if (optionsToUse.vertexSpaceStart instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"]) {
      _this2.vertexSpaceStart = optionsToUse.vertexSpaceStart;
    } // this.vertexOrigin = vertexOrigin;
    // MultiMove means the line has a middle section that when touched
    // translates the line collection, and when the rest of the line is
    // touched then the line collection is rotated.


    _this2.multiMove = {
      vertexSpaceMidLength: 0,
      bounds: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](-1, -1, 2, 2)
    };
    _this2._midLine = null; // If the line is to be shown (and not just a label) then make it

    _this2._line = null;

    if (optionsToUse.showLine) {
      // let dashStyleToUse = optionsToUse.dashStyle;
      // if (dashStyleToUse == null) {  // If undefined, make null
      //   dashStyleToUse = null;
      // }
      var straightLine = makeStraightLine(_this2.shapes, _this2.vertexSpaceLength, _this2.width, _this2.vertexSpaceStart, optionsToUse.color, _this2.dashStyle, optionsToUse.largerTouchBorder, isTouchDevice);

      _this2.add('line', straightLine);
    } // Arrow related properties


    _this2.arrow1 = null;
    _this2.arrow2 = null;
    _this2._arrow1 = null;
    _this2._arrow2 = null; // Label related properties

    _this2.label = null;
    _this2._label = null;
    _this2.showRealLength = false;

    _this2.setLength(_this2.length);

    if (optionsToUse.p1 != null && optionsToUse.p2 != null) {
      _this2.setEndPoints(optionsToUse.p1, optionsToUse.p2);
    }

    var defaultArrowOptions = {
      width: _this2.width * 4,
      height: _this2.width * 4
    };

    if (optionsToUse.arrowStart) {
      var arrowOptions = Object.assign({}, defaultArrowOptions, optionsToUse.arrowStart);

      _this2.addArrowStart(arrowOptions.height, arrowOptions.width);
    }

    if (optionsToUse.arrowEnd) {
      var _arrowOptions = Object.assign({}, defaultArrowOptions, optionsToUse.arrowEnd);

      _this2.addArrowEnd(_arrowOptions.height, _arrowOptions.width);
    } // Arrows overrides arrowStart or arrowEnd


    if (optionsToUse.arrows) {
      var arrows = {};

      if (_typeof(optionsToUse.arrows) === 'object') {
        arrows = optionsToUse.arrows;
      }

      var _arrowOptions2 = Object.assign({}, defaultArrowOptions, arrows);

      _this2.addArrows(_arrowOptions2.height, _arrowOptions2.width);
    }

    var defaultLabelOptions = {
      text: null,
      offset: 0,
      location: 'top',
      subLocation: 'left',
      orientation: 'horizontal',
      linePosition: 0.5,
      scale: 0.7,
      color: optionsToUse.color,
      precision: 1
    };

    if (optionsToUse.label) {
      var labelOptions = Object.assign({}, defaultLabelOptions, optionsToUse.label);

      if (labelOptions.text === null) {
        labelOptions.text = '';
        _this2.showRealLength = true;
      }

      _this2.addLabel(labelOptions.text, labelOptions.offset, labelOptions.location, labelOptions.subLocation, labelOptions.orientation, labelOptions.linePosition, labelOptions.scale, labelOptions.color, labelOptions.precision);
    }

    var defaultMoveOptions = {
      type: 'rotation',
      middleLengthPercent: 0.22,
      translationBounds: _this2.diagramLimits
    };

    if (optionsToUse.move) {
      var moveOptions = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_4__["joinObjects"])({}, defaultMoveOptions, optionsToUse.move);

      _this2.setMovable(true, moveOptions.type, moveOptions.middleLengthPercent, moveOptions.translationBounds);
    }

    _this2.pulseDefaultSettings = {
      line: optionsToUse.pulse.line || 1,
      label: optionsToUse.pulse.label || 1,
      arrow: optionsToUse.pulse.arrow || 1,
      collection: optionsToUse.pulse.collection || 1
    };

    _this2.pulseDefault = function (done) {
      _this2.pulseWidth({
        line: _this2.pulseDefaultSettings.line,
        label: _this2.pulseDefaultSettings.label,
        arrow: _this2.pulseDefaultSettings.arrow,
        done: done
      });

      if (_this2.pulseDefaultSettings.collection !== 1) {
        _this2.pulseScaleNow(1, _this2.pulseDefaultSettings.collection);
      }
    };

    if (optionsToUse.mods != null && optionsToUse.mods !== {}) {
      _this2.setProperties(optionsToUse.mods);
    }

    return _this2;
  }

  _createClass(DiagramObjectLine, [{
    key: "pulseWidth",
    value: function pulseWidth() {
      var optionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var defaultOptions = {
        line: 3,
        label: 1.5,
        arrow: 2,
        done: null
      };
      var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_4__["joinObjects"])(defaultOptions, optionsIn);
      var done = options.done;
      var line = this._line;

      if (line != null) {
        line.stopPulsing();
        var oldTransformMethod = line.pulseSettings.transformMethod;
        var oldPulseCallback = line.pulseSettings.callback;

        var finishPulsing = function finishPulsing() {
          line.pulseSettings.transformMethod = oldTransformMethod;
          line.pulseSettings.callback = oldPulseCallback;
        };

        line.pulseSettings.callback = finishPulsing;

        line.pulseSettings.transformMethod = function (s) {
          return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(1, s);
        };

        line.pulseScaleNow(1, options.line, 0, done);
        done = null;
      }

      var arrow1 = this._arrow1;
      var arrow2 = this._arrow2;

      if (arrow1 != null) {
        arrow1.pulseScaleNow(1, options.arrow, 0, done);
        done = null;
      }

      if (arrow2 != null) {
        arrow2.pulseScaleNow(1, options.arrow, 0, done);
        done = null;
      }

      var label = this._label;

      if (label != null) {
        label.pulseScaleNow(1, options.label, 0, done);
        done = null;
      }

      if (done != null) {
        done();
      }

      this.animateNextFrame();
    }
  }, {
    key: "addArrow",
    value: function addArrow(index) {
      var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.width * 4;
      var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : height;
      var r = Math.PI / 2;

      if (index === 2) {
        r = Math.PI / 2 * 3;
      }

      var a = this.shapes.arrow({
        width: width,
        legWidth: 0,
        height: height,
        legHeight: 0,
        color: this.color,
        transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().translate(this.vertexSpaceStart.x, 0),
        tip: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
        rotation: r
      }); // const a = this.shapes.arrowLegacy(
      //   width, 0, height, 0,
      //   this.color, new Transform().translate(this.vertexSpaceStart.x, 0), new Point(0, 0), r,
      // );
      // $FlowFixMe

      this["arrow".concat(index)] = {
        height: height
      };
      this.add("arrow".concat(index), a);
      this.setLength(this.currentLength);
    }
  }, {
    key: "addArrows",
    value: function addArrows() {
      var arrowHeight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.width * 4;
      var arrowWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : arrowHeight;
      this.addArrow1(arrowHeight, arrowWidth);
      this.addArrow2(arrowHeight, arrowWidth);
    }
  }, {
    key: "addArrow1",
    value: function addArrow1() {
      var arrowHeight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.width * 4;
      var arrowWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : arrowHeight;
      this.addArrow(1, arrowHeight, arrowWidth);
    }
  }, {
    key: "addArrow2",
    value: function addArrow2() {
      var arrowHeight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.width * 4;
      var arrowWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : arrowHeight;
      this.addArrow(2, arrowHeight, arrowWidth);
    }
  }, {
    key: "addArrowStart",
    value: function addArrowStart() {
      var arrowHeight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.width * 4;
      var arrowWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : arrowHeight;
      this.addArrow1(arrowHeight, arrowWidth);
    }
  }, {
    key: "addArrowEnd",
    value: function addArrowEnd() {
      var arrowHeight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.width * 4;
      var arrowWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : arrowHeight;
      this.addArrow2(arrowHeight, arrowWidth);
    }
  }, {
    key: "setMovable",
    value: function setMovable() {
      var movable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var moveType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.move.type;
      var middleLengthPercent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.333;
      var translationBounds = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.diagramLimits;

      if (movable) {
        if (moveType === 'translation' || moveType === 'rotation' || moveType === 'scale' || moveType === 'scaleX' || moveType === 'scaleY') {
          this.move.type = moveType;

          _get(_getPrototypeOf(DiagramObjectLine.prototype), "setMovable", this).call(this, true); // this.isTouchable = true;
          // this.isMovable = true;


          this.hasTouchableElements = true;

          if (this._line != null) {
            this._line.isTouchable = true;
            this._line.isMovable = false;
          }

          if (this._midLine) {
            this._midLine.isMovable = false;
          }

          this.multiMove.bounds = translationBounds;
        } else {
          this.setMultiMovable(middleLengthPercent, translationBounds);
        }
      } else {
        this.isMovable = false;
        this.isTouchable = false;

        if (this._line != null) {
          this._line.isTouchable = false;
          this._line.isMovable = false;
        }
      }
    }
  }, {
    key: "setMultiMovable",
    value: function setMultiMovable(middleLengthPercent, translationBounds) {
      this.multiMove.vertexSpaceMidLength = middleLengthPercent * this.vertexSpaceLength;
      var start = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](this.vertexSpaceStart.x + this.vertexSpaceLength / 2 - this.multiMove.vertexSpaceMidLength / 2, 0);
      var midLine = makeStraightLine(this.shapes, this.multiMove.vertexSpaceMidLength, this.width, start, this.color, null, this.largerTouchBorder, this.isTouchDevice); // console.log(midLine)

      midLine.isTouchable = true;
      midLine.move.type = 'translation';
      midLine.move.element = this;
      midLine.isMovable = true;
      midLine.move.canBeMovedAfterLosingTouch = true;
      this.add('midLine', midLine);

      if (this._line) {
        this._line.isTouchable = true;
        this._line.move.type = 'rotation';
        this._line.move.element = this;
        this._line.isMovable = true;
        this._line.move.canBeMovedAfterLosingTouch = true;
      }

      this.hasTouchableElements = true;
      this.isTouchable = false;
      this.isMovable = false;
      this.multiMove.bounds = translationBounds;
      this.setLength(this.currentLength);
    }
  }, {
    key: "updateMoveTransform",
    value: function updateMoveTransform() {
      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.transform._dup();
      var r = t.r();
      var bounds = this.multiMove.bounds;

      if (r != null) {
        var w = Math.abs(this.currentLength / 2 * Math.cos(r));
        var h = Math.abs(this.currentLength / 2 * Math.sin(r));
        this.move.maxTransform.updateTranslation(bounds.right - w, bounds.top - h);
        this.move.minTransform.updateTranslation(bounds.left + w, bounds.bottom + h);

        if (r > 2 * Math.PI) {
          this.transform.updateRotation(r - 2 * Math.PI);
        }

        if (r < 0) {
          this.transform.updateRotation(r + 2 * Math.PI);
        }
      }
    }
  }, {
    key: "addLabel",
    value: function addLabel(labelText, offset) {
      var location = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'top';
      var subLocation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'left';
      var orientation = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'horizontal';
      var linePosition = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0.5;
      var scale = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0.7;
      var color = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : this.color;
      var precision = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 1;
      this.label = new LineLabel(this.equation, labelText, color, offset, location, subLocation, orientation, linePosition, scale, precision);

      if (this.label != null) {
        this.add('label', this.label.eqn);
      }

      this.updateLabel();
    }
  }, {
    key: "getLength",
    value: function getLength() {
      return this.length;
    }
  }, {
    key: "getAngle",
    value: function getAngle() {
      var units = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'rad';

      if (units === 'deg') {
        return this.angle * 180 / Math.PI;
      }

      return this.angle;
    }
  }, {
    key: "setLabel",
    value: function setLabel(text) {
      this.showRealLength = false;

      if (this.label != null) {
        this.label.setText(text);
      }

      this.updateLabel();
    }
  }, {
    key: "getLabel",
    value: function getLabel() {
      if (this.label != null) {
        return this.label.getText();
      }

      return '';
    }
  }, {
    key: "setLabelToRealLength",
    value: function setLabelToRealLength() {
      this.showRealLength = true;
      this.updateLabel();
    }
  }, {
    key: "updateLabel",
    value: function updateLabel() {
      var parentRotationOffset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var label = this.label;

      if (label == null) {
        return;
      }

      var lineAngle = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["normAngle"])(this.transform.r() || 0);
      var labelAngle = 0;

      if (this.showRealLength && this._label) {
        // this._label._base.drawingObject.setText(roundNum(this.currentLength, 2)
        //   .toFixed(label.precision));
        label.setText(Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["roundNum"])(this.currentLength, 2).toFixed(label.precision)); // label.eqn.reArrangeCurrentForm();
      }

      var labelPosition = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](this.vertexSpaceStart.x * this.currentLength + label.linePosition * this.currentLength, 0);
      var labelOffsetAngle = Math.PI / 2;
      var labelOffsetMag = label.offset;

      if (label.location === 'end1' || label.location === 'end2') {
        if (label.location === 'end1') {
          labelPosition.x = this.vertexSpaceStart.x * this.currentLength - label.offset;
          labelOffsetAngle = -Math.PI;
        }

        if (label.location === 'end2') {
          labelPosition.x = this.vertexSpaceStart.x * this.currentLength + this.currentLength + label.offset;
          labelOffsetAngle = 0;
        }
      } else {
        var offsetTop = Math.cos(lineAngle) < 0 ? -Math.PI / 2 : Math.PI / 2;
        var offsetBottom = -offsetTop;
        var offsetLeft = Math.sin(lineAngle) > 0 ? Math.PI / 2 : -Math.PI / 2;
        var offsetRight = -offsetLeft;

        if (label.location === 'top') {
          labelOffsetAngle = offsetTop;
        }

        if (label.location === 'bottom') {
          labelOffsetAngle = offsetBottom;
        }

        if (label.location === 'right') {
          labelOffsetAngle = offsetRight;
        }

        if (label.location === 'left') {
          labelOffsetAngle = offsetLeft;
        }

        if (Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["roundNum"])(Math.sin(lineAngle), 4) === 0 && (label.location === 'left' || label.location === 'right')) {
          if (label.subLocation === 'top') {
            labelOffsetAngle = offsetTop;
          }

          if (label.subLocation === 'bottom') {
            labelOffsetAngle = offsetBottom;
          }
        }

        if (Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["roundNum"])(Math.cos(lineAngle), 4) === 0 && (label.location === 'top' || label.location === 'bottom')) {
          if (label.subLocation === 'right') {
            labelOffsetAngle = offsetRight;
          }

          if (label.subLocation === 'left') {
            labelOffsetAngle = offsetLeft;
          }
        }

        if (label.location === 'inside') {
          labelOffsetAngle = -Math.PI / 2;
        }

        if (label.location === 'outside') {
          labelOffsetAngle = Math.PI / 2;
        }
      }

      if (label.orientation === 'horizontal') {
        labelAngle = -lineAngle;
      }

      if (label.orientation === 'baseToLine') {
        if (labelPosition.y < 0) {
          labelAngle = Math.PI;
        }
      }

      if (label.orientation === 'baseAway') {
        if (labelPosition.y > 0) {
          labelAngle = Math.PI;
        }
      }

      if (label.orientation === 'baseUpright') {
        if (Math.cos(lineAngle) < 0) {
          labelAngle = Math.PI;
        }
      }

      label.updateRotation(labelAngle - parentRotationOffset, labelPosition, labelOffsetMag, labelOffsetAngle);
    }
  }, {
    key: "setLength",
    value: function setLength(newLength) {
      var lineStart = this.vertexSpaceStart.x * newLength;
      var lineLength = newLength;
      var straightLineLength = lineLength;
      var startOffset = 0;

      if (this.arrow1 && this._arrow1) {
        straightLineLength -= this.arrow1.height;
        startOffset = this.arrow1.height;

        this._arrow1.setPosition(lineStart);
      }

      if (this.arrow2 && this._arrow2) {
        straightLineLength -= this.arrow2.height;

        this._arrow2.setPosition(lineStart + lineLength, 0);
      }

      var line = this._line;

      if (line) {
        if (this.dashStyle) {
          line.lengthToDraw = straightLineLength; // const newStart = this.vertexSpaceStart.x * straightLineLength;
          // const delta = lineStart + startOffset - newStart;

          line.setPosition(lineStart + startOffset - this.vertexSpaceStart.x, 0);
        } else {
          line.transform.updateScale(straightLineLength, 1);
          var newStart = this.vertexSpaceStart.x * straightLineLength;
          var delta = lineStart + startOffset - newStart;
          line.setPosition(delta, 0);
        }
      }

      var midLine = this._midLine;

      if (midLine) {
        midLine.transform.updateScale(newLength, 1);
      }

      this.length = newLength;
      this.updateLineGeometry();
      this.currentLength = newLength; // to deprecate?

      this.updateLabel();
    }
  }, {
    key: "updateLineGeometry",
    value: function updateLineGeometry() {
      var t = this.transform.t();
      var r = this.transform.r();

      if (t != null && r != null) {
        this.position = t;
        this.angle = r;
        var p1 = this.vertexSpaceStart.transformBy(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(this.length).rotate(this.angle).translate(this.position).m());
        var line = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](p1, this.length, this.angle);
        this.p1 = line.getPoint(1);
        this.p2 = line.getPoint(2);
        this.line = line;
      }
    }
  }, {
    key: "setLineDimensions",
    value: function setLineDimensions() {
      var offset = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(this.offset, this.angle + Math.PI / 2);
      this.transform.updateTranslation(this.position.add(offset));
      this.transform.updateRotation(this.angle);
      this.setLength(this.length);
      this.updateLabel();
    }
  }, {
    key: "setEndPoints",
    value: function setEndPoints(p, q) {
      var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.offset;
      this.offset = offset;

      var _this$calculateFromP = this.calculateFromP1P2(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(p), Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(q)),
          length = _this$calculateFromP.length,
          angle = _this$calculateFromP.angle,
          position = _this$calculateFromP.position;

      this.angle = angle;
      this.length = length;
      this.position = position;
      this.setLineDimensions(); // const pq = new Line(p, q);
      // this.angle = pq.angle();
      // this.length = pq.length();
      // this.position = p;
      // if (this.vertexOrigin === 'center') {
      //   this.position = pq.midpoint();
      // } else if (this.vertexOrigin === 'end') {
      //   this.position = q;
      // } else if (typeof this.vertexOrigin === 'number') {
      //   this.position = p.add(polarToRect(this.vertexOrigin * this.length, this.angle));
      // } else if (this.vertexOrigin instanceof Point) {
      //   this.position = p.add(this.vertexOrigin);
      // }
      // // this.updateLineGeometry();
      // // const newLength = distance(q, p);
      // // const pq = new Line(p, q);
      // this.transform.updateRotation(pq.angle());
      // const offsetdelta = polarToRect(offset, pq.angle() + Math.PI / 2);
      // // if (this.reference === 'center') {
      // this.transform.updateTranslation(this.position.add(offsetdelta));
      // // } else {
      // //   this.transform.updateTranslation(p.add(offsetdelta));
      // // }
      // this.setLength(this.length);
      // this.updateLabel();
    }
  }, {
    key: "animateLengthTo",
    value: function animateLengthTo() {
      var _this3 = this;

      var toLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var finishOnCancel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var onStepCallback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      var stop = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;

      if (stop) {
        this.stop();
      }

      var initialLength = this.currentLength;
      var deltaLength = toLength - this.currentLength;

      var func = function func(percent) {
        _this3.setLength(initialLength + deltaLength * percent);

        if (onStepCallback != null) {
          onStepCallback(percent, initialLength + deltaLength * percent);
        }
      };

      var done = function done() {
        if (finishOnCancel) {
          _this3.setLength(initialLength + deltaLength);
        }

        if (typeof callback === 'function' && callback) {
          callback();
        }
      };

      this.animations["new"]('Line Length').custom({
        callback: func,
        duration: time
      }).whenFinished(done).start(); // this.animations.start();

      this.animateNextFrame(); // console.log(this)
      // this.animateCustomTo(func, time, 0, done);
    }
  }, {
    key: "grow",
    value: function grow() {
      var fromLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var finishOnCancel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var onStepCallback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      this.stop();
      var target = this.currentLength;
      this.setLength(fromLength);
      this.animateLengthTo(target, time, finishOnCancel, callback, onStepCallback);
    }
  }, {
    key: "showLineOnly",
    value: function showLineOnly() {
      this.show();

      if (this._line) {
        this._line.show();
      }

      if (this._arrow1) {
        this._arrow1.show();
      }

      if (this._arrow2) {
        this._arrow2.show();
      }

      if (this._label) {
        this._label.hideAll();
      }
    }
  }, {
    key: "getP1",
    value: function getP1() {
      var m = this.transform.matrix();
      return this.p1.transformBy(m);
    }
  }, {
    key: "getP2",
    value: function getP2() {
      var m = this.transform.matrix();
      return this.p2.transformBy(m);
    }
  }]);

  return DiagramObjectLine;
}(_Element__WEBPACK_IMPORTED_MODULE_2__["DiagramElementCollection"]); // export type TypeLine = DiagramObjectLine;
// export class MovableLine extends DiagramObjectLine {
//   // constructor(
//   //   fullLength: number,
//   //   endLength: number,
//   //   width: number,
//   //   boundary: Rect,
//   // ) {
//   // }
// }
// export type TypeMovableLine = MovableLine;




/***/ }),

/***/ "./src/js/diagram/DiagramObjects/PolyLine.js":
/*!***************************************************!*\
  !*** ./src/js/diagram/DiagramObjects/PolyLine.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DiagramObjectPolyLine; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _tools_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/math */ "./src/js/tools/math.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _DiagramPrimitives_DiagramPrimitives__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../DiagramPrimitives/DiagramPrimitives */ "./src/js/diagram/DiagramPrimitives/DiagramPrimitives.js");
/* harmony import */ var _DiagramObjects__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DiagramObjects */ "./src/js/diagram/DiagramObjects/DiagramObjects.js");
/* harmony import */ var _DiagramEquation_DiagramEquation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../DiagramEquation/DiagramEquation */ "./src/js/diagram/DiagramEquation/DiagramEquation.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }




 // import type {
//   TypePolyLineBorderToPoint,
// } from '../DiagramElements/PolyLine';

 // eslint-disable-next-line import/no-cycle




function makeArray(possibleArray, count) {
  if (Array.isArray(possibleArray)) {
    if (count === possibleArray.length) {
      // $FlowFixMe
      return possibleArray;
    }

    var _outArray = [];

    for (var i = 0; i < count; i += 1) {
      _outArray.push(possibleArray[i % possibleArray.length]);
    }

    return _outArray;
  }

  var outArray = [];
  var labels = [];

  if (_typeof(possibleArray) === 'object' && possibleArray != null) {
    if (possibleArray.label != null && possibleArray.label.text != null && Array.isArray(possibleArray.label.text)) {
      labels = possibleArray.label.text.slice(); // const obj = possibleArray;

      for (var _i = 0; _i < count; _i += 1) {
        // $FlowFixMe
        var obj = {
          label: {
            text: labels[_i % labels.length]
          }
        }; // console.log(labels, labels[i % labels.length]);

        outArray.push(Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, possibleArray, obj));
      } // $FlowFixMe


      return outArray;
    }
  }

  for (var _i2 = 0; _i2 < count; _i2 += 1) {
    outArray.push(possibleArray);
  }

  return outArray;
} // function makeColorArray(
//   possibleArray: Array<Array<number> | number>,
//   count: number,
// ): Array<Array<number>> {
//   if (Array.isArray(possibleArray[0])) {
//     if (count === possibleArray.length) {                   // $FlowFixMe
//       return possibleArray;
//     }
//     const outArray = [];
//     for (let i = 0; i < count; i += 1) {                    // $FlowFixMe
//       outArray.push(possibleArray[i % possibleArray.length].slice());
//     }
//     return outArray;
//   }
//   const outArray = [];
//   for (let i = 0; i < count; i += 1) {
//     outArray.push(possibleArray.slice());
//   }                                                         // $FlowFixMe
//   return outArray;
// }


var DiagramObjectPolyLine =
/*#__PURE__*/
function (_DiagramElementCollec) {
  _inherits(DiagramObjectPolyLine, _DiagramElementCollec);

  function DiagramObjectPolyLine(shapes, equation, objects, isTouchDevice, animateNextFrame) {
    var _this;

    var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};

    _classCallCheck(this, DiagramObjectPolyLine);

    var defaultOptions = {
      position: null,
      color: [0, 1, 0, 1],
      points: [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](1, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 1)],
      close: false,
      showLine: true,
      // borderToPoint: 'never',
      width: 0.01,
      reverse: false,
      transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('PolyLine').scale(1, 1).rotate(0).translate(0, 0),
      makeValid: null
    };

    if (options.makeValid != null && options.makeValid.shape != null && options.makeValid.shape === 'triangle') {
      defaultOptions.makeValid = {
        shape: 'triangle',
        hide: {
          minAngle: null,
          maxAngle: null,
          minSide: null
        }
      };
    }

    var defaultSideOptions = {
      showLine: false,
      offset: 0,
      width: 0.01,
      color: options.color == null ? [0, 1, 0, 1] : options.color
    };
    var defaultSideLabelOptions = {
      offset: 0.1,
      text: null,
      location: 'outside',
      subLocation: 'top',
      orientation: 'horizontal',
      linePosition: 0.5,
      scale: 0.7
    };
    var defaultAngleOptions = {
      color: options.color == null ? [0, 1, 0, 1] : options.color,
      curve: {},
      autoRightAngle: true
    };
    var defaultAngleLabelOptions = {
      text: null
    };
    var defaultPadOptions = {
      sides: 20,
      radius: 0.1,
      color: options.color == null ? [0, 1, 0, 1] : options.color,
      fill: true,
      isMovable: false,
      boundary: 'diagram',
      touchRadiusInBoundary: false
    };

    if (options.side != null) {
      defaultOptions.side = defaultSideOptions; // $FlowFixMe

      if (options.side.label != null) {
        defaultOptions.side.label = defaultSideLabelOptions;
      }
    }

    if (options.angle != null) {
      defaultOptions.angle = defaultAngleOptions; // $FlowFixMe

      if (options.angle.label != null) {
        defaultOptions.angle.label = defaultAngleLabelOptions;
      }
    }

    if (options.pad != null) {
      defaultOptions.pad = defaultPadOptions;
    }

    var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, options);

    if (Array.isArray(options.side)) {
      // $FlowFixMe
      optionsToUse.side = options.side.map(function (side) {
        return Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions.side, side);
      });
    }

    if (Array.isArray(options.angle)) {
      // $FlowFixMe
      optionsToUse.angle = options.angle.map(function (angle) {
        return Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions.angle, angle);
      });
    }

    _this = _possibleConstructorReturn(this, _getPrototypeOf(DiagramObjectPolyLine).call(this, optionsToUse.transform, shapes.limits));

    _this.setColor(optionsToUse.color);

    _this.shapes = shapes;
    _this.equation = equation;
    _this.objects = objects;
    _this.largerTouchBorder = optionsToUse.largerTouchBorder;
    _this.isTouchDevice = isTouchDevice;
    _this.animateNextFrame = animateNextFrame;
    _this.updatePointsCallback = null;

    if (optionsToUse.position != null) {
      _this.transform.updateTranslation(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(optionsToUse.position));
    }

    _this.position = _this.getPosition();
    _this.close = optionsToUse.close;
    _this.options = optionsToUse;
    _this.reverse = optionsToUse.reverse;
    _this.makeValid = optionsToUse.makeValid;
    _this.points = optionsToUse.points.map(function (p) {
      return Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(p);
    }); // Add Pads

    if (optionsToUse.pad) {
      var pad = optionsToUse.pad;
      var pCount = _this.points.length;
      var padArray = makeArray(pad, pCount);

      var _loop = function _loop(i) {
        var name = "pad".concat(i);
        var padOptions = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, {
          transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().translate(_this.points[i])
        }, padArray[i]);

        var padShape = _this.shapes.polygon(padOptions);

        if (padArray[i].isMovable) {
          padShape.isMovable = true;
          padShape.isTouchable = true;

          if (padArray[i].touchRadius != null) {
            var multiplier = padArray[i].touchRadius / padArray[i].radius;
            padShape.increaseBorderSize(multiplier);
          }

          var boundary = padArray[i].boundary; // console.log(boundary, padArray[i])

          if (boundary === 'diagram') {
            boundary = shapes.limits._dup();
          } else if (Array.isArray(boundary)) {
            var _boundary = boundary,
                _boundary2 = _slicedToArray(_boundary, 4),
                left = _boundary2[0],
                bottom = _boundary2[1],
                width = _boundary2[2],
                height = _boundary2[3];

            boundary = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](left, bottom, width, height);
          }

          if (padArray[i].touchRadiusInBoundary === false && padArray[i].touchRadius != null) {
            var delta = padArray[i].touchRadius - padArray[i].radius;
            boundary = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](boundary.left - delta, boundary.bottom - delta, boundary.width + 2 * delta, boundary.height + 2 * delta);
          }

          padShape.setMoveBoundaryToDiagram(boundary);

          padShape.setTransformCallback = function (transform) {
            var index = parseInt(padShape.name.slice(3), 10);
            var translation = transform.t();

            if (translation != null) {
              _this.points[index] = translation._dup();

              _this.updatePoints(_this.points);
            }
          };
        }

        _this.add(name, padShape);
      };

      for (var i = 0; i < pCount; i += 1) {
        _loop(i);
      }
    } // Add Angles


    if (optionsToUse.angle) {
      var angle = optionsToUse.angle;
      var _pCount = _this.points.length;

      if (optionsToUse.close === false) {
        _pCount -= 2;
      }

      var angleArray = makeArray(angle, _pCount);
      var firstIndex = 0;

      if (optionsToUse.close === false) {
        firstIndex = 1;
      }

      for (var _i3 = firstIndex; _i3 < _pCount + firstIndex; _i3 += 1) {
        var j = _i3 + 1;
        var k = _i3 - 1;

        if (_i3 === _pCount - 1 && optionsToUse.close) {
          j = 0;
        }

        if (_i3 === 0 && optionsToUse.close) {
          k = _pCount - 1;
        }

        var name = "angle".concat(_i3);

        if (_this.reverse) {
          var newJ = k;
          k = j;
          j = newJ;
        }

        var angleOptions = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, {
          p1: _this.points[k],
          p2: _this.points[_i3],
          p3: _this.points[j]
        }, angleArray[_i3 - firstIndex]);

        var angleAnnotation = _this.objects.angle(angleOptions);

        _this.add(name, angleAnnotation);
      }
    } // Add Line


    if (optionsToUse.showLine) {
      var line = _this.shapes.polyline({
        points: _this.points,
        // color: optionsToUse.color,
        // close: optionsToUse.close,
        // // borderToPoint: optionsToUse.borderToPoint,
        // width: optionsToUse.width,
        width: options.width,
        close: options.close,
        widthIs: options.widthIs,
        cornerStyle: options.cornerStyle,
        cornerSize: options.cornerSize,
        cornerSides: options.cornerSides,
        minAutoCornerAngle: options.minAutoCornerAngle,
        dash: options.dash,
        color: options.color,
        pulse: options.pulse
      });

      _this.add('line', line);
    } // Add Sides


    if (optionsToUse.side) {
      var side = optionsToUse.side;

      var _pCount2 = _this.points.length - 1;

      if (optionsToUse.close) {
        _pCount2 += 1;
      }

      var sideArray = makeArray(side, _pCount2);

      for (var _i4 = 0; _i4 < _pCount2; _i4 += 1) {
        var _j = _i4 + 1;

        if (_i4 === _pCount2 - 1 && optionsToUse.close) {
          _j = 0;
        }

        var _name = "side".concat(_i4).concat(_j);

        var sideOptions = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, {
          p1: _this.points[_i4],
          p2: _this.points[_j]
        }, sideArray[_i4]);

        if (_this.reverse) {
          sideOptions = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, {
            p1: _this.points[_j],
            p2: _this.points[_i4]
          }, sideArray[_i4]);
        }

        var sideLine = _this.objects.line(sideOptions);

        _this.add(_name, sideLine);
      }
    }

    return _this;
  }

  _createClass(DiagramObjectPolyLine, [{
    key: "updateSideLabels",
    value: function updateSideLabels() {
      var rotationOffset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      if (this.options.side != null) {
        var pCount = this.points.length - 1;

        if (this.close) {
          pCount += 1;
        }

        for (var i = 0; i < pCount; i += 1) {
          var j = i + 1;

          if (i === pCount - 1 && this.close) {
            j = 0;
          }

          var name = "side".concat(i).concat(j);

          if (this.elements[name] != null) {
            var wasHidden = !this.elements[name].isShown;
            this.elements[name].updateLabel(rotationOffset);

            if (wasHidden) {
              this.elements[name].hide();
            }
          }
        }
      }
    }
  }, {
    key: "updateAngleLabels",
    value: function updateAngleLabels() {
      var rotationOffset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      if (this.options.angle != null) {
        var pCount = this.points.length;

        if (this.close === false) {
          pCount -= 2;
        }

        var firstIndex = 0;

        if (this.close === false) {
          firstIndex = 1;
        }

        for (var i = firstIndex; i < pCount + firstIndex; i += 1) {
          var name = "angle".concat(i);

          if (this.elements[name] != null) {
            var wasHidden = !this.elements[name].isShown;
            this.elements[name].updateLabel(rotationOffset);

            if (wasHidden) {
              this.elements[name].hide();
            }
          }
        }
      }
    }
  }, {
    key: "updatePoints",
    value: function updatePoints(newPointsIn) {
      var skipCallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var newPoints = newPointsIn.map(function (p) {
        return Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(p);
      });

      if (this._line != null) {
        this._line.custom.updatePoints(newPoints);
      } // Add Pads


      var pCount = this.points.length;

      if (this.options.pad) {
        for (var i = 0; i < pCount; i += 1) {
          var name = "pad".concat(i);

          if (this.elements[name]) {
            // if (this.elements[name].isMovable === false) {
            this.elements[name].transform.updateTranslation(newPoints[i]); // }
          }
        }
      }

      if (this.options.side != null) {
        pCount = this.points.length - 1;

        if (this.close) {
          pCount += 1;
        }

        for (var _i5 = 0; _i5 < pCount; _i5 += 1) {
          var j = _i5 + 1;

          if (_i5 === pCount - 1 && this.close) {
            j = 0;
          }

          var _name2 = "side".concat(_i5).concat(j);

          if (this.elements[_name2] != null) {
            var wasHidden = !this.elements[_name2].isShown;

            if (this.reverse) {
              this.elements[_name2].setEndPoints(newPoints[j], newPoints[_i5]);
            } else {
              this.elements[_name2].setEndPoints(newPoints[_i5], newPoints[j]);
            }

            if (wasHidden) {
              this.elements[_name2].hide();
            }
          }
        }
      }

      if (this.options.angle != null) {
        pCount = this.points.length;

        if (this.close === false) {
          pCount -= 2;
        }

        var firstIndex = 0;

        if (this.close === false) {
          firstIndex = 1;
        }

        for (var _i6 = firstIndex; _i6 < pCount + firstIndex; _i6 += 1) {
          var _j2 = _i6 + 1;

          var k = _i6 - 1;

          if (_i6 === pCount - 1 && this.close) {
            _j2 = 0;
          }

          if (_i6 === 0 && this.close) {
            k = pCount - 1;
          }

          var _name3 = "angle".concat(_i6);

          if (this.elements[_name3] != null) {
            var _wasHidden = !this.elements[_name3].isShown;

            if (this.reverse) {
              var newJ = k;
              k = _j2;
              _j2 = newJ;
            }

            this.elements[_name3].setAngle({
              p1: newPoints[k],
              p2: newPoints[_i6],
              p3: newPoints[_j2]
            });

            if (_wasHidden) {
              this.elements[_name3].hide();
            }
          }
        }
      }

      this.points = newPoints;

      if (this.makeValid != null && this.makeValid.shape === 'triangle' && !skipCallback) {
        this.makeValidTriangle();
      }

      if (this.updatePointsCallback != null && !skipCallback) {
        this.updatePointsCallback();
      }
    }
  }, {
    key: "updateRotation",
    value: function updateRotation() {
      var rotationOffset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var i = 0; // $FlowFixMe

      var angle = this["_angle".concat(i)];

      while (angle != null) {
        angle.update(this.getRotation() + rotationOffset);
        i += 1; // $FlowFixMe

        angle = this["_angle".concat(i)];
      }

      i = 0; // $FlowFixMe

      var side = this["_side".concat(i).concat(i + 1)];

      while (side != null) {
        side.updateLabel(this.getRotation() + rotationOffset);
        i += 1; // $FlowFixMe

        side = this["_side".concat(i).concat(i + 1)];
      } // $FlowFixMe


      side = this["_side".concat(i, 0)];

      if (side != null) {
        side.updateLabel(this.getRotation() + rotationOffset);
      }
    }
  }, {
    key: "reversePoints",
    value: function reversePoints() {
      var skipCallback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var newPoints = [];

      for (var i = 0; i < this.points.length; i += 1) {
        newPoints.push(this.points[this.points.length - 1 - i]);
      }

      this.updatePoints(newPoints, skipCallback);
    }
  }, {
    key: "setPositionWithoutMoving",
    value: function setPositionWithoutMoving(newPositionPointOrX) {
      var newPositionY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var newPosition = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);

      if (typeof newPositionPointOrX === 'number') {
        newPosition.x = newPositionPointOrX;
        newPosition.y = newPositionY;
      } else {
        newPosition = newPositionPointOrX;
      }

      var currentPosition = this.getPosition();
      var delta = currentPosition.sub(newPosition);
      this.setPosition(newPosition);
      var newPoints = this.points.map(function (p) {
        return p.add(delta);
      });
      this.updatePoints(newPoints);
    }
  }, {
    key: "setRotationWithoutMoving",
    value: function setRotationWithoutMoving(newRotation) {
      var currentRotation = this.getRotation();
      var delta = currentRotation - newRotation;
      var deltaMatrix = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().rotate(delta).m();
      this.setRotation(newRotation);
      var newPoints = this.points.map(function (p) {
        return p.transformBy(deltaMatrix);
      });
      this.updatePoints(newPoints);
    }
  }, {
    key: "setScaleWithoutMoving",
    value: function setScaleWithoutMoving(newScalePointOrX) {
      var newScaleY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var newScale = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);

      if (typeof newScalePointOrX === 'number') {
        newScale.x = newScalePointOrX;
        newScale.y = newScaleY;
      } else {
        newScale = newScalePointOrX;
      }

      var currentScale = this.getScale();
      var delta = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](currentScale.x / newScale.x, currentScale.y / newScale.y);
      var deltaMatrix = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(delta).m();
      this.setScale(newScale);
      var newPoints = this.points.map(function (p) {
        return p.transformBy(deltaMatrix);
      });
      this.updatePoints(newPoints);
    }
  }, {
    key: "setShow",
    value: function setShow(name, show) {
      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];

        if (element.name.startsWith(name)) {
          if (show) {
            element.showAll();
          } else {
            element.hide();
          }
        }
      }
    }
  }, {
    key: "hideAngles",
    value: function hideAngles() {
      this.setShow('angle', false);
    }
  }, {
    key: "hideSides",
    value: function hideSides() {
      this.setShow('side', false);
    }
  }, {
    key: "showAngles",
    value: function showAngles() {
      this.setShow('angle', true);
    }
  }, {
    key: "showSides",
    value: function showSides() {
      this.setShow('side', true);
    }
  }, {
    key: "updateLabels",
    value: function updateLabels() {
      var rotationOffset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getRotation();
      this.updateAngleLabels(rotationOffset);
      this.updateSideLabels(rotationOffset);
    }
  }, {
    key: "makeValidTriangle",
    value: function makeValidTriangle() {
      // $FlowFixMe
      var angle0 = this._angle0; // $FlowFixMe

      var angle1 = this._angle1; // $FlowFixMe

      var angle2 = this._angle2; // $FlowFixMe

      var side01 = this._side01; // $FlowFixMe

      var side12 = this._side12; // $FlowFixMe

      var side20 = this._side20;
      var anglePrecision = angle0.label.precision;
      var sidePrecision = side01.label.precision; // $FlowFixMe

      var clipAngle0 = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["clipAngle"])(angle0.getAngle(), '0to360') * 180 / Math.PI;
      var clipAngle1 = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["clipAngle"])(angle1.getAngle(), '0to360') * 180 / Math.PI;
      var clipAngle2 = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["clipAngle"])(angle2.getAngle(), '0to360') * 180 / Math.PI;
      var a0 = Object(_tools_math__WEBPACK_IMPORTED_MODULE_2__["round"])(clipAngle0, anglePrecision);
      var a1 = Object(_tools_math__WEBPACK_IMPORTED_MODULE_2__["round"])(clipAngle1, anglePrecision);
      var a2 = Object(_tools_math__WEBPACK_IMPORTED_MODULE_2__["round"])(clipAngle2, anglePrecision);
      var s01 = Object(_tools_math__WEBPACK_IMPORTED_MODULE_2__["round"])(side01.getLength(), sidePrecision);
      var s12 = Object(_tools_math__WEBPACK_IMPORTED_MODULE_2__["round"])(side12.getLength(), sidePrecision);
      var s20 = Object(_tools_math__WEBPACK_IMPORTED_MODULE_2__["round"])(side20.getLength(), sidePrecision); // Reverse the points if the angles are on the outside

      if (a0 > 90 && a1 > 90 && a2 > 90) {
        this.reverse = !this.reverse;
        this.updatePoints(this.points, false);
        a0 = Object(_tools_math__WEBPACK_IMPORTED_MODULE_2__["round"])(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["clipAngle"])(angle0.getAngle(), '0to360') * 180 / Math.PI, anglePrecision);
        a1 = Object(_tools_math__WEBPACK_IMPORTED_MODULE_2__["round"])(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["clipAngle"])(angle1.getAngle(), '0to360') * 180 / Math.PI, anglePrecision);
        a2 = Object(_tools_math__WEBPACK_IMPORTED_MODULE_2__["round"])(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["clipAngle"])(angle2.getAngle(), '0to360') * 180 / Math.PI, anglePrecision);
      } // else {
      // This is a weird case at the 0/360 transition


      if (a0 > 180) {
        a0 = 360 - angle0;
      }

      if (a1 > 180) {
        a1 = 360 - angle1;
      }

      if (a2 > 180) {
        a2 = 360 - angle2;
      } // Hide the angles if the triangle is thin or small enough
      // if (
      //   (angle0.label.autoHide > -1 && a0 > angle0.label.autoHide)
      //   || (angle0.label.autoHideMax != null && angle0.label.autoHideMax < a0)
      //   || (angle1.label.autoHide > -1 && a1 > angle1.label.autoHide)
      //   || (angle1.label.autoHideMax != null && angle1.label.autoHideMax < a1)
      //   || (angle2.label.autoHide > -1 && a2 > angle2.label.autoHide)
      //   || (angle2.label.autoHideMax != null && angle2.label.autoHideMax < a2)
      //   || s01 < 0.6 || s12 < 0.6 || s20 < 0.6
      // ) {
      // if (angle0.isShown) {
      // Make angles consistent with 180


      var tot = a0 + a1 + a2;
      var diff = tot - 180; // If the angles are > 180, then find the closet angle
      // to rounding down and reduce it by diff
      // If the angles are < 180 then find the closes angle
      // to round down and round it down

      var remainders = [Object(_tools_math__WEBPACK_IMPORTED_MODULE_2__["round"])(clipAngle0, anglePrecision + 1), Object(_tools_math__WEBPACK_IMPORTED_MODULE_2__["round"])(clipAngle1, anglePrecision + 1), Object(_tools_math__WEBPACK_IMPORTED_MODULE_2__["round"])(clipAngle2, anglePrecision + 1)].map(function (a) {
        return a - Math.floor(a * Math.pow(10, anglePrecision)) / Math.pow(10, anglePrecision);
      });
      var angles = [a0, a1, a2];
      var indexToChange = 0;

      if (tot > 180) {
        indexToChange = remainders.reduce(function (iMax, x, i, arr) {
          return x > arr[iMax] ? i : iMax;
        }, 0);
      } else if (tot < 180) {
        indexToChange = remainders.reduce(function (iMin, x, i, arr) {
          return x < arr[iMin] ? i : iMin;
        }, 1);
      }

      angles[indexToChange] -= diff;
      a0 = angles[0];
      a1 = angles[1];
      a2 = angles[2];
      angle0.setLabel("".concat(a0.toFixed(anglePrecision), "\xBA"));
      angle1.setLabel("".concat(a1.toFixed(anglePrecision), "\xBA"));
      angle2.setLabel("".concat(a2.toFixed(anglePrecision), "\xBA"));
      angle0.checkLabelForRightAngle();
      angle1.checkLabelForRightAngle();
      angle2.checkLabelForRightAngle();

      if (this.makeValid != null) {
        var minSide = this.makeValid.hide.minSide;
        var _this$makeValid$hide = this.makeValid.hide,
            minAngle = _this$makeValid$hide.minAngle,
            maxAngle = _this$makeValid$hide.maxAngle;
        var hideAngles = false;

        if (minAngle != null) {
          minAngle *= 180 / Math.PI;

          if (a0 < minAngle || a1 < minAngle || a2 < minAngle) {
            hideAngles = true;
          }
        }

        if (maxAngle != null) {
          maxAngle *= 180 / Math.PI;

          if (a0 > maxAngle || a1 > maxAngle || a2 > maxAngle) {
            hideAngles = true;
          }
        }

        if (minSide != null && (s01 < minSide || s12 < minSide || s20 < minSide)) {
          hideAngles = true;
        }

        if (hideAngles) {
          this.hideAngles();
        }
      } // Make sides consistent with equilateral or isosceles


      if ((side01.isShown || side12.isShown || side20.isShown) && a0 > 0 && a0 < 180 && a1 > 0 && a1 < 180 && a2 > 0 && a2 < 180) {
        // s12 = round(
        //   s01 / Math.sin(a2 * Math.PI / 180) * Math.sin(a0 * Math.PI / 180),
        //   sidePrecision,
        // );
        // s20 = round(
        //   s01 / Math.sin(a2 * Math.PI / 180) * Math.sin(a1 * Math.PI / 180),
        //   sidePrecision,
        // );
        var leastSigStep = 1 / Math.pow(10, sidePrecision); // If Equilateral, make all sides equal

        if (a0 === 60 && a1 === 60 && a2 === 60) {
          s12 = s01;
          s20 = s01; // If Isosceles possibility 1:
        } else if (a0 === a1) {
          s20 = s12;

          if (s01 === s12) {
            var moreAccurate = Object(_tools_math__WEBPACK_IMPORTED_MODULE_2__["round"])(side01.getLength(), sidePrecision + 1);

            if (moreAccurate < s01) {
              s01 -= leastSigStep;
            } else {
              s01 += leastSigStep;
            }
          } // If Isosceles possibility 2:

        } else if (a0 === a2) {
          s01 = s12;

          if (s20 === s12) {
            var _moreAccurate = Object(_tools_math__WEBPACK_IMPORTED_MODULE_2__["round"])(side20.getLength(), sidePrecision + 1);

            if (_moreAccurate < s20) {
              s20 -= leastSigStep;
            } else {
              s20 += leastSigStep;
            }
          } // If Isosceles possibility 3:

        } else if (a1 === a2) {
          s20 = s01;

          if (s12 === s01) {
            var _moreAccurate2 = Object(_tools_math__WEBPACK_IMPORTED_MODULE_2__["round"])(side12.getLength(), sidePrecision + 1);

            if (_moreAccurate2 < s12) {
              s12 -= leastSigStep;
            } else {
              s12 += leastSigStep;
            }
          } // If these are not equilateral, or isosceles, then all sides must be different length

        }
      } // if (s01 === Infinity) {
      //   s01 = round(side01.getLength(), sidePrecision);
      // }
      // if (s12 === Infinity) {
      //   s12 = round(side12.getLength(), sidePrecision);
      // }
      // if (s20 === Infinity) {
      //   s20 = round(side20.getLength(), sidePrecision);
      // }


      side01.setLabel("".concat(s01.toFixed(sidePrecision)));
      side12.setLabel("".concat(s12.toFixed(sidePrecision)));
      side20.setLabel("".concat(s20.toFixed(sidePrecision))); // }
    }
  }]);

  return DiagramObjectPolyLine;
}(_Element__WEBPACK_IMPORTED_MODULE_3__["DiagramElementCollection"]);



/***/ }),

/***/ "./src/js/diagram/DiagramPrimitives/DiagramPrimitives.js":
/*!***************************************************************!*\
  !*** ./src/js/diagram/DiagramPrimitives/DiagramPrimitives.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DiagramPrimitives; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_htmlGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/htmlGenerator */ "./src/js/tools/htmlGenerator.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _DrawContext2D__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../DrawContext2D */ "./src/js/diagram/DrawContext2D.js");
/* harmony import */ var _tools_math__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../tools/math */ "./src/js/tools/math.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _DrawingObjects_VertexObject_VertexObject__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../DrawingObjects/VertexObject/VertexObject */ "./src/js/diagram/DrawingObjects/VertexObject/VertexObject.js");
/* harmony import */ var _DiagramElements_Fan__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../DiagramElements/Fan */ "./src/js/diagram/DiagramElements/Fan.js");
/* harmony import */ var _DiagramElements_RadialLines__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../DiagramElements/RadialLines */ "./src/js/diagram/DiagramElements/RadialLines.js");
/* harmony import */ var _DiagramElements_HorizontalLine__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../DiagramElements/HorizontalLine */ "./src/js/diagram/DiagramElements/HorizontalLine.js");
/* harmony import */ var _DiagramElements_DashedLine__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../DiagramElements/DashedLine */ "./src/js/diagram/DiagramElements/DashedLine.js");
/* harmony import */ var _DiagramElements_RectangleFilled__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../DiagramElements/RectangleFilled */ "./src/js/diagram/DiagramElements/RectangleFilled.js");
/* harmony import */ var _DiagramElements_Rectangle__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../DiagramElements/Rectangle */ "./src/js/diagram/DiagramElements/Rectangle.js");
/* harmony import */ var _DiagramElements_Generic__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../DiagramElements/Generic */ "./src/js/diagram/DiagramElements/Generic.js");
/* harmony import */ var _DiagramElements_Box__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../DiagramElements/Box */ "./src/js/diagram/DiagramElements/Box.js");
/* harmony import */ var _DiagramElements_Lines__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../DiagramElements/Lines */ "./src/js/diagram/DiagramElements/Lines.js");
/* harmony import */ var _DiagramElements_Arrow__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../DiagramElements/Arrow */ "./src/js/diagram/DiagramElements/Arrow.js");
/* harmony import */ var _DiagramElements_Plot_AxisProperties__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../DiagramElements/Plot/AxisProperties */ "./src/js/diagram/DiagramElements/Plot/AxisProperties.js");
/* harmony import */ var _DiagramElements_Plot_Axis__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../DiagramElements/Plot/Axis */ "./src/js/diagram/DiagramElements/Plot/Axis.js");
/* harmony import */ var _DiagramElements_Text__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../DiagramElements/Text */ "./src/js/diagram/DiagramElements/Text.js");
/* harmony import */ var _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../DrawingObjects/TextObject/TextObject */ "./src/js/diagram/DrawingObjects/TextObject/TextObject.js");
/* harmony import */ var _DrawingObjects_HTMLObject_HTMLObject__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../DrawingObjects/HTMLObject/HTMLObject */ "./src/js/diagram/DrawingObjects/HTMLObject/HTMLObject.js");
/* harmony import */ var _DrawingObjects_Geometries_lines_lines__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../DrawingObjects/Geometries/lines/lines */ "./src/js/diagram/DrawingObjects/Geometries/lines/lines.js");
/* harmony import */ var _DrawingObjects_Geometries_polygon_polygon__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../DrawingObjects/Geometries/polygon/polygon */ "./src/js/diagram/DrawingObjects/Geometries/polygon/polygon.js");
/* harmony import */ var _DrawingObjects_Geometries_copy_copy__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../DrawingObjects/Geometries/copy/copy */ "./src/js/diagram/DrawingObjects/Geometries/copy/copy.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

 // import {
//   round
// } from '../../tools/math';







 // import {
//   PolyLine, PolyLineCorners,
// } from '../DiagramElements/PolyLine';

 // import {
//   Polygon, PolygonFilled, PolygonLine,
// } from '../DiagramElements/Polygon';







 // import type { TypeRectangleFilledReference } from '../DiagramElements/RectangleFilled';











/**
  Curved Corner Definition
 */

// export type TypePointTransforms = {
//   offset?: TypeParsablePoint,
//   transform?: Transform,
//   repeatRect?: {
//     xNum?: number,
//     xStep?: number,
//     yNum?: number,
//     yStep?: number,
//   },
//   repeatPolar?: {
//     magNum?: number,
//     magStep?: number,
//     angleNum?: number,
//     angleStep?: number,
//     angleStart?: number,
//   },
//   repeatTransforms?: Array<Transform>,
// };
// export type TypeCopyLinear = {
//   num?: number,
//   step?: number,
//   angle?: number,
//   axis?: 'x' | 'y',
// }
// export type TypeCopyRadial = {
//   numMag?: number,
//   numAngle?: number,
//   stepMag?: number,
//   stepAngle?: number,
//   startAngle?: number,
// }
// export type TypeCopyOffset = {
//   offset: TypeParsablePoint,
// };
// export type TypeCopyTransform = {
//   transform: Transform;
// }
// export type TypeCopy = Array<Transform> | Array<Point> | TypeCopyRadial
//                        | TypeCopyLinear | Point | Transform | TypeCopyOffset
//                        | TypeCopyTransform;
// export type TypePointTransforms1 = {
//   offset?: TypeParsablePoint,
//   transform?: Transform,
//   copy: {
//     xNum?: number,
//     xStep?: number,
//     yNum?: number,
//     yStep?: number,
//     magNum?: number,
//     magStep?: number,
//     angleNum?: number,
//     angleStep?: number,
//     angleStart?: number,
//     transforms?: Array<Transform>,
//   },
//   copy: TypeCopy | Array<TypeCopy>,
// };
function parsePoints(options, keysToParsePointsOrPointArrays) {
  var parseKey = function parseKey(key) {
    var value = options[key];

    if (value == null) {
      return;
    }

    if (typeof value === 'string') {
      return;
    }

    var processArray = function processArray(a) {
      for (var i = 0; i < a.length; i += 1) {
        if (Array.isArray(a[i]) && !(typeof a[i][0] === 'number')) {
          // eslint-disable-next-line no-param-reassign
          a[i] = processArray(a[i]);
        } else {
          // eslint-disable-next-line no-param-reassign
          a[i] = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(a[i]);
        }
      }

      return a;
    };

    if (Array.isArray(value) && !(typeof value[0] === 'number')) {
      // eslint-disable-next-line no-param-reassign
      options[key] = processArray(value); // value.map(p => getPoint(p));
    } else {
      // eslint-disable-next-line no-param-reassign
      options[key] = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(value);
    }
  };

  if (typeof keysToParsePointsOrPointArrays === 'string') {
    parseKey(keysToParsePointsOrPointArrays);
  } else {
    keysToParsePointsOrPointArrays.forEach(function (key) {
      return parseKey(key);
    });
  }
}

function processOptions() {
  for (var _len = arguments.length, optionsIn = new Array(_len), _key = 0; _key < _len; _key++) {
    optionsIn[_key] = arguments[_key];
  }

  var options = _tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"].apply(void 0, [{}].concat(optionsIn));

  if (options.position != null) {
    var p = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(options.position);

    if (options.transform == null) {
      options.transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('processOptions').translate(0, 0);
    }

    options.transform.updateTranslation(p);
  }

  return options;
}

var DiagramPrimitives =
/*#__PURE__*/
function () {
  function DiagramPrimitives(webgl, draw2D, // draw2DFigures: Object,
  htmlCanvas, limits, spaceTransforms, animateNextFrame) {
    _classCallCheck(this, DiagramPrimitives);

    if (Array.isArray(webgl)) {
      this.webgl = webgl;
    } else {
      this.webgl = [webgl];
    } // this.webgl = webgl;


    if (Array.isArray(draw2D)) {
      this.draw2D = draw2D;
    } else {
      this.draw2D = [draw2D];
    }

    this.htmlCanvas = htmlCanvas;
    this.limits = limits;
    this.animateNextFrame = animateNextFrame;
    this.spaceTransforms = spaceTransforms; // this.draw2DFigures = draw2DFigures;
  }

  _createClass(DiagramPrimitives, [{
    key: "generic",
    value: function generic() {
      var defaultOptions = {
        points: [],
        border: null,
        hole: null,
        drawType: 'triangles',
        color: [1, 0, 0, 1],
        transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('generic').standard(),
        position: null,
        texture: {
          src: '',
          mapTo: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](-1, -1, 2, 2),
          mapFrom: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](0, 0, 1, 1),
          repeat: false,
          onLoad: this.animateNextFrame
        }
      };

      for (var _len2 = arguments.length, optionsIn = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        optionsIn[_key2] = arguments[_key2];
      }

      var options = _tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"].apply(void 0, [defaultOptions].concat(optionsIn));

      if (options.position != null) {
        var p = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(options.position);
        options.transform.updateTranslation(p);
      }

      var parsedPoints = options.points.map(function (p) {
        return Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(p);
      });

      var parseBorder = function parseBorder(borders) {
        if (borders == null || !Array.isArray(borders)) {
          return null;
        }

        var borderOut = [];
        borders.forEach(function (b) {
          if (Array.isArray(b)) {
            borderOut.push(b.map(function (bElement) {
              return Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(bElement);
            }));
          }
        });
        return borderOut;
      };

      var parsedBorder = parseBorder(options.border);
      var parsedBorderHoles = parseBorder(options.hole);
      var copyToUse = options.copy;

      if (options.copy != null && !Array.isArray(options.copy)) {
        copyToUse = [options.copy];
      }

      var element = Object(_DiagramElements_Generic__WEBPACK_IMPORTED_MODULE_14__["default"])(this.webgl, parsedPoints, parsedBorder, parsedBorderHoles, options.drawType, options.color, options.transform, this.limits, options.texture.src, options.texture.mapTo, options.texture.mapFrom, options.texture.repeat, options.texture.onLoad, copyToUse);

      if (options.pulse != null) {
        if (typeof element.pulseDefault !== 'function') {
          element.pulseDefault.scale = options.pulse;
        }
      }

      return element;
    }
  }, {
    key: "polyline",
    value: function polyline() {
      var defaultOptions = {
        width: 0.01,
        color: [1, 0, 0, 1],
        close: false,
        widthIs: 'mid',
        cornerStyle: 'auto',
        cornerSize: 0.01,
        cornerSides: 10,
        cornersOnly: false,
        cornerLength: 0.1,
        // forceCornerLength: false,
        minAutoCornerAngle: Math.PI / 7,
        dash: [],
        linePrimitives: false,
        lineNum: 1,
        transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('polyline').standard(),
        border: 'line',
        hole: 'none' // repeat: null,

      };

      for (var _len3 = arguments.length, optionsIn = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        optionsIn[_key3] = arguments[_key3];
      }

      var options = processOptions.apply(void 0, [defaultOptions].concat(optionsIn));
      parsePoints(options, ['points', 'border', 'hole']);

      if (options.linePrimitives === false) {
        options.lineNum = 2;
      }

      var getTris;

      if (options.cornersOnly) {
        getTris = function getTris(points) {
          return Object(_DrawingObjects_Geometries_lines_lines__WEBPACK_IMPORTED_MODULE_23__["makePolyLineCorners"])(points, options.width, options.close, options.cornerLength, // options.forceCornerLength,
          options.widthIs, options.cornerStyle, options.cornerSize, options.cornerSides, options.minAutoCornerAngle, options.linePrimitives, options.lineNum);
        };
      } else {
        getTris = function getTris(points) {
          return Object(_DrawingObjects_Geometries_lines_lines__WEBPACK_IMPORTED_MODULE_23__["makePolyLine"])(points, options.width, options.close, options.widthIs, options.cornerStyle, options.cornerSize, options.cornerSides, options.minAutoCornerAngle, options.dash, options.linePrimitives, options.lineNum, options.border, options.hole);
        };
      }

      var _getTris = getTris(options.points),
          _getTris2 = _slicedToArray(_getTris, 3),
          triangles = _getTris2[0],
          borders = _getTris2[1],
          holes = _getTris2[2];

      var element = this.generic(options, {
        drawType: options.linePrimitives ? 'lines' : 'triangles',
        points: triangles,
        // $FlowFixMe
        border: Array.isArray(options.border) ? options.border : borders,
        holeBorder: Array.isArray(options.hole) ? options.hole : holes // repeat: options.repeat,

      });

      element.custom.updatePoints = function (points) {
        var _element$drawingObjec;

        (_element$drawingObjec = element.drawingObject).change.apply(_element$drawingObjec, _toConsumableArray(getTris(points)));
      };

      if (options.pulse != null) {
        if (typeof element.pulseDefault !== 'function') {
          element.pulseDefault.scale = options.pulse;
        }
      }

      return element;
    }
  }, {
    key: "polygon",
    value: function polygon() {
      var defaultOptions = {
        radius: 1,
        sides: 4,
        direction: 1,
        // sidesToDraw: 4,
        rotation: 0,
        width: 0.01,
        line: {
          widthIs: 'inside'
        },
        // angle: Math.PI * 2,
        offset: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
        transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('polygon').standard(),
        touchableLineOnly: false
      };

      for (var _len4 = arguments.length, optionsIn = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        optionsIn[_key4] = arguments[_key4];
      }

      var options = processOptions.apply(void 0, [defaultOptions].concat(optionsIn));
      parsePoints(options, ['offset']);
      var element;

      if (options.angleToDraw != null) {
        options.sidesToDraw = Math.floor(options.angleToDraw / (Math.PI * 2 / options.sides));
      }

      if (options.sidesToDraw == null) {
        options.sidesToDraw = options.sides;
      }

      if (options.fill) {
        var fan = Object(_DrawingObjects_Geometries_polygon_polygon__WEBPACK_IMPORTED_MODULE_24__["getFanTrisPolygon"])(options.radius, options.rotation, options.offset, options.sides, options.sidesToDraw, options.direction);
        element = this.generic(options, {
          drawType: 'fan',
          points: fan,
          // $FlowFixMe
          border: [_toConsumableArray(fan.slice(1, -1))]
        });
      } else {
        var polygonPoints = Object(_DrawingObjects_Geometries_polygon_polygon__WEBPACK_IMPORTED_MODULE_24__["getPolygonPoints"])(options.radius, options.rotation, options.offset, options.sides, options.sidesToDraw, options.direction);
        var border = 'line';
        var hole;

        if (options.direction === 1) {
          border = 'negative';
          hole = 'positive';
        }

        if (options.direction === -1) {
          border = 'positive';
          hole = 'negative';
        }

        element = this.polyline(options, options.line, {
          points: polygonPoints,
          close: options.sides === options.sidesToDraw,
          border: border,
          hole: hole
        });
      }

      return element;
    }
  }, {
    key: "grid",
    value: function grid() {
      var defaultOptions = {
        bounds: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](-1, -1, 2, 2),
        width: 0.005,
        transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('grid').standard(),
        dash: [],
        linePrimitives: false,
        lineNum: 2
      };

      for (var _len5 = arguments.length, optionsIn = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        optionsIn[_key5] = arguments[_key5];
      }

      var options = processOptions.apply(void 0, [defaultOptions].concat(optionsIn));
      parsePoints(options, []);
      options.bounds = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getRect"])(options.bounds);

      var getTris = function getTris(points) {
        return Object(_DrawingObjects_Geometries_lines_lines__WEBPACK_IMPORTED_MODULE_23__["makePolyLine"])(points, options.width, false, 'mid', 'auto', // cornerStyle doesn't matter
        0.1, // cornerSize doesn't matter
        1, // cornerSides,
        Math.PI / 7, // minAutoCornerAngle,
        options.dash, options.linePrimitives, options.lineNum, [[]], [[]]);
      }; // Prioritize Num over Step. Only define Num from Step if Num is undefined.


      var bounds = options.bounds;
      var xStep = options.xStep,
          xNum = options.xNum,
          yStep = options.yStep,
          yNum = options.yNum,
          width = options.width;

      if (options.linePrimitives && options.lineNum === 1) {
        width = 0;
      }

      var totWidth = bounds.width;
      var totHeight = bounds.height;

      if (xStep != null && xNum == null) {
        xNum = xStep === 0 ? 1 : 1 + Math.floor((totWidth + xStep * 0.1) / xStep);
      }

      if (yStep != null && yNum == null) {
        yNum = yStep === 0 ? 1 : 1 + Math.floor((totHeight + yStep * 0.1) / yStep);
      }

      if (xNum == null) {
        xNum = 2;
      }

      if (yNum == null) {
        yNum = 2;
      }

      xStep = xNum < 2 ? 0 : totWidth / (xNum - 1);
      yStep = yNum < 2 ? 0 : totHeight / (yNum - 1);
      var start = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](bounds.left, bounds.bottom);
      var xLineStart = start.add(-width / 2, 0);
      var xLineStop = start.add(totWidth + width / 2, 0);
      var yLineStart = start.add(0, -width / 2);
      var yLineStop = start.add(0, totHeight + width / 2);
      var xTris = [];
      var yTris = [];

      if (xNum > 0) {
        var _getTris3 = getTris([yLineStart, yLineStop]),
            _getTris4 = _slicedToArray(_getTris3, 1),
            yLine = _getTris4[0];

        yTris = Object(_DrawingObjects_Geometries_copy_copy__WEBPACK_IMPORTED_MODULE_25__["copyPoints"])(yLine, [{
          along: 'x',
          num: xNum - 1,
          step: xStep
        }]);
      }

      if (yNum > 0) {
        var _getTris5 = getTris([xLineStart, xLineStop]),
            _getTris6 = _slicedToArray(_getTris5, 1),
            xLine = _getTris6[0];

        xTris = Object(_DrawingObjects_Geometries_copy_copy__WEBPACK_IMPORTED_MODULE_25__["copyPoints"])(xLine, [{
          along: 'y',
          num: yNum - 1,
          step: yStep
        }]);
      }

      var element = this.generic(options, {
        drawType: options.linePrimitives ? 'lines' : 'triangles',
        // $FlowFixMe
        points: [].concat(_toConsumableArray(xTris), _toConsumableArray(yTris)),
        border: [[start.add(-width / 2, -width / 2), start.add(totWidth + width / 2, -width / 2), start.add(totWidth + width / 2, totHeight + width / 2), start.add(-width / 2, totHeight + width / 2)]]
      });
      return element;
    }
  }, {
    key: "polygonSweep",
    value: function polygonSweep() {
      var defaultOptions = {
        sides: 4,
        fill: false,
        transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('polygonSweep').standard(),
        line: {
          linePrimitives: false,
          lineNum: 2
        }
      };
      var forceOptions = {
        line: {
          cornerStyle: 'auto',
          cornersOnly: false
        }
      };

      for (var _len6 = arguments.length, optionsIn = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        optionsIn[_key6] = arguments[_key6];
      }

      var options = processOptions.apply(void 0, [defaultOptions].concat(optionsIn, [forceOptions]));
      var element = this.polygon(options); // $FlowFixMe

      element.drawingObject.getPointCountForAngle = function (angle) {
        var sidesToDraw = Math.floor(_tools_math__WEBPACK_IMPORTED_MODULE_5__["round"](angle) / _tools_math__WEBPACK_IMPORTED_MODULE_5__["round"](Math.PI * 2) * options.sides);

        if (options.fill) {
          return sidesToDraw + 2;
        }

        if (options.line && options.line.linePrimitives) {
          return sidesToDraw * options.line.lineNum * 2;
        }

        return sidesToDraw * 6;
      };

      return element;
    }
  }, {
    key: "fan",
    value: function fan() {
      var defaultOptions = {
        points: [],
        color: [1, 0, 0, 1],
        transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('fan').standard(),
        position: null
      };

      for (var _len7 = arguments.length, optionsIn = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        optionsIn[_key7] = arguments[_key7];
      }

      var options = Object.assign.apply(Object, [{}, defaultOptions].concat(optionsIn));

      if (options.position != null) {
        var p = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(options.position);
        options.transform.updateTranslation(p);
      }

      var element = Object(_DiagramElements_Fan__WEBPACK_IMPORTED_MODULE_8__["default"])(this.webgl, options.points.map(function (p) {
        return Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(p);
      }), options.color, options.transform, this.limits);

      if (options.pulse != null) {
        if (typeof element.pulseDefault !== 'function') {
          element.pulseDefault.scale = options.pulse;
        }
      }

      if (options.mods != null && options.mods !== {}) {
        element.setProperties(options.mods);
      }

      return element;
    }
  }, {
    key: "textGL",
    value: function textGL(options) {
      return Object(_DiagramElements_Text__WEBPACK_IMPORTED_MODULE_20__["default"])(this.webgl, this.limits, options);
    }
  }, {
    key: "text",
    value: function text(textOrOptions) {
      var defaultOptions = {
        text: '',
        // position: new Point(0, 0),
        font: null,
        family: 'Times New Roman',
        style: 'italic',
        size: 0.2,
        weight: '200',
        xAlign: 'center',
        yAlign: 'middle',
        offset: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
        // vertex space offset
        color: [1, 0, 0, 1],
        transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('text').standard() // draw2D: this.draw2D,

      };
      var options;

      for (var _len8 = arguments.length, optionsIn = new Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {
        optionsIn[_key8 - 1] = arguments[_key8];
      }

      if (typeof textOrOptions === 'string') {
        options = _tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"].apply(void 0, [{}, defaultOptions, {
          text: textOrOptions
        }].concat(optionsIn));
      } else {
        options = _tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"].apply(void 0, [{}, defaultOptions, textOrOptions].concat(optionsIn));
      }

      if (options.position != null) {
        var p = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(options.position);
        options.transform.updateTranslation(p);
      }

      var o = options;
      var text = o.text;
      var fontToUse = o.font;

      if (fontToUse === null) {
        fontToUse = new _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_21__["DiagramFont"](o.family, o.style, o.size, o.weight, o.xAlign, o.yAlign, o.color);
      }

      var dT = new _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_21__["DiagramText"](o.offset, text, fontToUse);
      var to = new _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_21__["TextObject"](this.draw2D, [dT]);
      var element = new _Element__WEBPACK_IMPORTED_MODULE_2__["DiagramElementPrimitive"](to, o.transform, o.color, this.limits);

      if (options.pulse != null) {
        if (typeof element.pulseDefault !== 'function') {
          element.pulseDefault.scale = options.pulse;
        }
      }

      if (options.mods != null && options.mods !== {}) {
        element.setProperties(options.mods);
      }

      return element;
    }
  }, {
    key: "arrow",
    value: function arrow() {
      var defaultOptions = {
        width: 0.5,
        legWidth: 0,
        height: 0.5,
        legHeight: 0,
        color: [1, 0, 0, 1],
        transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('arrow').standard(),
        tip: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
        rotation: 0
      };

      for (var _len9 = arguments.length, optionsIn = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
        optionsIn[_key9] = arguments[_key9];
      }

      var options = Object.assign.apply(Object, [{}, defaultOptions].concat(optionsIn));

      if (options.position != null) {
        var p = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(options.position);
        options.transform.updateTranslation(p);
      }

      var element = new _DiagramElements_Arrow__WEBPACK_IMPORTED_MODULE_17__["default"](this.webgl, options.width, options.legWidth, options.height, options.legHeight, Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(options.tip), options.rotation, options.color, options.transform, this.limits);

      if (options.pulse != null) {
        if (typeof element.pulseDefault !== 'function') {
          element.pulseDefault.scale = options.pulse;
        }
      }

      if (options.mods != null && options.mods !== {}) {
        element.setProperties(options.mods);
      }

      return element;
    } // arrowLegacy(
    //   width: number = 1,
    //   legWidth: number = 0.5,
    //   height: number = 1,
    //   legHeight: number = 0.5,
    //   color: Array<number>,
    //   transform: Transform | Point = new Transform(),
    //   tip: Point = new Point(0, 0),
    //   rotation: number = 0,
    // ) {
    //   return Arrow(
    //     this.webgl, width, legWidth, height, legHeight,
    //     tip, rotation, color, transform, this.limits,
    //   );
    // }
    // textLegacy(
    //   textInput: string,
    //   location: Point,
    //   color: Array<number>,
    //   fontInput: DiagramFont | null = null,
    // ) {
    //   let font = new DiagramFont(
    //     'Times New Roman',
    //     'italic',
    //     0.2,
    //     '200',
    //     'center',
    //     'middle',
    //     color,
    //   );
    //   if (fontInput !== null) {
    //     font = fontInput;
    //   }
    //   const dT = new DiagramText(new Point(0, 0), textInput, font);
    //   const to = new TextObject(this.draw2D, [dT]);
    //   return new DiagramElementPrimitive(
    //     to,
    //     new Transform().scale(1, 1).translate(location.x, location.y),
    //     color,
    //     this.limits,
    //   );
    // }

  }, {
    key: "htmlElement",
    value: function htmlElement(elementToAdd) {
      var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "id__temp_".concat(Math.round(Math.random() * 10000));
      var classes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      var location = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      var yAlign = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'middle';
      var xAlign = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'left';
      var element = document.createElement('div');

      if (classes && element) {
        var classArray = classes.split(' ');
        classArray.forEach(function (c) {
          return element.classList.add(c.trim());
        });
      }

      if (Array.isArray(elementToAdd)) {
        elementToAdd.forEach(function (e) {
          return element.appendChild(e);
        });
      } else {
        element.appendChild(elementToAdd);
      }

      element.style.position = 'absolute';
      element.setAttribute('id', id);
      this.htmlCanvas.appendChild(element);
      var hT = new _DrawingObjects_HTMLObject_HTMLObject__WEBPACK_IMPORTED_MODULE_22__["default"](this.htmlCanvas, id, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), yAlign, xAlign);
      var diagramElement = new _Element__WEBPACK_IMPORTED_MODULE_2__["DiagramElementPrimitive"](hT, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(1, 1).translate(location.x, location.y), [1, 1, 1, 1], this.limits); // console.log('html', diagramElement.transform.mat, location)
      // diagramElement.setFirstTransform();

      return diagramElement;
    } // htmlText(
    //   textInput: string,
    //   id: string = generateUniqueId('id__html_text_'),
    //   classes: string = '',
    //   location: Point = new Point(0, 0),
    //   yAlign: 'top' | 'bottom' | 'middle' = 'middle',
    //   xAlign: 'left' | 'right' | 'center' = 'left',
    // ) {
    //   // const inside = document.createTextNode(textInput);
    //   const inside = document.createElement('div');
    //   inside.innerHTML = textInput;
    //   return this.htmlElement(inside, id, classes, location, yAlign, xAlign);
    // }

  }, {
    key: "htmlImage",
    value: function htmlImage() {
      var defaultOptions = {
        id: Object(_tools_tools__WEBPACK_IMPORTED_MODULE_6__["generateUniqueId"])('id__html_image_'),
        classes: '',
        position: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
        yAlign: 'middle',
        xAlign: 'left',
        src: '' // color: [1, 0, 0, 1],

      };

      for (var _len10 = arguments.length, optionsIn = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
        optionsIn[_key10] = arguments[_key10];
      }

      var options = _tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));
      var image = document.createElement('img');
      image.src = options.src; // setHTML(inside, options.text, options.modifiers);

      var id = options.id,
          classes = options.classes,
          position = options.position,
          yAlign = options.yAlign,
          xAlign = options.xAlign;
      var element = this.htmlElement(image, id, classes, Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(position), yAlign, xAlign);

      if (options.color != null) {
        element.setColor(options.color);
      }

      if (options.pulse != null) {
        if (typeof element.pulseDefault !== 'function') {
          element.pulseDefault.scale = options.pulse;
        }
      }

      return element;
    }
  }, {
    key: "htmlText",
    value: function htmlText() {
      var defaultOptions = {
        text: '',
        id: Object(_tools_tools__WEBPACK_IMPORTED_MODULE_6__["generateUniqueId"])('id__html_text_'),
        classes: '',
        position: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
        yAlign: 'middle',
        xAlign: 'left' // color: [1, 0, 0, 1],

      };

      for (var _len11 = arguments.length, optionsIn = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
        optionsIn[_key11] = arguments[_key11];
      }

      var options = _tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));
      var inside = document.createElement('div'); // const htmlText = toHTML(options.textInput, '', '', options.color);
      // console.log(options.textInput, htmlText)

      Object(_tools_htmlGenerator__WEBPACK_IMPORTED_MODULE_1__["setHTML"])(inside, options.text, options.modifiers);
      var id = options.id,
          classes = options.classes,
          position = options.position,
          yAlign = options.yAlign,
          xAlign = options.xAlign;
      var element = this.htmlElement(inside, id, classes, Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(position), yAlign, xAlign);

      if (options.color != null) {
        element.setColor(options.color);
      }

      if (options.pulse != null) {
        if (typeof element.pulseDefault !== 'function') {
          element.pulseDefault.scale = options.pulse;
        }
      }

      return element;
    }
  }, {
    key: "lines",
    value: function lines(linePairs) {
      var numLinesThick = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var color = arguments.length > 2 ? arguments[2] : undefined;
      var transform = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();
      return Object(_DiagramElements_Lines__WEBPACK_IMPORTED_MODULE_16__["default"])(this.webgl, linePairs, numLinesThick, color, transform, this.limits);
    } // gridLegacy(...optionsIn: Array<TypeGridOptions>) {
    //   const defaultOptions = {
    //     bounds: new Rect(-1, -1, 2, 2),
    //     xStep: 0.1,
    //     yStep: 0.1,
    //     xOffset: 0,
    //     yOffset: 0,
    //     numLinesThick: 1,
    //     color: [1, 0, 0, 1],
    //     position: null,
    //     transform: new Transform('grid').standard(),
    //   };
    //   const options = joinObjects({}, defaultOptions, ...optionsIn);
    //   if (options.position != null) {
    //     const point = getPoint(options.position);
    //     options.transform.updateTranslation(point);
    //   }
    //   const linePairs = [];
    //   // const xLimit = tools.roundNum(bounds.righ + xStep);
    //   const {
    //     bounds, xStep, xOffset, yStep, yOffset, color, numLinesThick, transform,
    //   } = options;
    //   if (options.xStep !== 0) {
    //     for (let x = bounds.left + xOffset; tools.roundNum(x, 8) <= bounds.right; x += xStep) {
    //       linePairs.push([new Point(x, bounds.top), new Point(x, bounds.bottom)]);
    //     }
    //   }
    //   if (yStep !== 0) {
    //     for (let y = bounds.bottom + yOffset; tools.roundNum(y, 8) <= bounds.top; y += yStep) {
    //       linePairs.push([new Point(bounds.left, y), new Point(bounds.right, y)]);
    //     }
    //   }
    //   const element = this.lines(linePairs, numLinesThick, color, transform);
    //   if (options.pulse != null && typeof element.pulseDefault !== 'function') {
    //     element.pulseDefault.scale = options.pulse;
    //   }
    //   return element;
    // }

  }, {
    key: "horizontalLine",
    value: function horizontalLine(start, length, width, rotation, color) {
      var transform = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();
      return Object(_DiagramElements_HorizontalLine__WEBPACK_IMPORTED_MODULE_10__["default"])(this.webgl, start, length, width, rotation, color, transform, this.limits);
    }
  }, {
    key: "dashedLine",
    value: function dashedLine() {
      var defaultOptions = {
        start: [0, 0],
        length: 1,
        width: 0.01,
        rotation: 0,
        dashStyle: [0.1, 0.1],
        transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('dashedLine').scale(1, 1).rotate(0).translate(0, 0),
        position: null
      };

      for (var _len12 = arguments.length, optionsIn = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
        optionsIn[_key12] = arguments[_key12];
      }

      var options = _tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));

      if (options.position != null) {
        options.transform.updateTranslation(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(options.position));
      }

      var element = Object(_DiagramElements_DashedLine__WEBPACK_IMPORTED_MODULE_11__["default"])(this.webgl, Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(options.start), options.length, options.width, options.rotation, options.dashStyle, options.color, options.transform, this.limits);

      if (options.pulse != null && typeof element.pulseDefault !== 'function') {
        element.pulseDefault.scale = options.pulse;
      }

      return element;
    } // dashedLine(
    //   start: Point,
    //   length: number,
    //   width: number,
    //   rotation: number,
    //   dashStyle: Array<number>,
    //   color: Array<number>,
    //   transform: Transform | Point = new Transform(),
    // ) {
    //   return DashedLine(
    //     this.webgl, start, length, width,
    //     rotation, dashStyle, color, transform, this.limits,
    //   );
    // }

  }, {
    key: "rectangle",
    value: function rectangle() {
      var defaultOptions = {
        yAlign: 'middle',
        xAlign: 'center',
        width: 1,
        height: 1,
        lineWidth: 0.01,
        corner: {
          radius: 0,
          sides: 1
        },
        fill: false,
        color: [1, 0, 0, 1],
        transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('rectangle').scale(1, 1).rotate(0).translate(0, 0),
        position: null
      };

      for (var _len13 = arguments.length, optionsIn = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
        optionsIn[_key13] = arguments[_key13];
      }

      var options = _tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));

      if (options.position != null) {
        options.transform.updateTranslation(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(options.position));
      }

      if (typeof options.reference !== 'string') {
        options.reference = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(options.reference);
      }

      var element;

      if (options.fill) {
        element = Object(_DiagramElements_RectangleFilled__WEBPACK_IMPORTED_MODULE_12__["default"])(this.webgl, options.xAlign, options.yAlign, options.width, options.height, options.corner.radius, options.corner.sides, options.color, options.transform, this.limits);
      } else {
        element = Object(_DiagramElements_Rectangle__WEBPACK_IMPORTED_MODULE_13__["default"])(this.webgl, options.xAlign, options.yAlign, options.width, options.height, options.lineWidth, options.corner.radius, options.corner.sides, options.color, options.transform, this.limits);
      }

      if (options.pulse != null && typeof element.pulseDefault !== 'function') {
        element.pulseDefault.scale = options.pulse;
      }

      return element;
    }
  }, {
    key: "box",
    value: function box() {
      var defaultOptions = {
        width: 1,
        height: 1,
        fill: false,
        lineWidth: 0.01,
        color: [1, 0, 0, 1],
        transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(1, 1).rotate(0).translate(0, 0),
        position: null
      };

      for (var _len14 = arguments.length, optionsIn = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {
        optionsIn[_key14] = arguments[_key14];
      }

      var options = _tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));

      if (options.position != null) {
        options.transform.updateTranslation(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(options.position));
      }

      if (typeof options.reference !== 'string') {
        options.reference = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(options.reference);
      }

      var element = Object(_DiagramElements_Box__WEBPACK_IMPORTED_MODULE_15__["default"])(this.webgl, options.width, options.height, options.lineWidth, options.fill, options.color, options.transform, this.limits);

      if (options.pulse != null && typeof element.pulseDefault !== 'function') {
        element.pulseDefault.scale = options.pulse;
      }

      return element;
    }
  }, {
    key: "radialLines",
    value: function radialLines() {
      var defaultOptions = {
        innerRadius: 0,
        outerRadius: 1,
        width: 0.05,
        dAngle: Math.PI / 4,
        angle: Math.PI * 2,
        transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().standard()
      };

      for (var _len15 = arguments.length, optionsIn = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {
        optionsIn[_key15] = arguments[_key15];
      }

      var options = _tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));

      if (options.position != null) {
        options.transform.updateTranslation(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(options.position));
      }

      var element = Object(_DiagramElements_RadialLines__WEBPACK_IMPORTED_MODULE_9__["default"])(this.webgl, options.innerRadius, options.outerRadius, options.width, options.dAngle, options.angle, options.color, options.transform, this.limits);

      if (options.pulse != null && typeof element.pulseDefault !== 'function') {
        element.pulseDefault.scale = options.pulse;
      }

      return element;
    }
  }, {
    key: "repeatPatternVertex",
    value: function repeatPatternVertex() {
      var defaultOptions = {
        element: null,
        xNum: 2,
        yNum: 2,
        xStep: 1,
        yStep: 1,
        transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('repeatPattern').standard()
      };

      for (var _len16 = arguments.length, optionsIn = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {
        optionsIn[_key16] = arguments[_key16];
      }

      var options = _tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));

      if (options.position != null) {
        options.transform.updateTranslation(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(options.position));
      }

      var element = options.element,
          transform = options.transform,
          xNum = options.xNum,
          yNum = options.yNum,
          xStep = options.xStep,
          yStep = options.yStep;

      if (element == null) {
        return this.collection();
      }

      var copy = element._dup();

      var drawingObject = element.drawingObject; // console.log(element.drawingObject.points)

      if (drawingObject instanceof _DrawingObjects_VertexObject_VertexObject__WEBPACK_IMPORTED_MODULE_7__["default"]) {
        copy.transform = transform._dup();
        var newPoints = [];
        var points = drawingObject.points;

        for (var x = 0; x < xNum; x += 1) {
          for (var y = 0; y < yNum; y += 1) {
            for (var p = 0; p < points.length; p += 2) {
              newPoints.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](points[p] + x * xStep, points[p + 1] + y * yStep)); // console.log(points[p], points[p+1], newPoints.slice(-1))
            }
          }
        } // console.log(newPoints)


        copy.drawingObject.changeVertices(newPoints);
      }

      if (options.pulse != null && typeof element.pulseDefault !== 'function') {
        copy.pulseDefault.scale = options.pulse;
      }

      return copy;
    }
  }, {
    key: "collection",
    value: function collection() {
      var transformOrPointOrOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('collection').scale(1, 1).rotate(0).translate(0, 0);
      var color = [1, 0, 0, 1];
      var pulse = null;

      if (transformOrPointOrOptions instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"]) {
        transform.updateTranslation(transformOrPointOrOptions);
      } else if (transformOrPointOrOptions instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]) {
        transform = transformOrPointOrOptions._dup();
      } else {
        for (var _len17 = arguments.length, moreOptions = new Array(_len17 > 1 ? _len17 - 1 : 0), _key17 = 1; _key17 < _len17; _key17++) {
          moreOptions[_key17 - 1] = arguments[_key17];
        }

        var optionsToUse = _tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"].apply(void 0, [transformOrPointOrOptions].concat(moreOptions));

        if (optionsToUse.transform != null) {
          transform = optionsToUse.transform;
        }

        if (optionsToUse.position != null) {
          transform.updateTranslation(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(optionsToUse.position));
        }

        if (optionsToUse.color != null) {
          color = optionsToUse.color;
        }

        if (optionsToUse.pulse != null) {
          pulse = optionsToUse.pulse;
        }
      }

      var element = new _Element__WEBPACK_IMPORTED_MODULE_2__["DiagramElementCollection"](transform, this.limits);
      element.setColor(color);

      if (pulse != null && typeof element.pulseDefault !== 'function') {
        element.pulseDefault.scale = pulse;
      }

      return element;
    }
  }, {
    key: "repeatPattern",
    value: function repeatPattern(element, xNum, yNum, xStep, yStep) {
      var transform = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();
      var group;

      if (transform instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]) {
        group = this.collection({
          transform: transform
        });
      } else {
        group = this.collection({
          transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().translate(transform)
        });
      }

      var t = element.transform.t();

      var transformToUse = element.transform._dup();

      if (t === null) {
        t = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
        transformToUse = transformToUse.translate(0, 0);
      }

      if (t) {
        for (var x = 0; x < xNum; x += 1) {
          for (var y = 0; y < yNum; y += 1) {
            var copy = element._dup();

            copy.transform = transformToUse._dup();
            copy.transform.updateTranslation(t.x + xStep * x, t.y + yStep * y);
            group.add("xy".concat(x).concat(y), copy);
          }
        }
      }

      return group;
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "repeatPatternVertexLegacy",
    value: function repeatPatternVertexLegacy(element, xNum, yNum, xStep, yStep) {
      var transform = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();

      var copy = element._dup();

      var drawingObject = element.drawingObject; // console.log(element.drawingObject.points)

      if (drawingObject instanceof _DrawingObjects_VertexObject_VertexObject__WEBPACK_IMPORTED_MODULE_7__["default"]) {
        copy.transform = transform._dup();
        var newPoints = [];
        var points = drawingObject.points;

        for (var x = 0; x < xNum; x += 1) {
          for (var y = 0; y < yNum; y += 1) {
            for (var p = 0; p < points.length; p += 2) {
              newPoints.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](points[p] + x * xStep, points[p + 1] + y * yStep)); // console.log(points[p], points[p+1], newPoints.slice(-1))
            }
          }
        } // console.log(newPoints)


        copy.drawingObject.changeVertices(newPoints);
      }

      return copy;
    }
  }, {
    key: "axes",
    value: function axes() {
      var defaultOptions = {
        width: 1,
        height: 1,
        limits: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](-1, -1, 2, 2),
        yAxisLocation: 0,
        xAxisLocation: 0,
        stepX: 0.1,
        stepY: 0.1,
        fontSize: 0.13,
        showGrid: true,
        color: [1, 1, 1, 0],
        location: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"](),
        decimalPlaces: 1,
        lineWidth: 0.01
      };

      for (var _len18 = arguments.length, optionsIn = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {
        optionsIn[_key18] = arguments[_key18];
      }

      var options = _tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));

      if (options.fontColor == null) {
        options.fontColor = options.color.slice();
      }

      if (options.gridColor == null) {
        options.gridColor = options.color.slice();
      }

      var width = options.width,
          lineWidth = options.lineWidth,
          limits = options.limits,
          color = options.color,
          stepX = options.stepX,
          decimalPlaces = options.decimalPlaces,
          yAxisLocation = options.yAxisLocation,
          xAxisLocation = options.xAxisLocation,
          fontSize = options.fontSize,
          height = options.height,
          stepY = options.stepY,
          location = options.location,
          showGrid = options.showGrid,
          gridColor = options.gridColor,
          fontColor = options.fontColor;
      var xProps = new _DiagramElements_Plot_AxisProperties__WEBPACK_IMPORTED_MODULE_18__["AxisProperties"]('x', 0);
      xProps.minorTicks.mode = 'off';
      xProps.minorGrid.mode = 'off';
      xProps.majorGrid.mode = 'off';
      xProps.length = width;
      xProps.width = lineWidth;
      xProps.limits = {
        min: limits.left,
        max: limits.right
      };
      xProps.color = color.slice();
      xProps.title = '';
      xProps.majorTicks.start = limits.left;
      xProps.majorTicks.step = stepX;
      xProps.majorTicks.length = lineWidth * 5;
      xProps.majorTicks.offset = -xProps.majorTicks.length / 2;
      xProps.majorTicks.width = lineWidth * 2;
      xProps.majorTicks.labelMode = 'off';
      xProps.majorTicks.color = color.slice();
      xProps.majorTicks.labels = _tools_math__WEBPACK_IMPORTED_MODULE_5__["range"](xProps.limits.min, xProps.limits.max, stepX).map(function (v) {
        return v.toFixed(decimalPlaces);
      }).map(function (v) {
        if (v === yAxisLocation.toString() && yAxisLocation === xAxisLocation) {
          return "".concat(v, "     ");
        }

        return v;
      }); // xProps.majorTicks.labels[xProps.majorTicks.labels / 2] = '   0';

      xProps.majorTicks.labelOffset = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, xProps.majorTicks.offset - fontSize * 0.1);
      xProps.majorTicks.labelsHAlign = 'center';
      xProps.majorTicks.labelsVAlign = 'top';
      xProps.majorTicks.fontColor = fontColor.slice();
      xProps.majorTicks.fontSize = fontSize;
      xProps.majorTicks.fontWeight = '400';
      var xAxis = new _DiagramElements_Plot_Axis__WEBPACK_IMPORTED_MODULE_19__["default"](this.webgl, this.draw2D, xProps, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(1, 1).rotate(0).translate(0, xAxisLocation - limits.bottom * height / 2), this.limits);
      var yProps = new _DiagramElements_Plot_AxisProperties__WEBPACK_IMPORTED_MODULE_18__["AxisProperties"]('x', 0);
      yProps.minorTicks.mode = 'off';
      yProps.minorGrid.mode = 'off';
      yProps.majorGrid.mode = 'off';
      yProps.length = height;
      yProps.width = xProps.width;
      yProps.limits = {
        min: limits.bottom,
        max: limits.top
      };
      yProps.color = xProps.color;
      yProps.title = '';
      yProps.rotation = Math.PI / 2;
      yProps.majorTicks.step = stepY;
      yProps.majorTicks.start = limits.bottom;
      yProps.majorTicks.length = xProps.majorTicks.length;
      yProps.majorTicks.offset = -yProps.majorTicks.length / 2;
      yProps.majorTicks.width = xProps.majorTicks.width;
      yProps.majorTicks.labelMode = 'off';
      yProps.majorTicks.color = color.slice();
      yProps.majorTicks.labels = _tools_math__WEBPACK_IMPORTED_MODULE_5__["range"](yProps.limits.min, yProps.limits.max, stepY).map(function (v) {
        return v.toFixed(decimalPlaces);
      }).map(function (v) {
        if (v === xAxisLocation.toString() && yAxisLocation === xAxisLocation) {
          return '';
        }

        return v;
      }); // yProps.majorTicks.labels[3] = '';

      yProps.majorTicks.labelOffset = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](yProps.majorTicks.offset - fontSize * 0.2, 0);
      yProps.majorTicks.labelsHAlign = 'right';
      yProps.majorTicks.labelsVAlign = 'middle';
      yProps.majorTicks.fontColor = xProps.majorTicks.fontColor;
      yProps.majorTicks.fontSize = fontSize;
      yProps.majorTicks.fontWeight = xProps.majorTicks.fontWeight;
      var yAxis = new _DiagramElements_Plot_Axis__WEBPACK_IMPORTED_MODULE_19__["default"](this.webgl, this.draw2D, yProps, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(1, 1).rotate(0).translate(yAxisLocation - limits.left * width / 2, 0), this.limits);
      var transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();

      if (location instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"]) {
        transform = transform.translate(location.x, location.y);
      } else {
        transform = location._dup();
      }

      var xy = this.collection(transform);

      if (showGrid) {
        var gridLines = this.grid({
          bounds: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](0, 0, width, height),
          xStep: _tools_math__WEBPACK_IMPORTED_MODULE_5__["roundNum"](stepX * width / limits.width, 8),
          yStep: _tools_math__WEBPACK_IMPORTED_MODULE_5__["roundNum"](stepY * height / limits.height, 8),
          numThickLines: 1,
          // linePrimitives: true,
          // lineNum: 2,
          width: options.lineWidth * 0.6,
          color: gridColor,
          transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(1, 1).rotate(0).translate(0, 0)
        });
        xy.add('grid', gridLines);
      }

      xy.add('y', yAxis);
      xy.add('x', xAxis);

      if (options.pulse != null && typeof xy.pulseDefault !== 'function') {
        xy.pulseDefault.scale = options.pulse;
      }

      return xy;
    }
  }, {
    key: "parallelMarks",
    value: function parallelMarks() {
      var _this = this;

      var defaultOptions = {
        width: 0.01,
        num: 1,
        length: 0.1,
        angle: Math.PI / 4,
        step: 0.04,
        rotation: 0,
        color: [1, 0, 0, 1],
        transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(1, 1).rotate(0).translate(0, 0),
        position: null
      };

      for (var _len19 = arguments.length, optionsIn = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {
        optionsIn[_key19] = arguments[_key19];
      }

      var options = _tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));

      if (options.position != null) {
        options.transform.updateTranslation(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(options.position));
      }

      var x = options.length * Math.cos(options.angle);
      var y = options.length * Math.sin(options.angle);
      var wx = Math.abs(options.width * Math.cos(options.angle + Math.PI / 2));
      var wy = options.width * Math.sin(options.angle + Math.PI / 2);
      var single = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0 - x, 0 - y), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-x - wx, -y + wy), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-Math.abs(options.width / Math.cos(options.angle + Math.PI / 2)), 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-x - wx, y - wy), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0 - x, 0 + y)];
      var collection = this.collection(options.transform);
      collection.setColor(options.color);

      if (options.pulse != null && typeof collection.pulseDefault !== 'function') {
        collection.pulseDefault.scale = options.pulse;
      }

      var start = -((options.num - 1) / 2) * options.step;

      var _loop = function _loop(i) {
        var points = single.map(function (p) {
          return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](p.x + start + i * options.step, p.y).rotate(options.rotation);
        });
        collection.add("".concat(i), _this.fan({
          points: points,
          color: options.color
        }));
      };

      for (var i = 0; i < options.num; i += 1) {
        _loop(i);
      }

      return collection;
    }
  }, {
    key: "marks",
    value: function marks() {
      var _this2 = this;

      var defaultOptions = {
        width: 0.01,
        num: 1,
        length: 0.2,
        angle: Math.PI / 2,
        step: 0.04,
        rotation: 0,
        color: [1, 0, 0, 1],
        transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(1, 1).rotate(0).translate(0, 0),
        position: null
      };

      for (var _len20 = arguments.length, optionsIn = new Array(_len20), _key20 = 0; _key20 < _len20; _key20++) {
        optionsIn[_key20] = arguments[_key20];
      }

      var options = _tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));

      if (options.position != null) {
        options.transform.updateTranslation(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(options.position));
      }

      var single = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](options.length / 2, options.width / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](options.length / 2, -options.width / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-options.length / 2, -options.width / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-options.length / 2, options.width / 2)];
      var collection = this.collection(options.transform);
      collection.setColor(options.color);

      if (options.pulse != null && typeof collection.pulseDefault !== 'function') {
        collection.pulseDefault.scale = options.pulse;
      }

      var start = -((options.num - 1) / 2) * options.step;

      var _loop2 = function _loop2(i) {
        var t = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().rotate(options.angle).translate(start + i * options.step, 0).rotate(options.rotation);
        var points = single.map(function (p) {
          return p._dup().transformBy(t.matrix());
        });
        collection.add("".concat(i), _this2.fan({
          points: points,
          color: options.color
        }));
      };

      for (var i = 0; i < options.num; i += 1) {
        _loop2(i);
      }

      return collection;
    }
  }]);

  return DiagramPrimitives;
}();



/***/ }),

/***/ "./src/js/diagram/DrawContext2D.js":
/*!*****************************************!*\
  !*** ./src/js/diagram/DrawContext2D.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var DrawContext2D =
/*#__PURE__*/
function () {
  function DrawContext2D(canvas) {
    _classCallCheck(this, DrawContext2D);

    this.canvas = canvas;
    this.ctx = this.canvas.getContext('2d');
    /* $FlowFixMe */

    var bsr = this.ctx.webkitBackingStorePixelRatio
    /* $FlowFixMe */
    || this.ctx.mozBackingStorePixelRatio
    /* $FlowFixMe */
    || this.ctx.msBackingStorePixelRatio
    /* $FlowFixMe */
    || this.ctx.oBackingStorePixelRatio
    /* $FlowFixMe */
    || this.ctx.backingStorePixelRatio || 1;
    var dpr = window.devicePixelRatio || 1;

    if (dpr === 1) {
      dpr = 2;
    }

    this.ratio = dpr / bsr;
    this.resize();
  }

  _createClass(DrawContext2D, [{
    key: "resize",
    value: function resize() {
      this.ctx.setTransform(1, 0, 0, 1, 0, 0);
      this.canvas.width = this.canvas.clientWidth * this.ratio;
      this.canvas.height = this.canvas.clientHeight * this.ratio;
      this.ctx.scale(this.ratio, this.ratio);
    }
  }, {
    key: "_dup",
    value: function _dup() {
      return this;
    }
  }]);

  return DrawContext2D;
}();

/* harmony default export */ __webpack_exports__["default"] = (DrawContext2D);

/***/ }),

/***/ "./src/js/diagram/DrawingObjects/DrawingObject.js":
/*!********************************************************!*\
  !*** ./src/js/diagram/DrawingObjects/DrawingObject.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

 // A Drawing object can be:
//  - GL primitive vertices
//  - Text object for 2D drawing contexts
//  - HTML Object in the diagram_html div
//
// It must have:
//
//   Properties:
//     - location     A reference location where relative boundaries are
//                    calculated from
//     - border       Array of borders in Diagram Units
//
//   Methods:
//     - drawWithTransformMatrix(transformMatrix)
//     - calcBorder(lastDrawTransformMatrix, glToDiagramTransform)
//

var DrawingObject =
/*#__PURE__*/
function () {
  // numPoints: number;           // Number of primative vertices
  // Border vertices
  // Border of any holes inside of main border
  // Only used for drawing objects with asynchronous
  //                            loading (like textures)
  function DrawingObject() {
    _classCallCheck(this, DrawingObject);

    // this.numPoints = 0;
    this.location = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
    this.border = [[]];
    this.holeBorder = [[]];
    this.onLoad = null;
    this.type = 'drawingObject';
    this.state = 'loading';
  }

  _createClass(DrawingObject, [{
    key: "_dup",
    value: function _dup() {
      return this;
    } // eslint-disable-next-line class-methods-use-this, no-unused-vars

  }, {
    key: "setText",
    value: function setText(text) {} // eslint-disable-next-line class-methods-use-this, no-unused-vars

  }, {
    key: "update",
    value: function update(options) {}
  }, {
    key: "getGLBoundaries",
    value: function getGLBoundaries(lastDrawTransformMatrix) {
      var glBoundaries = [];
      this.border.forEach(function (boundary) {
        var glBorder = [];
        boundary.forEach(function (point) {
          glBorder.push(point.transformBy(lastDrawTransformMatrix));
        });
        glBoundaries.push(glBorder);
      });
      return glBoundaries;
    }
  }, {
    key: "getGLBoundaryHoles",
    value: function getGLBoundaryHoles(lastDrawTransformMatrix) {
      var glBoundaries = [];
      this.holeBorder.forEach(function (boundary) {
        var glBorder = [];
        boundary.forEach(function (point) {
          glBorder.push(point.transformBy(lastDrawTransformMatrix));
        });
        glBoundaries.push(glBorder);
      });
      return glBoundaries;
    }
    /* eslint-enable */

    /* eslint-disable class-methods-use-this, no-unused-vars */

  }, {
    key: "drawWithTransformMatrix",
    value: function drawWithTransformMatrix(transformMatrix, color, canvasIndex, numPoints) {}
    /* eslint-enable */

  }, {
    key: "getGLBoundingRect",
    value: function getGLBoundingRect(lastDrawTransformMatrix) {
      var boundaries = this.getGLBoundaries(lastDrawTransformMatrix); // const min = new Point(0, 0);
      // const max = new Point(0, 0);
      // let firstPoint = true;
      // boundaries.forEach((boundary) => {
      //   boundary.forEach((point) => {
      //     if (firstPoint) {
      //       min.x = point.x;
      //       min.y = point.y;
      //       max.x = point.x;
      //       max.y = point.y;
      //       firstPoint = false;
      //     } else {
      //       min.x = point.x < min.x ? point.x : min.x;
      //       min.y = point.y < min.y ? point.y : min.y;
      //       max.x = point.x > max.x ? point.x : max.x;
      //       max.y = point.y > max.y ? point.y : max.y;
      //     }
      //   });
      // });
      // return new Rect(min.x, min.y, max.x - min.x, max.y - min.y);

      return Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getBoundingRect"])(boundaries);
    }
  }, {
    key: "getVertexSpaceBoundingRect",
    value: function getVertexSpaceBoundingRect() {
      return Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getBoundingRect"])(this.border);
    }
  }, {
    key: "getLocation",
    value: function getLocation() {
      return this.location;
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "getGLLocation",
    value: function getGLLocation(lastDrawTransformMatrix) {
      return this.getLocation().transformBy(lastDrawTransformMatrix);
    }
  }, {
    key: "getRelativeGLBoundingRect",
    value: function getRelativeGLBoundingRect(lastDrawTransformMatrix) {
      var glLocation = this.getGLLocation(lastDrawTransformMatrix);
      var glAbsoluteBoundaries = this.getGLBoundingRect(lastDrawTransformMatrix);
      var glRelativeBoundaries = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](glAbsoluteBoundaries.left - glLocation.x, glAbsoluteBoundaries.bottom - glLocation.y, glAbsoluteBoundaries.width, glAbsoluteBoundaries.height);
      return glRelativeBoundaries;
    }
  }, {
    key: "getRelativeVertexSpaceBoundingRect",
    value: function getRelativeVertexSpaceBoundingRect() {
      var absoluteBoundaries = this.getVertexSpaceBoundingRect();
      var relativeBoundaries = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](absoluteBoundaries.left - this.location.x, absoluteBoundaries.bottom - this.location.y, absoluteBoundaries.width, absoluteBoundaries.height);
      return relativeBoundaries;
    } // eslint-disable-next-line no-unused-vars, class-methods-use-this

  }, {
    key: "change",
    value: function change(drawingPrimitive, border, holes) {}
  }]);

  return DrawingObject;
}();

/* harmony default export */ __webpack_exports__["default"] = (DrawingObject);

/***/ }),

/***/ "./src/js/diagram/DrawingObjects/Geometries/copy/copy.js":
/*!***************************************************************!*\
  !*** ./src/js/diagram/DrawingObjects/Geometries/copy/copy.js ***!
  \***************************************************************/
/*! exports provided: copyPoints, copyStep */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyPoints", function() { return copyPoints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyStep", function() { return copyStep; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../tools/tools */ "./src/js/tools/tools.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

/* eslint-disable camelcase */



function getPointsToCopy(points, startIn, endIn, marks) {
  var out = [];
  var start = marks["".concat(startIn)];
  var end;

  if (endIn === 'end') {
    end = points.length;
  } else {
    end = marks["".concat(endIn)];
  }

  if (end == null) {
    end = points.length;
  }

  for (var i = start; i < end; i += 1) {
    out.push(points[i]._dup());
  }

  return out;
}

function copyOffset(pointsToCopy, // initialPoints: Array<Point>,
optionsIn) {
  var defaultOptions = {
    to: []
  };
  var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, optionsIn);
  options.to = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoints"])(options.to);
  var out = [];

  var _loop = function _loop(i) {
    out = [].concat(_toConsumableArray(out), _toConsumableArray(pointsToCopy.map(function (p) {
      return p.add(options.to[i]);
    })));
  };

  for (var i = 0; i < options.to.length; i += 1) {
    _loop(i);
  }

  return out;
}

function copyTransform(pointsToCopy, // initialPoints: Array<Point>,
optionsIn) {
  var defaultOptions = {
    to: []
  };
  var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, optionsIn);

  if (options.to instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]) {
    options.to = [optionsIn.to];
  }

  var out = [];

  var _loop2 = function _loop2(i) {
    // $FlowFixMe
    var matrix = options.to[i].matrix();
    out = [].concat(_toConsumableArray(out), _toConsumableArray(pointsToCopy.map(function (p) {
      return p.transformBy(matrix);
    })));
  };

  for (var i = 0; i < options.to.length; i += 1) {
    _loop2(i);
  }

  return out;
}

function copyLinear(pointsToCopy, // initialPoints: Array<Point>,
optionsIn) {
  if (optionsIn.along == null) {
    return [];
  }

  var defaultOptions = {
    num: 1
  };
  var angle = 0;
  var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, optionsIn);

  if (options.along === 'y') {
    angle = Math.PI / 2;
  } else if (options.along === 'x') {
    angle = 0;
  } else if (typeof options.along === 'number') {
    angle = options.along;
  }

  if (options.step == null) {
    var bounds = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getBoundingRect"])(pointsToCopy);
    options.step = Math.abs(bounds.height / Math.sin(angle));
  }

  var out = [];

  var _loop3 = function _loop3(i) {
    var step = options.step * i;
    out = [].concat(_toConsumableArray(out), _toConsumableArray(pointsToCopy.map(function (p) {
      return p.add(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(step, angle));
    })));
  };

  for (var i = 1; i < options.num + 1; i += 1) {
    _loop3(i);
  }

  return out;
}

function copyAngle(pointsToCopy, // initialPoints: Array<Point>,
optionsIn) {
  var defaultOptions = {
    num: 1,
    step: Math.PI / 4,
    center: [0, 0]
  };
  var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, optionsIn);
  options.center = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(options.center);
  var out = [];
  var center = options.center;

  var _loop4 = function _loop4(i) {
    var matrix = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().translate(-center.x, -center.y).rotate(i * options.step).translate(center.x, center.y).matrix();
    out = [].concat(_toConsumableArray(out), _toConsumableArray(pointsToCopy.map(function (p) {
      return p.transformBy(matrix);
    })));
  };

  for (var i = 1; i < options.num + 1; i += 1) {
    _loop4(i);
  }

  return out;
} // function copyArc(
//   pointsToCopy: Array<Point>,
//   initialPoints: Array<Point>,
//   optionsIn: CPY_Arc,
// ) {
//   const defaultOptions = {
//     num: 1,
//     step: 0.1,
//     angleStep: Math.PI / 4,
//     // arcStep: 0.1,
//     startAngle: 0,
//     stopAngle: Math.PI * 2,
//     center: [0, 0],
//   };
//   const options = joinObjects({}, defaultOptions, optionsIn);
//   options.center = getPoint(options.center);
//   let out = initialPoints;
//   const { center } = options;
//   for (let i = 1; i < options.num + 1; i += 1) {
//     const matrix = new Transform()
//       .translate(-center.x, -center.y)
//       .rotate(i * options.step)
//       .translate(center.x, center.y)
//       .matrix();
//     out = [...out, ...pointsToCopy.map(p => p.transformBy(matrix))];
//   }
//   return out;
// }


function copyStep(points, copyStyle, options) // marks: CPY_Marks,
{
  // const out = [];
  if (copyStyle === 'linear' || copyStyle === 'x' || copyStyle === 'y' || typeof copyStyle === 'number') {
    return copyLinear(points, options);
  }

  if (copyStyle === 'to') {
    if (options.to == null) {
      return points;
    }

    if (Array.isArray(options.to) && options.to.length === 0) {
      return points;
    }

    if (options.to instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]) {
      return copyTransform(points, options);
    }

    if (Array.isArray(options.to) && options.to[0] instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]) {
      return copyTransform(points, options);
    }

    return copyOffset(points, options);
  }

  if (copyStyle === 'rotation') {
    return copyAngle(points, options);
  }

  return points;
}

function copyPoints(points, chain) {
  var marks = {}; // let out = [];

  var startIndex = 0; // let all = [];
  // $FlowFixMe

  var out = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoints"])(points);

  if (chain == null) {
    return out;
  }

  var chainToUse = [];

  if (!Array.isArray(chain)) {
    chainToUse = [chain];
  } else {
    chainToUse = chain;
  }

  marks['0'] = 0;
  marks['1'] = points.length;
  chainToUse.forEach(function (c, index) {
    if (typeof c === 'string') {
      marks[c] = out.length;
    } else {
      var defaultOptions = {
        start: startIndex,
        end: 'end',
        original: true
      };
      var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, c);
      var copyStyle = 'to';

      if (options.along != null) {
        copyStyle = options.along;
      }

      var pointsToCopy = getPointsToCopy(out, options.start, options.end, marks);

      if (options.original === false) {
        startIndex = out.length;
      }

      out = [].concat(_toConsumableArray(out), _toConsumableArray(copyStep(pointsToCopy, copyStyle, options)));
      marks["".concat(index + 2)] = out.length;
    }
  });
  return _toConsumableArray(out.slice(startIndex));
}



/***/ }),

/***/ "./src/js/diagram/DrawingObjects/Geometries/lines/corners.js":
/*!*******************************************************************!*\
  !*** ./src/js/diagram/DrawingObjects/Geometries/lines/corners.js ***!
  \*******************************************************************/
/*! exports provided: circleCorner, cutCorner, cornerLine, makeCorner, lineToCorners */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circleCorner", function() { return circleCorner; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cutCorner", function() { return cutCorner; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cornerLine", function() { return cornerLine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeCorner", function() { return makeCorner; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineToCorners", function() { return lineToCorners; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

 //
// Make a circular corner between points - P2 and p3 must be the same
// distance from p1
//
//               .....................................
//          p3  0                                     0 center
//              0                                  0  .
//              0                               0   b .
//              0                            0        .
//              0                         0           .
//              0                C     0              .
//              0                   0                 .
//              0                0                    .  A
//              0             0                       .
//              0          0                          .
//              0       0                             .
//              0    0                                .
//              0 0  a                              c .
//              000000000000000000000000000000000000000
//          p1                     B                    p2
//
//

function circleCorner(p2in, p1, p3in, sides) {
  // If sides is 0 or negative, then return the original points
  if (sides < 1) {
    return [p2in._dup(), p1._dup(), p3in._dup()];
  } // If sides is 1, then return the chamfer


  if (sides === 1) {
    return [p2in._dup(), p3in._dup()];
  }

  var p2 = p2in._dup();

  var p3 = p3in._dup();

  var points = [];

  var _2a = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["threePointAngleMin"])(p2, p1, p3);

  if (_2a === Math.PI) {
    points.push(p2in._dup());

    for (var i = 0; i < sides - 2; i += 1) {
      points.push(p1._dup());
    }

    points.push(p3in._dup());
    return points;
  } // if equal to 0, that means the lines are going back on top of each other
  // in which case we still want a radius at the end, so make it small and
  // unnoticable


  var isZero = false; // let zeroMag = 0.0001;

  if (_2a === 0) {
    isZero = true;
    _2a = 0.00001;
  }

  var direction = _2a / Math.abs(_2a);

  var line12 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](p1, p2);
  var a = Math.abs(_2a / 2);
  var c = Math.PI / 2;
  var b = Math.PI - a - c;
  var B = line12.length();
  var C = Math.sin(c) / Math.sin(b) * B; // const C = B / Math.cos(a);

  var center = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](p1.x + C * Math.cos(a * direction + line12.angle()), p1.y + C * Math.sin(a * direction + line12.angle()));

  var _2b = b * 2;

  var delta = _2b / sides * direction * -1;
  var lineC2 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](center, p2);
  var angleC2 = lineC2.angle();
  var magC2 = lineC2.length();
  points.push(p2); // If the angle is zero, then we want to draw a pho (very small) polyline
  // that will simulate a radius at the end

  if (isZero) {
    var mag = 0.0001;
    var ang12 = line12.angle() + Math.PI / 2;
    var deltaZero = Math.PI / sides;

    for (var _i = 0; _i <= sides; _i += 1) {
      points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](center.x + mag * Math.cos(ang12 + deltaZero * _i), center.y + mag * Math.sin(ang12 + deltaZero * _i)));
    }
  } else {
    for (var _i2 = 0; _i2 < sides - 1; _i2 += 1) {
      var angle = angleC2 + (_i2 + 1) * delta;
      points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](center.x + magC2 * Math.cos(angle), center.y + magC2 * Math.sin(angle)));
    }
  }

  points.push(p3); // if (reverse) {
  //   return points.reverse();
  // }

  return points;
}

function cutCorner(p2, p1, p3, sides, style, value) {
  var line12 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](p1, p2);
  var line13 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](p1, p3);
  var cut;

  if (style === 'fromVertex') {
    cut = value;
    cut = Math.min(cut, line12.length() / 2 * 0.99, line13.length() / 2 * 0.99);
  } else if (style === 'radius') {
    var angle = Math.abs(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["threePointAngleMin"])(p2, p1, p3)) / 2;
    cut = value / Math.tan(angle);
    cut = Math.min(cut, line12.length() / 2 * 0.99, line13.length() / 2 * 0.99);
  } else {
    // if (style === 'max')
    cut = Math.min(line12.length(), line13.length());
  } // cut = Math.min(cut, line12.length() / 2 * 0.99, line13.length() / 2 * 0.99);


  var p2Max = line12.pointAtPercent(cut / line12.length());
  var p3Max = line13.pointAtPercent(cut / line13.length());
  return circleCorner(p2Max, p1, p3Max, sides);
}

function cornerLine(pointsIn, close, type, sides, size) {
  var points = [];

  if (close) {
    points = cutCorner(pointsIn[pointsIn.length - 1], pointsIn[0], pointsIn[1], sides, type, size);
  } else {
    points.push(pointsIn[0]);
  }

  for (var i = 1; i < pointsIn.length - 1; i += 1) {
    var corner = cutCorner(pointsIn[i - 1], pointsIn[i], pointsIn[i + 1], sides, type, size);
    points = [].concat(_toConsumableArray(points), _toConsumableArray(corner));
  }

  if (close) {
    points = [].concat(_toConsumableArray(points), _toConsumableArray(cutCorner(pointsIn[pointsIn.length - 2], pointsIn[pointsIn.length - 1], pointsIn[0], sides, type, size)));
  } else {
    points.push(pointsIn[pointsIn.length - 1]._dup());
  }

  return points;
}

function makeCorner(p2, p1, p3, length) {
  var forceLength = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  var line12 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](p1, p2);
  var line13 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](p1, p3);
  var newP2 = line12.pointAtPercent(length / line12.length());
  var newP3 = line13.pointAtPercent(length / line13.length());

  if (forceLength === false) {
    if (length > line12.length()) {
      newP2 = p2._dup();
    }

    if (length > line13.length()) {
      newP3 = p3._dup();
    }
  }

  return [newP2, p1._dup(), newP3];
}

function lineToCorners(pointsIn, close, length) {
  var forceLength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var corners = [];

  for (var i = 1; i < pointsIn.length - 1; i += 1) {
    corners.push(makeCorner(pointsIn[i - 1], pointsIn[i], pointsIn[i + 1], length, forceLength));
  }

  if (close) {
    corners.push(makeCorner(pointsIn[pointsIn.length - 2], pointsIn[pointsIn.length - 1], pointsIn[0], length, forceLength));
    corners.push(makeCorner(pointsIn[pointsIn.length - 1], pointsIn[0], pointsIn[1], length, forceLength));
  }

  return corners;
}



/***/ }),

/***/ "./src/js/diagram/DrawingObjects/Geometries/lines/dashes.js":
/*!******************************************************************!*\
  !*** ./src/js/diagram/DrawingObjects/Geometries/lines/dashes.js ***!
  \******************************************************************/
/*! exports provided: getDashElementAndRemainder, makeDashDefinition, makeDashes, lineToDash */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDashElementAndRemainder", function() { return getDashElementAndRemainder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeDashDefinition", function() { return makeDashDefinition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeDashes", function() { return makeDashes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineToDash", function() { return lineToDash; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }



function makeDashDefinition(dashes) {
  var cum = [];
  var cycleLength = dashes.reduce(function (p, sum) {
    cum.push(p + sum);
    return p + sum;
  }, 0);
  return {
    definition: dashes,
    sum: cycleLength,
    cum: cum
  };
}

function getDashElementAndRemainder(dash, offset) {
  var singleCycleOffset;

  if (offset > dash.sum) {
    singleCycleOffset = offset % dash.sum;
  } else {
    singleCycleOffset = offset;
  }

  for (var i = 0; i < dash.definition.length; i += 1) {
    if (singleCycleOffset <= dash.cum[i]) {
      return [i, dash.cum[i] - singleCycleOffset];
    }
  }

  return [0, 0];
}

function makeDashes(dash, p1, p2, offset) {
  var points = [];
  var cumDistance = 0; // eslint-disable-next-line prefer-const

  var _getDashElementAndRem = getDashElementAndRemainder(dash, offset),
      _getDashElementAndRem2 = _slicedToArray(_getDashElementAndRem, 2),
      index = _getDashElementAndRem2[0],
      remainder = _getDashElementAndRem2[1];

  var line12 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](p1, p2);
  var totLength = line12.length();
  var dashLength = remainder;
  var lastIndex = index;

  while (cumDistance < totLength) {
    var isOnLine = index % 2 === 0;

    if (isOnLine) {
      var q1 = line12.pointAtPercent(cumDistance / totLength);
      var q2 = void 0;

      if (cumDistance + dashLength <= totLength) {
        q2 = line12.pointAtPercent((cumDistance + dashLength) / totLength);
        cumDistance += dashLength;
      } else {
        q2 = p2._dup();
        cumDistance += dashLength;
      }

      points.push([q1, q2]);
    } else {
      cumDistance += dashLength;
    }

    lastIndex = index;
    index = (index + 1) % dash.definition.length;
    dashLength = dash.definition[index];
  }

  return {
    points: points,
    continues: cumDistance > totLength && lastIndex % 2 === 0
  };
}

function lineToDash(points, dash) {
  var close = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var out = [];
  var dd = makeDashDefinition(dash);
  var cumLength = offset;
  var lastContinue = false;

  var processLine = function processLine(p1, p2) {
    var dashes = makeDashes(dd, p1, p2, cumLength);
    var dashLines = dashes.points;
    var dashContinues = dashes.continues;

    if (lastContinue && dashLines[0] != null) {
      out[out.length - 1] = [].concat(_toConsumableArray(out[out.length - 1]), _toConsumableArray(dashLines[0].slice(1)));
      out = [].concat(_toConsumableArray(out), _toConsumableArray(dashLines.slice(1)));
    } else {
      out = [].concat(_toConsumableArray(out), _toConsumableArray(dashLines));
    }

    lastContinue = dashContinues;
    cumLength += Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["distance"])(p1, p2);
  };

  for (var i = 0; i < points.length - 1; i += 1) {
    var p1 = points[i];
    var p2 = points[i + 1];
    processLine(p1, p2);
  }

  if (close) {
    var _p = points[points.length - 1];
    var _p2 = points[0];
    processLine(_p, _p2);

    var _getDashElementAndRem3 = getDashElementAndRemainder(dd, offset),
        _getDashElementAndRem4 = _slicedToArray(_getDashElementAndRem3, 1),
        startIndex = _getDashElementAndRem4[0]; // const startIsOnLine = startIndex % 2 === 0;


    if (lastContinue && startIndex % 2 === 0 && out.length > 1) {
      out[0] = [].concat(_toConsumableArray(out[out.length - 1]), _toConsumableArray(out[0].slice(1)));
    }
  }

  return out;
}



/***/ }),

/***/ "./src/js/diagram/DrawingObjects/Geometries/lines/lines.js":
/*!*****************************************************************!*\
  !*** ./src/js/diagram/DrawingObjects/Geometries/lines/lines.js ***!
  \*****************************************************************/
/*! exports provided: joinLinesInPoint, lineSegmentsToPoints, joinLinesInTangent, makePolyLine, makePolyLineCorners */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "joinLinesInPoint", function() { return joinLinesInPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineSegmentsToPoints", function() { return lineSegmentsToPoints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "joinLinesInTangent", function() { return joinLinesInTangent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makePolyLine", function() { return makePolyLine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makePolyLineCorners", function() { return makePolyLineCorners; });
/* harmony import */ var _corners__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./corners */ "./src/js/diagram/DrawingObjects/Geometries/lines/corners.js");
/* harmony import */ var _dashes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dashes */ "./src/js/diagram/DrawingObjects/Geometries/lines/dashes.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }




/* eslint-disable yoda */
// A thick line is defined from:
//  * A reference line
//  * A width
//  * Where the reference line is relative to the width
//    ('mid', 'inside', 'outside')
//  * How to deal with the corners in the line
//
// Convert line segments that define the outer boundaries of a line into
// triangles for drawing in WebGL
//
//                        outside
// p1    ----------------------------------------------   p2
//       2, 4
//
//       1                                         3, 5
// p1    ----------------------------------------------   p2
//                        inside
//

function lineSegmentsToPoints(lineSegments, linePrimitives) {
  var borderIs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'line';
  var holeIs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'none';
  var tris = [];
  var border = [];
  var hole = [[]];
  lineSegments.forEach(function (lineSegment) {
    var negative = lineSegment[0];
    var positive = lineSegment.slice(-1)[0];

    if (linePrimitives) {
      for (var l = 0; l < lineSegment.length; l += 1) {
        tris.push(lineSegment[l].p1._dup());
        tris.push(lineSegment[l].p2._dup());
      }
    } else {
      tris.push(positive.p1._dup());
      tris.push(positive.p2._dup());
      tris.push(negative.p1._dup());
      tris.push(negative.p1._dup());
      tris.push(positive.p2._dup());
      tris.push(negative.p2._dup());
    }

    if (borderIs === 'line') {
      border.push([negative.p1._dup(), negative.p2._dup(), positive.p2._dup(), positive.p1._dup()]);
    } else if (borderIs === 'negative') {
      if (border.length === 0) {
        border.push([]);
      }

      border[0].push(negative.p1._dup(), negative.p2._dup());
    } else if (borderIs === 'positive') {
      if (border.length === 0) {
        border.push([]);
      }

      border[0].push(positive.p1._dup(), positive.p2._dup());
    }

    if (holeIs === 'positive') {
      hole[0].push(positive.p1._dup(), positive.p2._dup());
    } else if (holeIs === 'negative') {
      hole[0].push(negative.p1._dup(), negative.p2._dup());
    }
  });

  if (Array.isArray(borderIs)) {
    border = borderIs;
  }

  if (Array.isArray(holeIs)) {
    hole = holeIs;
  }

  return [tris, border, hole];
} // Extend two lines to their intersection point


function joinLinesInPoint(line1, lineNext) {
  var intersect = line1.intersectsWith(lineNext);

  if (intersect.intersect != null) {
    line1.setP2(intersect.intersect._dup());
    lineNext.setP1(intersect.intersect._dup());
  }
} //                    2       2        2
//                    N     o N        N
//                       No      N        N
//                      o   N       N        N
//                    o        N       N        N
//                   o            N       N        N
//            angle o                N       N        N
//                 o                    N       N        N        / Tangent
//                 o                       N  1    N        N  1 /
//                o                           N       N        N/
//  in   000000000o000000000000000000000000000000        N  1  /
//       1        o                            2            N /
//  mid  0000000000000000000000000000000000000000000000000000/
//       1                                                2 /
//  out  00000000000000000000000000000000000000000000000000/
//       1                                              2 /
//                                                       /
//
// Note, for simplicity, both inside and outside can intercept with tangent
// and geometry is valid.


function joinLinesInTangent( // inside: Line,
// insideNext: Line,
mid, midNext, outside, outsideNext) {
  var angle = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_2__["threePointAngleMin"])(mid.p1, mid.p2, midNext.p2);
  var tangent = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Line"](mid.p2, 1, mid.angle() + angle / 2 + Math.PI / 2);
  var intercept = tangent.intersectsWith(outside);

  if (intercept.intersect != null) {
    outside.setP2(intercept.intersect);
  }

  intercept = tangent.intersectsWith(outsideNext);

  if (intercept.intersect != null) {
    outsideNext.setP1(intercept.intersect);
  }
}

function joinLinesAcuteInside(mid, midNext, inside, insideNext) {
  var intercept = inside.intersectsWith(midNext);

  if (intercept.intersect != null) {
    inside.setP2(intercept.intersect);
  }

  intercept = insideNext.intersectsWith(mid);

  if (intercept.intersect != null) {
    insideNext.setP1(intercept.intersect);
  }
}

function joinLinesObtuseInside(mid, midNext, inside, insideNext) {
  var intercept = inside.intersectsWith(midNext);

  if (intercept.intersect != null && intercept.intersect.isOnLine(midNext, 8)) {
    inside.setP2(intercept.intersect);
  }

  intercept = insideNext.intersectsWith(mid);

  if (intercept.intersect != null && intercept.intersect.isOnLine(mid, 8)) {
    insideNext.setP1(intercept.intersect);
  }
}

function makeLineSegments(points, width, close, cornerStyle, widthIs, isInside) {
  var numLines = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 2;
  var idealLines = [];

  var makeLine = function makeLine(p1, p2) {
    return new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Line"](p1, p2);
  };

  for (var i = 0; i < points.length - 1; i += 1) {
    idealLines.push(makeLine(points[i], points[i + 1]));
  }

  if (close) {
    idealLines.push(makeLine(points[points.length - 1], points[0]));
  } // lineSegments should be more negative to more positive


  var lineSegments = [];

  var makeOffset = function makeOffset(prev, current, next, offset, index) {
    var minNegativeOffset = offset;
    var minPositiveOffset = offset;
    var prevAngle = Math.PI;

    if (prev != null) {
      prevAngle = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_2__["threePointAngle"])(prev.p1, current.p1, current.p2);
      var minPrevAngle = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_2__["threePointAngleMin"])(prev.p1, current.p1, current.p2);
      var minPrevOffset = current.distanceToPoint(prev.p1);
      var minOffset = Math.min(minPrevOffset, Math.tan(Math.abs(minPrevAngle)) * current.length()); // Negative side is inside angle

      if (prevAngle < Math.PI / 2) {
        minNegativeOffset = Math.min(minNegativeOffset, minOffset);
      } else if (prevAngle > Math.PI / 2 * 3) {
        minPositiveOffset = Math.min(minPositiveOffset, minOffset);
      }
    }

    var nextAngle = Math.PI;

    if (next != null) {
      nextAngle = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_2__["threePointAngle"])(current.p1, current.p2, next.p2);
      var minNextAngle = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_2__["threePointAngleMin"])(current.p1, current.p2, next.p2);
      var minNextOffset = current.distanceToPoint(next.p2);

      var _minOffset = Math.min(minNextOffset, Math.tan(Math.abs(minNextAngle)) * current.length());

      if (nextAngle < Math.PI / 2) {
        minNegativeOffset = Math.min(minNegativeOffset, _minOffset);
      } else if (nextAngle > Math.PI / 2 * 3) {
        minPositiveOffset = Math.min(minPositiveOffset, _minOffset);
      }
    } // let negativeLine;
    // let positiveLine;


    var offsetLine; // console.log(widthIs)
    // console.log(prevAngle, nextAngle)

    if (widthIs === 'negative') {
      if (cornerStyle === 'auto' && (isInside || prevAngle < Math.PI || nextAngle < Math.PI)) {
        offsetLine = current.offset('negative', minNegativeOffset);
      } else {
        offsetLine = current.offset('negative', offset);
      }
    } else if (widthIs === 'positive') {
      if (cornerStyle === 'auto' && (isInside || prevAngle > Math.PI || nextAngle > Math.PI)) {
        // console.log('min')
        offsetLine = current.offset('positive', minPositiveOffset);
      } else {
        offsetLine = current.offset('positive', offset);
      } // otherwise widthIs === 'mid'

    } else {
      offsetLine = current.offset('positive', offset);
    } // if (cornerStyle === 'auto' && widthIs !== 'mid') {
    //   negativeLine = current.offset('negative', minNegativeOffset);
    //   positiveLine = current.offset('positive', minPositiveOffset);
    // } else {
    //   negativeLine = current.offset('negative', offset);
    //   positiveLine = current.offset('positive', offset);
    // }


    lineSegments[index].push(offsetLine);
  };

  var step = width / (numLines - 1);

  for (var _i = 0; _i < idealLines.length; _i += 1) {
    var prev = _i > 0 ? idealLines[_i - 1] : null;
    var current = idealLines[_i];
    var next = _i < idealLines.length - 1 ? idealLines[_i + 1] : null;

    if (close && _i === 0) {
      prev = idealLines[idealLines.length - 1];
    }

    if (close && _i === idealLines.length - 1) {
      // eslint-disable-next-line prefer-destructuring
      next = idealLines[0];
    }

    lineSegments.push([]);

    if (widthIs === 'negative' || widthIs === 'positive') {
      lineSegments[_i].push(current._dup());
    } else if (numLines === 1) {
      lineSegments[_i].push(current._dup());
    } else {
      var offsetLine = current.offset('negative', width / 2);

      lineSegments[_i].push(offsetLine);
    }

    for (var l = 1; l < numLines; l += 1) {
      if (widthIs === 'negative' || widthIs === 'positive') {
        makeOffset(prev, current, next, l * step, _i);
      } else {
        makeOffset(prev, current, next, -width / 2 + l * step, _i);
      }
    }

    if (widthIs === 'negative') {
      lineSegments[_i].reverse();
    }
  }

  return [idealLines, lineSegments];
}

function getWidthIs(points, close, widthIs) {
  if (widthIs === 'mid' || widthIs === 'negative' || widthIs === 'positive') {
    return widthIs;
  }

  var numInsideNegativeAngles = 0;
  var totAngles = close ? points.length : points.length - 2;

  var testAngle = function testAngle(p2, p1, p3) {
    var angle = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_2__["threePointAngle"])(p2, p1, p3);

    if (angle < Math.PI) {
      numInsideNegativeAngles += 1;
    }

    if (angle === Math.PI) {
      totAngles -= 1;
    }
  };

  for (var i = 1; i < points.length - 1; i += 1) {
    testAngle(points[i - 1], points[i], points[i + 1]);
  }

  if (close) {
    testAngle(points[points.length - 1], points[0], points[1]);
    testAngle(points[points.length - 2], points[points.length - 1], points[0]);
  }

  if (numInsideNegativeAngles >= totAngles / 2) {
    if (widthIs === 'inside') {
      return 'negative';
    }

    return 'positive';
  }

  if (widthIs === 'inside') {
    return 'positive';
  }

  return 'negative';
}

function makeThickLine(points) {
  var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.01;
  var widthIsIn = arguments.length > 2 ? arguments[2] : undefined;
  var close = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var corner = arguments.length > 4 ? arguments[4] : undefined;
  var minAngleIn = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : Math.PI / 7;
  var linePrimitives = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
  var lineNum = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 2;
  var borderIs = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 'line';
  var holeIs = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 'none';
  var widthToUse = width; // if (widthIsIn === 'mid') {
  //   widthToUse = width / 2;
  // }

  var widthIs = getWidthIs(points, close, widthIsIn);

  var _makeLineSegments = makeLineSegments(points, widthToUse, close, corner, widthIs, widthIsIn === 'inside', lineNum),
      _makeLineSegments2 = _slicedToArray(_makeLineSegments, 2),
      idealLines = _makeLineSegments2[0],
      lineSegments = _makeLineSegments2[1]; // Join line segments based on the angle between them


  var minAngle = minAngleIn == null ? 0 : minAngleIn;

  var joinLineSegments = function joinLineSegments(currentIndex, nextIndex, lineIndex) {
    var mid = idealLines[currentIndex];
    var midNext = idealLines[nextIndex];
    var lineSegment = lineSegments[currentIndex][lineIndex];
    var lineSegmentNext = lineSegments[nextIndex][lineIndex]; // const [positive, mid, negative] = lineSegments[current];
    // const [positiveNext, midNext, negativeNext] = lineSegments[next];

    var angle = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_2__["threePointAngle"])(mid.p1, mid.p2, midNext.p2); // If the angle is less than 180, then the 'negative' line segments are
    // on the outside of the angle.
    // console.log(currentIndex, lineIndex, angle)

    if (0 < angle && angle < minAngle) {
      if (widthIs === 'mid') {
        joinLinesInTangent(mid, midNext, lineSegment, lineSegmentNext); // joinLinesInTangent(mid, midNext, positive, positiveNext);
      } else if (widthIs === 'negative') {
        joinLinesAcuteInside(mid, midNext, lineSegment, lineSegmentNext);
      } else if (widthIs === 'positive') {
        joinLinesInTangent(mid, midNext, lineSegment, lineSegmentNext);
      }
    } else if (minAngle <= angle && angle <= Math.PI / 2) {
      if (widthIs === 'mid') {
        joinLinesInPoint(lineSegment, lineSegmentNext); // joinLinesInPoint(lineSegment, lineSegmentNext);
      } else if (widthIs === 'negative') {
        joinLinesAcuteInside(mid, midNext, lineSegment, lineSegmentNext);
      } else if (widthIs === 'positive') {
        joinLinesInPoint(lineSegment, lineSegmentNext);
      } // If the angle is greater than the minAngle, then the line segments can
      // be connected directly

    } else if (Math.PI / 2 <= angle && angle < Math.PI) {
      if (widthIs === 'mid') {
        joinLinesInPoint(lineSegment, lineSegmentNext); // joinLinesInPoint(lineSegment, lineSegmentNext);
      } else if (widthIs === 'negative') {
        joinLinesObtuseInside(mid, midNext, lineSegment, lineSegmentNext);
      } else if (widthIs === 'positive') {
        joinLinesInPoint(lineSegment, lineSegmentNext);
      }
    } else if (angle === Math.PI) {
      if (widthIs === 'negative') {
        if (widthIsIn === 'inside') {
          joinLinesObtuseInside(mid, midNext, lineSegment, lineSegmentNext);
        } else {
          joinLinesInPoint(lineSegment, lineSegmentNext);
        }
      } else if (widthIs === 'positive') {
        if (widthIsIn === 'inside') {
          joinLinesObtuseInside(mid, midNext, lineSegment, lineSegmentNext);
        } else {
          joinLinesInPoint(lineSegment, lineSegmentNext);
        }
      } // If the angle is greater than 180, then the positive side is on the
      // inside of the angle

    } else if (Math.PI < angle && angle < Math.PI / 2 * 3) {
      if (widthIs === 'mid') {
        joinLinesInPoint(lineSegment, lineSegmentNext);
        joinLinesInPoint(lineSegment, lineSegmentNext);
      } else if (widthIs === 'negative') {
        joinLinesInPoint(lineSegment, lineSegmentNext);
      } else if (widthIs === 'positive') {
        joinLinesObtuseInside(mid, midNext, lineSegment, lineSegmentNext);
      } //

    } else if (Math.PI / 2 * 3 <= angle && angle <= Math.PI * 2 - minAngle) {
      if (widthIs === 'mid') {
        joinLinesInPoint(lineSegment, lineSegmentNext); // joinLinesInPoint(lineSegment, lineSegmentNext);
      } else if (widthIs === 'negative') {
        joinLinesInPoint(lineSegment, lineSegmentNext);
      } else if (widthIs === 'positive') {
        joinLinesAcuteInside(mid, midNext, lineSegment, lineSegmentNext);
      } //

    } else if (Math.PI * 2 - minAngle < angle && angle < Math.PI * 2) {
      if (widthIs === 'mid') {
        joinLinesInTangent(mid, midNext, lineSegment, lineSegmentNext); // joinLinesInTangent(mid, midNext, lineSegment, lineSegmentNext);
      } else if (widthIs === 'negative') {
        joinLinesInTangent(mid, midNext, lineSegment, lineSegmentNext);
      } else if (widthIs === 'positive') {
        joinLinesAcuteInside(mid, midNext, lineSegment, lineSegmentNext);
      }
    } else if (angle === Math.PI * 2 || angle === 0) {} // do nothing
    // if (widthIs === 'mid') {
    //   joinLinesInPoint(lineSegment, lineSegmentNext);
    //   // joinLinesInPoint(lineSegment, lineSegmentNext);
    // } else if (widthIs === 'negative') {
    //   joinLinesInPoint(lineSegment, lineSegmentNext);
    // } else if (widthIs === 'positive') {
    //   joinLinesInPoint(lineSegment, lineSegmentNext);
    // }
    // if (lineSegments.length >= 2) {
    //   console.log(currentIndex, lineIndex, lineSegments[2][0]._dup())
    // }

  }; // Create fill triangles between the positive & mid, and negative and mid lines


  var cornerFills = [];

  var createFill = function createFill(currentIndex, nextIndex) {
    var mid = idealLines[currentIndex];
    var midNext = idealLines[nextIndex];
    var positive = lineSegments[currentIndex].slice(-1)[0];
    var positiveNext = lineSegments[nextIndex].slice(-1)[0];
    var negative = lineSegments[currentIndex][0];
    var negativeNext = lineSegments[nextIndex][0];
    var angle = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_2__["threePointAngle"])(mid.p1, mid.p2, midNext.p2);

    if (linePrimitives) {
      for (var i = 0; i < lineSegments[currentIndex].length; i += 1) {
        cornerFills.push(lineSegments[currentIndex][i].p2._dup());
        cornerFills.push(lineSegments[nextIndex][i].p1._dup());
      }
    } else if (angle < Math.PI) {
      if (widthIsIn !== 'inside') {
        cornerFills.push(positive.p2._dup());
        cornerFills.push(mid.p2._dup());
        cornerFills.push(positiveNext.p1._dup());
      }
    } else if (angle > Math.PI) {
      if (widthIsIn !== 'inside') {
        cornerFills.push(negative.p2._dup());
        cornerFills.push(mid.p2._dup());
        cornerFills.push(negativeNext.p1._dup());
      }
    }
  }; // NB: this all assumes the GL primitive is TRIANGLES. Thus the order the
  // triangles is drawn is not important, and so fills can happen in chunks.


  if (corner !== 'none') {
    for (var l = 0; l < lineNum; l += 1) {
      for (var i = 0; i < lineSegments.length - 1; i += 1) {
        if (corner === 'auto') {
          joinLineSegments(i, i + 1, l);
        } else if (l === 0) {
          createFill(i, i + 1);
        }
      }

      if (close) {
        if (corner === 'auto') {
          joinLineSegments(lineSegments.length - 1, 0, l);
        } else if (l === 0) {
          createFill(lineSegments.length - 1, 0);
        }
      }
    }
  }

  var _lineSegmentsToPoints = lineSegmentsToPoints(lineSegments, linePrimitives, borderIs, holeIs),
      _lineSegmentsToPoints2 = _slicedToArray(_lineSegmentsToPoints, 3),
      tris = _lineSegmentsToPoints2[0],
      border = _lineSegmentsToPoints2[1],
      hole = _lineSegmentsToPoints2[2]; // if (close === false) {
  //   return [[...tris, ...cornerFills], [[...border[0]], [...hole]];
  // }


  return [[].concat(_toConsumableArray(tris), cornerFills), border, hole];
}

function makePolyLine(pointsIn) {
  var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.01;
  var close = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var widthIs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'mid';
  var cornerStyle = arguments.length > 4 ? arguments[4] : undefined;
  var cornerSize = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0.1;
  var cornerSides = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 10;
  var minAutoCornerAngle = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : Math.PI / 7;
  var dash = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : [];
  var linePrimitives = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : false;
  var lineNum = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 2;
  var borderIs = arguments.length > 11 ? arguments[11] : undefined;
  var holeIs = arguments.length > 12 ? arguments[12] : undefined;
  var points = [];
  var cornerStyleToUse;
  var orderedPoints = pointsIn; // const orderedPoints = setPointOrder(pointsIn, close, widthIs);
  // Convert line to line with corners

  if (cornerStyle === 'auto') {
    points = orderedPoints.map(function (p) {
      return p._dup();
    });
    cornerStyleToUse = 'auto';
  } else if (cornerStyle === 'radius') {
    points = Object(_corners__WEBPACK_IMPORTED_MODULE_0__["cornerLine"])(orderedPoints, close, 'fromVertex', cornerSides, cornerSize);
    cornerStyleToUse = 'fill'; // console.log(points)
  } else {
    // autoCorners = 'none';
    cornerStyleToUse = cornerStyle;
    points = orderedPoints.map(function (p) {
      return p._dup();
    });
  } // Convert line to dashed line


  if (dash.length > 1) {
    var dashes = Object(_dashes__WEBPACK_IMPORTED_MODULE_1__["lineToDash"])(points, dash, close, 0);
    var closeDashes = false;

    if (dashes.length === 1) {
      closeDashes = close;
    }

    var dashedTris = [];
    var dashedBorder = [[]];
    var dashedHole = [[]];
    dashes.forEach(function (d) {
      var _makeThickLine = makeThickLine(d, width, widthIs, closeDashes, cornerStyleToUse, minAutoCornerAngle, linePrimitives, lineNum, borderIs, holeIs),
          _makeThickLine2 = _slicedToArray(_makeThickLine, 3),
          tris = _makeThickLine2[0],
          border = _makeThickLine2[1],
          hole = _makeThickLine2[2];

      dashedTris = [].concat(_toConsumableArray(dashedTris), _toConsumableArray(tris));
      dashedBorder = [[].concat(_toConsumableArray(dashedBorder[0]), _toConsumableArray(border[0]))];
      dashedHole = [[].concat(_toConsumableArray(dashedHole[0]), _toConsumableArray(hole[0]))];
    });
    return [dashedTris, dashedBorder, dashedHole];
  }

  return makeThickLine(points, width, widthIs, close, cornerStyleToUse, minAutoCornerAngle, linePrimitives, lineNum, borderIs, holeIs);
}

function makePolyLineCorners(pointsIn) {
  var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.01;
  var close = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var cornerLength = arguments.length > 3 ? arguments[3] : undefined;
  var widthIs = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'mid';
  var cornerStyle = arguments.length > 5 ? arguments[5] : undefined;
  var cornerSize = arguments.length > 6 ? arguments[6] : undefined;
  var cornerSides = arguments.length > 7 ? arguments[7] : undefined;
  var minAutoCornerAngle = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : Math.PI / 7;
  var linePrimitives = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : false;
  var lineNum = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 1;
  // split line into corners
  var corners = Object(_corners__WEBPACK_IMPORTED_MODULE_0__["lineToCorners"])(pointsIn, close, cornerLength, false);
  var tris = [];
  var borders = [];
  var holes = [];
  corners.forEach(function (corner) {
    var _makePolyLine = makePolyLine(corner, width, false, widthIs, cornerStyle, cornerSize, cornerSides, minAutoCornerAngle, [], linePrimitives, lineNum, 'line', 'none'),
        _makePolyLine2 = _slicedToArray(_makePolyLine, 3),
        t = _makePolyLine2[0],
        b = _makePolyLine2[1],
        h = _makePolyLine2[2];

    tris = [].concat(_toConsumableArray(tris), _toConsumableArray(t));
    borders = [].concat(_toConsumableArray(borders), _toConsumableArray(b));
    holes = [].concat(_toConsumableArray(holes), _toConsumableArray(h));
  });
  return [tris, borders, holes];
}

 // TODO
// inside and dash
// inside and radius
// Inside and radius
// const diagram = new Fig.Diagram();
// const { Point } = Fig;
// const line = [
//     new Point(0.5, 0),
//     new Point(0, 0.024286),
//     new Point(-0.5, 0),
//     // new Point(0, 1),
// ];
// diagram.addElements([
//   {
//     name: 'pad',
//     method: 'polygon',
//     options: {
//       radius: 0.2,
//       color: [0.5, 0.5, 0.5, 0.5],
//       sides: 100,
//       fill: true,
//     },
//   },
//   {
//     name: 'r',
//     method: 'polyline',
//     options: {
//       points: line,
//       width: 0.03,
//       close: true,
//       pointsAt: 'inside',
//       cornerStyle: 'radius',
//       cornerSize: 0.05,
//       cornerSides: 10,
//     },
//   },
//   {
//     name: 'x2',
//     method: 'line',
//     options: {
//       p1: [-1, 0],
//       p2: [1, 0],
//       width: 0.005,
//       color: [0.5, 0.5, 0.5, 0.5],
//     }
//   },
// ]);
// const pad = diagram.getElement('pad');
// pad.setMovable();
// pad.setTransformCallback = () => {
//   line[1] = pad.getPosition();
//   const r = diagram.getElement('r');
//   r.updatePoints(line);
//   diagram.animateNextFrame();
// }
// diagram.initialize();
// pad.setPosition(0, 0.1);
// Inside and dash
// {
//   name: 'r',
//   method: 'polyline',
//   options: {
//     points: line,
//     width: 0.03,
//     close: true,
//     pointsAt: 'inside',
//     dash: [0.1, 0.03],
//   },
// },

/***/ }),

/***/ "./src/js/diagram/DrawingObjects/Geometries/polygon/polygon.js":
/*!*********************************************************************!*\
  !*** ./src/js/diagram/DrawingObjects/Geometries/polygon/polygon.js ***!
  \*********************************************************************/
/*! exports provided: getPolygonPoints, getFanTrisPolygon */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPolygonPoints", function() { return getPolygonPoints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFanTrisPolygon", function() { return getFanTrisPolygon; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

 // import {
//   round,
// } from '../../../../tools/math';

function getPolygonPoints(radius, rotation, offset, sides, sidesToDraw, direction) {
  var deltaAngle = Math.PI * 2 / sides;
  var points = [];

  if (sidesToDraw === 0) {
    return [];
  }

  for (var i = 0; i < sidesToDraw; i += 1) {
    points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](radius * Math.cos(deltaAngle * i * direction + rotation) + offset.x, radius * Math.sin(deltaAngle * i * direction + rotation) + offset.y));
  }

  if (sidesToDraw < sides) {
    points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](radius * Math.cos(deltaAngle * sidesToDraw * direction + rotation) + offset.x, radius * Math.sin(deltaAngle * sidesToDraw * direction + rotation) + offset.y));
  }

  return points;
}

function getFanTrisPolygon(radius, rotation, offset, sides, sidesToDraw, direction) {
  var fan = [offset._dup()].concat(_toConsumableArray(getPolygonPoints(radius, rotation, offset, sides, sidesToDraw, direction)));

  if (sides === sidesToDraw) {
    fan.push(fan[1]._dup());
  }

  return fan;
}



/***/ }),

/***/ "./src/js/diagram/DrawingObjects/HTMLObject/HTMLObject.js":
/*!****************************************************************!*\
  !*** ./src/js/diagram/DrawingObjects/HTMLObject/HTMLObject.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _DrawingObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../DrawingObject */ "./src/js/diagram/DrawingObjects/DrawingObject.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

// import * as m2 from '../tools/m2';



var HTMLObject =
/*#__PURE__*/
function (_DrawingObject) {
  _inherits(HTMLObject, _DrawingObject);

  // diagramLimits: Rect;
  function HTMLObject(parentDiv, id, location) {
    var _this;

    var yAlign = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'middle';
    var xAlign = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'center';

    _classCallCheck(this, HTMLObject);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(HTMLObject).call(this));
    var element = document.getElementById(id);

    if (element) {
      _this.element = element;
    }

    _this.id = id;
    _this.location = location;
    _this.yAlign = yAlign;
    _this.xAlign = xAlign;
    _this.parentDiv = parentDiv;
    _this.show = true;

    _this.setBorder();

    return _this;
  }

  _createClass(HTMLObject, [{
    key: "_dup",
    value: function _dup() {
      var c = new HTMLObject(this.parentDiv, this.id, this.location._dup(), this.yAlign, this.xAlign);
      c.show = this.show;
      c.border = this.border.map(function (b) {
        return b.map(function (p) {
          return p._dup();
        });
      });
      return c;
    }
  }, {
    key: "setBorder",
    value: function setBorder() {
      var parentRect = this.parentDiv.getBoundingClientRect();
      var elementRect = this.element.getBoundingClientRect();
      var left = elementRect.left - parentRect.left;
      var right = left + elementRect.width;
      var top = elementRect.top - parentRect.top;
      var bottom = top + elementRect.height;
      var boundary = [];
      boundary.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](left, top));
      boundary.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](right, top));
      boundary.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](right, bottom));
      boundary.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](left, bottom));
      this.border = [];
      this.border.push(boundary);
    }
  }, {
    key: "getGLBoundaries",
    value: function getGLBoundaries() {
      var parentRect = this.parentDiv.getBoundingClientRect();
      var glSpace = {
        x: {
          bottomLeft: -1,
          width: 2
        },
        y: {
          bottomLeft: -1,
          height: 2
        }
      };
      var pixelSpace = {
        x: {
          bottomLeft: 0,
          width: parentRect.width
        },
        y: {
          bottomLeft: parentRect.height,
          height: -parentRect.height
        }
      };
      var pixelToGLTransform = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["spaceToSpaceTransform"])(pixelSpace, glSpace);
      var elementRect = this.element.getBoundingClientRect();
      var left = elementRect.left - parentRect.left;
      var right = left + elementRect.width;
      var top = elementRect.top - parentRect.top;
      var bottom = top + elementRect.height;
      var boundary = [];
      boundary.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](left, top));
      boundary.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](right, top));
      boundary.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](right, bottom));
      boundary.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](left, bottom));
      return [boundary.map(function (p) {
        return p.transformBy(pixelToGLTransform.matrix());
      })];
    }
  }, {
    key: "glToPixelSpace",
    value: function glToPixelSpace(p) {
      var x = (p.x - -1) / 2 * this.parentDiv.clientWidth;
      var y = (1 - p.y) / 2 * this.parentDiv.clientHeight;
      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](x, y);
    }
  }, {
    key: "change",
    value: function change(newHtml, lastDrawTransformMatrix) {
      var element = newHtml;

      if (typeof newHtml === 'string') {
        element = document.createElement('div');
        element.innerHTML = newHtml;
      }

      if (element instanceof HTMLElement) {
        this.element.innerHTML = '';
        this.element.appendChild(element);
        this.transformHtml(lastDrawTransformMatrix);
      }
    }
  }, {
    key: "transformHtml",
    value: function transformHtml(transformMatrix) {
      if (this.show) {
        // this.element.style.visibility = 'visible';
        var glLocation = this.location.transformBy(transformMatrix);
        var pixelLocation = this.glToPixelSpace(glLocation);
        var w = this.element.clientWidth;
        var h = this.element.clientHeight; // console.log(w, h, this.element.id)

        var left = 0;
        var top = 0;

        if (this.xAlign === 'center') {
          left = -w / 2;
        } else if (this.xAlign === 'right') {
          left = -w;
        }

        if (this.yAlign === 'middle') {
          top = -h / 2;
        } else if (this.yAlign === 'bottom') {
          top = -h;
        }

        var x = pixelLocation.x + left;
        var y = pixelLocation.y + top;
        this.element.style.position = 'absolute';
        this.element.style.left = "".concat(x, "px");
        this.element.style.top = "".concat(y, "px");
        this.element.style.visibility = 'visible'; // this.element.classList.remove('diagram__hidden');
      } else {
        this.element.style.position = 'absolute';
        this.element.style.left = '-10000px';
        this.element.style.top = '-10000px'; // this.element.classList.add('diagram__hidden');

        this.element.style.visibility = 'hidden'; // this.element.style.visibility = 'hidden';
        // console.trace()
      }
    }
  }, {
    key: "drawWithTransformMatrix",
    value: function drawWithTransformMatrix(transformMatrix) {
      this.transformHtml(transformMatrix);
    }
  }]);

  return HTMLObject;
}(_DrawingObject__WEBPACK_IMPORTED_MODULE_1__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (HTMLObject); // Transform -1 to 1 space to 0 to width/height space

/***/ }),

/***/ "./src/js/diagram/DrawingObjects/TextObject/TextObject.js":
/*!****************************************************************!*\
  !*** ./src/js/diagram/DrawingObjects/TextObject/TextObject.js ***!
  \****************************************************************/
/*! exports provided: TextObject, DiagramText, DiagramFont */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextObject", function() { return TextObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DiagramText", function() { return DiagramText; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DiagramFont", function() { return DiagramFont; });
/* harmony import */ var _tools_m2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/m2 */ "./src/js/tools/m2.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _DrawingObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../DrawingObject */ "./src/js/diagram/DrawingObjects/DrawingObject.js");
/* harmony import */ var _DrawContext2D__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../DrawContext2D */ "./src/js/diagram/DrawContext2D.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../tools/tools */ "./src/js/tools/tools.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }







function colorArrayToString(color) {
  return "rgba(".concat(Math.floor(color[0] * 255), ",").concat(Math.floor(color[1] * 255), ",").concat(Math.floor(color[2] * 255), ",").concat(color[3], ")");
} // DiagramFont defines the font properties to be used in a TextObject


var DiagramFont =
/*#__PURE__*/
function () {
  function DiagramFont() {
    var family = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Helvetica Neue';
    var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    var size = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var weight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '200';
    var xAlign = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'center';
    var yAlign = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'middle';
    var color = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;

    _classCallCheck(this, DiagramFont);

    this.family = family;
    this.style = style;
    this.size = size;
    this.weight = weight;
    this.xAlign = xAlign;
    this.yAlign = yAlign;
    this.opacity = 1;
    this.setColor(color); // if (Array.isArray(color)) {
    //   this.color = colorArrayToString(color);
    // } else {
    //   this.color = color;
    // }
  }

  _createClass(DiagramFont, [{
    key: "setColor",
    value: function setColor() {
      var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      // if (Array.isArray(color)) {
      //   this.color = colorArrayToString(color);
      // } else {
      //   this.color = color;
      // }
      this.color = color;
    }
  }, {
    key: "set",
    value: function set(ctx) {
      var scalingFactor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      ctx.font = "".concat(this.style, " ").concat(this.weight, " ").concat(this.size * scalingFactor, "px ").concat(this.family);
      ctx.textAlign = this.xAlign;
      ctx.textBaseline = this.yAlign;
    }
  }, {
    key: "_dup",
    value: function _dup() {
      return new DiagramFont(this.family, this.style, this.size, this.weight, this.xAlign, this.yAlign, this.color);
    }
  }]);

  return DiagramFont;
}(); // DiagramText is a single text element of the diagram that is drawn at
// once and referenced to the same location


var DiagramText =
/*#__PURE__*/
function () {
  function DiagramText() {
    var location = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, 0);
    var text = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    var font = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new DiagramFont();

    _classCallCheck(this, DiagramText);

    this.location = location._dup();
    this.text = text.slice();
    this.font = font._dup();
  }

  _createClass(DiagramText, [{
    key: "_dup",
    value: function _dup() {
      return new DiagramText(this.location._dup(), this.text, this.font._dup());
    }
  }]);

  return DiagramText;
}(); // TextObject is the DrawingObject used in the DiagramElementPrimitive.
// TextObject will draw an array of DiagramText objects.


var TextObject =
/*#__PURE__*/
function (_DrawingObject) {
  _inherits(TextObject, _DrawingObject);

  function TextObject(drawContext2D) {
    var _this;

    var text = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    _classCallCheck(this, TextObject);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(TextObject).call(this));

    if (Array.isArray(drawContext2D)) {
      _this.drawContext2D = drawContext2D;
    } else {
      _this.drawContext2D = [drawContext2D];
    }

    _this.text = text;
    _this.scalingFactor = 1;
    _this.lastDraw = [];
    _this.lastDrawTransform = []; // this.glRect = new Rect(-1, -1, 2, 2);

    if (text.length > 0) {
      var minSize = _this.text[0].font.size;

      _this.text.forEach(function (t) {
        if (t.font.size > 0 && t.font.size < minSize) {
          minSize = t.font.size;
        }
      });

      if (minSize < 20) {
        _this.scalingFactor = minSize * 50;
      }

      if (minSize < 1) {
        var power = -Math.log(minSize) / Math.LN10 + 2;
        _this.scalingFactor = Math.pow(10, power);
      }
    }

    _this.setBorder();

    _this.state = 'loaded';
    return _this;
  }

  _createClass(TextObject, [{
    key: "setText",
    value: function setText(text) {
      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this.text[index].text = text;
      this.setBorder();
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var c = new TextObject(this.drawContext2D, this.text);
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_4__["duplicateFromTo"])(this, c);
      c.scalingFactor = this.scalingFactor;
      c.border = this.border.map(function (b) {
        return b.map(function (p) {
          return p._dup();
        });
      });
      return c;
    }
  }, {
    key: "setFont",
    value: function setFont(fontSize) {
      for (var i = 0; i < this.text.length; i += 1) {
        this.text[i].font.size = fontSize;
      }

      this.setBorder();
    }
  }, {
    key: "setOpacity",
    value: function setOpacity(opacity) {
      for (var i = 0; i < this.text.length; i += 1) {
        this.text[i].font.opacity = opacity;
      }
    }
  }, {
    key: "setColor",
    value: function setColor(color) {
      // const c = colorArrayToString(color);
      for (var i = 0; i < this.text.length; i += 1) {
        this.text[i].font.color = color;
      }
    }
  }, {
    key: "draw",
    value: function draw(translation, rotation, scale, count, color) {
      var transformation = _tools_m2__WEBPACK_IMPORTED_MODULE_0__["identity"]();
      transformation = _tools_m2__WEBPACK_IMPORTED_MODULE_0__["translate"](transformation, translation.x, translation.y);
      transformation = _tools_m2__WEBPACK_IMPORTED_MODULE_0__["rotate"](transformation, rotation);
      transformation = _tools_m2__WEBPACK_IMPORTED_MODULE_0__["scale"](transformation, scale.x, scale.y);
      this.drawWithTransformMatrix(_tools_m2__WEBPACK_IMPORTED_MODULE_0__["t"](transformation), color);
    } // Text is drawn in pixel space which is 0, 0 in the left hand top corner on
    // a canvas of size canvas.offsetWidth x canvas.offsetHeight.
    //
    // Font size and text location is therefore defined in pixels.
    //
    // However, in a Diagram, the text canvas is overlaid on the diagram GL
    // canvas and we want to think about the size and location of text in
    // Diagram Space or Element Space (if the element has a specific transform).
    //
    // For example, if we have a diagram with limits: min: (0, 0), max(2, 1)
    // with a canvas of 1000 x 500 then:
    //    1) Transform pixel space (1000 x 500) to be GL Space (2 x 2). i.e.
    //         - Magnify pixel space by 500 so one unit in the 2D drawing
    //           context is equivalent to 1 unit in GL Space.
    //         - Translate pixel space so 0, 0 is in the middle of the canvas
    //    2) Transform GL Space to Element Space
    //         - The transform matrix in the input parameters includes the
    //           transform to Diagram Space and then Element Space.
    //         - Now one unit in the 2D drawing context is equivalent to 1 unit
    //           in Element Space - i.e. the canvas will have limits of min(0, 0)
    //           and max(2, 1).
    //    3) Plot out all text
    //
    // However, when font size is defined in Element Space, and ends up being
    // <1 Element Space units, we have a problem. This is because font size is
    // still in pixels (just now it's super scaled up). Therefore, a scaling
    // factor is needed to make sure the font size can stay well above 1. This
    // scaling factor scales the final space, so a larger font size can be used.
    // Then all locations definted in Element Space also need to be scaled by
    // this scaling factor.
    //
    // The scaling factor can be number that is large enough to make it so the
    // font size is >>1. In the TextObject constructor, the scaling factor is
    // designed to ensure drawn text always is >20px.

  }, {
    key: "drawWithTransformMatrix",
    value: function drawWithTransformMatrix(transformMatrix) {
      var _this2 = this;

      var color = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [1, 1, 1, 1];
      var contextIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var drawContext2D = this.drawContext2D[contextIndex];
      var ctx = this.drawContext2D[contextIndex].ctx; // Arbitrary scaling factor used to ensure font size is >> 1 pixel
      // const scalingFactor = this.drawContext2D.canvas.offsetHeight /
      //                       (this.diagramLimits.height / 1000);

      var scalingFactor = this.scalingFactor; // Color used if color is not defined in each DiagramText element

      var parentColor = "rgba(\n      ".concat(Math.floor(color[0] * 255), ",\n      ").concat(Math.floor(color[1] * 255), ",\n      ").concat(Math.floor(color[2] * 255), ",\n      ").concat(Math.floor(color[3] * 255), ")");
      ctx.save(); // First convert pixel space to a zoomed in pixel space with the same
      // dimensions as gl clip space (-1 to 1 for x, y), but inverted y
      // like to pixel space.
      // When zoomed: 1 pixel = 1 GL unit.
      // Zoom in so limits betcome 0 to 2:

      var sx = drawContext2D.canvas.offsetWidth / 2 / scalingFactor;
      var sy = drawContext2D.canvas.offsetHeight / 2 / scalingFactor; // Translate so limits become -1 to 1

      var tx = drawContext2D.canvas.offsetWidth / 2;
      var ty = drawContext2D.canvas.offsetHeight / 2; // Modify the incoming transformMatrix to be compatible with zoomed
      // pixel space
      //   - Scale by the scaling factor
      //   - Flip the y translation
      //   - Reverse rotation

      var tm = transformMatrix;
      var t = [tm[0], -tm[1], tm[2] * scalingFactor, -tm[3], tm[4], tm[5] * -scalingFactor, 0, 0, 1]; // Combine the zoomed pixel space with the incoming transform matrix
      // and apply it to the drawing context.

      var totalT = _tools_m2__WEBPACK_IMPORTED_MODULE_0__["mul"]([sx, 0, tx, 0, sy, ty, 0, 0, 1], t);
      ctx.transform(totalT[0], totalT[3], totalT[1], totalT[4], totalT[2], totalT[5]);
      this.lastDrawTransform = totalT.slice(); // Fill in all the text

      this.text.forEach(function (diagramText) {
        diagramText.font.set(ctx, scalingFactor);

        if (diagramText.font.color != null) {
          var c = [].concat(_toConsumableArray(diagramText.font.color.slice(0, 3)), [// $FlowFixMe
          diagramText.font.color[3] * diagramText.font.opacity]);
          ctx.fillStyle = colorArrayToString(c);
        } else {
          ctx.fillStyle = parentColor;
        } // const w = ctx.measureText(diagramText.text).width;
        // this.lastDraw.push({
        //   width: w * 2,
        //   height: w * 2,
        //   x: diagramText.location.x * scalingFactor - w,
        //   y: diagramText.location.y * -scalingFactor - w,
        // });


        _this2.recordLastDraw(ctx, diagramText, scalingFactor, diagramText.location.x * scalingFactor, diagramText.location.y * -scalingFactor);

        ctx.fillText(diagramText.text, diagramText.location.x * scalingFactor, diagramText.location.y * -scalingFactor);
      });
      ctx.restore();
    }
  }, {
    key: "recordLastDraw",
    value: function recordLastDraw(ctx, diagramText, scalingFactor, x, y) {
      var width = ctx.measureText(diagramText.text).width * 1.2;
      var height = diagramText.font.size * scalingFactor * 1.2;
      var bottom = y + height * 0.1;
      var left = x - width * 0.1;

      if (diagramText.font.yAlign === 'baseline') {
        bottom = y + height * 0.2;
      } else if (diagramText.font.yAlign === 'top') {
        bottom = y + height;
      } else if (diagramText.font.yAlign === 'middle') {
        bottom = y + height / 2;
      }

      if (diagramText.font.xAlign === 'center') {
        left -= width / 2;
      } else if (diagramText.font.xAlign === 'right') {
        left -= width;
      }

      this.lastDraw.push({
        width: width,
        height: -height,
        x: left,
        y: bottom
      }); // console.log(this.lastDraw)
    }
  }, {
    key: "clear",
    value: function clear() {
      var contextIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var lastDraw = this.lastDraw;

      if (lastDraw.length > 0) {
        var ctx = this.drawContext2D[contextIndex].ctx;
        var t = this.lastDrawTransform;
        ctx.save();
        ctx.transform(t[0], t[3], t[1], t[4], t[2], t[5]);
        lastDraw.forEach(function (draw) {
          // const x = Math.max(0, draw.x - draw.width * 0.5);
          // const y = Math.max(0, draw.y - draw.height * 0.5);
          var x = draw.x - draw.width;
          var y = draw.y - draw.height;
          ctx.clearRect(x, y, draw.width * 3, draw.height * 3);
        });
        ctx.restore();
      }

      this.lastDraw = [];
    }
  }, {
    key: "getGLBoundaries",
    value: function getGLBoundaries(lastDrawTransformMatrix) {
      var _this3 = this;

      var glBoundaries = [];
      this.text.forEach(function (t) {
        glBoundaries.push(_this3.getGLBoundaryOfText(t, lastDrawTransformMatrix));
      });
      return glBoundaries;
    }
  }, {
    key: "setBorder",
    value: function setBorder() {
      var _this4 = this;

      this.border = [];
      this.text.forEach(function (t) {
        _this4.border.push(_this4.getBoundaryOfText(t));
      }); // return glBoundaries;
    } // This method is used instead of the actual ctx.measureText because
    // Firefox and Chrome don't yet support it's advanced features.
    // Estimates are made for height based on width.
    // eslint-disable-next-line class-methods-use-this

  }, {
    key: "measureText",
    value: function measureText(ctx, text) {
      // const aWidth = ctx.measureText('a').width;
      var fontHeight = ctx.font.match(/[^ ]*px/);
      var aWidth;

      if (fontHeight != null) {
        aWidth = parseFloat(fontHeight[0]) / 2;
      } else {
        aWidth = ctx.measureText('a').width;
      } // const aWidth = parseFloat(ctx.font.match(/[^ ]*px/)[0]) / 2;
      // Estimations of FONT ascent and descent for a baseline of "alphabetic"


      var ascent = aWidth * 1.4;
      var descent = aWidth * 0.08; // Uncomment below and change above consts to lets if more resolution on
      // actual text boundaries is needed
      // const maxAscentRe =
      //   /[ABCDEFGHIJKLMNOPRSTUVWXYZ1234567890!#%^&()@$Qbdtfhiklj]/g;

      var midAscentRe = /[acemnorsuvwxz*gyqp]/g;
      var midDecentRe = /[;,$]/g;
      var maxDescentRe = /[gjyqp@Q(){}[\]|]/g;
      var midAscentMatches = text.text.match(midAscentRe);

      if (Array.isArray(midAscentMatches)) {
        if (midAscentMatches.length === text.text.length) {
          ascent = aWidth * 0.95;
        }
      }

      var midDescentMatches = text.text.match(midDecentRe);

      if (Array.isArray(midDescentMatches)) {
        if (midDescentMatches.length > 0) {
          descent = aWidth * 0.2;
        }
      }

      var maxDescentMatches = text.text.match(maxDescentRe);

      if (Array.isArray(maxDescentMatches)) {
        if (maxDescentMatches.length > 0) {
          descent = aWidth * 0.5;
        }
      }

      var height = ascent + descent;

      var _ctx$measureText = ctx.measureText(text.text),
          width = _ctx$measureText.width;

      var asc = 0;
      var des = 0;
      var left = 0;
      var right = 0;

      if (text.font.xAlign === 'left') {
        right = width;
      }

      if (text.font.xAlign === 'center') {
        left = width / 2;
        right = width / 2;
      }

      if (text.font.xAlign === 'right') {
        left = width;
      }

      if (text.font.yAlign === 'alphabetic' || text.font.yAlign === 'baseline') {
        asc = ascent;
        des = descent;
      }

      if (text.font.yAlign === 'top') {
        asc = 0;
        des = height;
      }

      if (text.font.yAlign === 'bottom') {
        asc = height;
        des = 0;
      }

      if (text.font.yAlign === 'middle') {
        asc = height / 2;
        des = height / 2;
      }

      return {
        actualBoundingBoxLeft: left,
        actualBoundingBoxRight: right,
        fontBoundingBoxAscent: asc,
        fontBoundingBoxDescent: des
      };
    }
  }, {
    key: "getBoundaryOfText",
    value: function getBoundaryOfText(text) {
      var contextIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var boundary = [];
      var scalingFactor = this.scalingFactor; // Measure the text

      text.font.set(this.drawContext2D[contextIndex].ctx, scalingFactor); // const textMetrics = this.drawContext2D.ctx.measureText(text.text);

      var textMetrics = this.measureText(this.drawContext2D[contextIndex].ctx, text); // Create a box around the text

      var location = text.location;
      var box = [new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](-textMetrics.actualBoundingBoxLeft / scalingFactor, textMetrics.fontBoundingBoxAscent / scalingFactor).add(location), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](textMetrics.actualBoundingBoxRight / scalingFactor, textMetrics.fontBoundingBoxAscent / scalingFactor).add(location), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](textMetrics.actualBoundingBoxRight / scalingFactor, -textMetrics.fontBoundingBoxDescent / scalingFactor).add(location), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](-textMetrics.actualBoundingBoxLeft / scalingFactor, -textMetrics.fontBoundingBoxDescent / scalingFactor).add(location)];
      box.forEach(function (p) {
        boundary.push(p);
      }); // console.log('boundary', boundary.width, text.text)

      return boundary;
    }
  }, {
    key: "getGLBoundaryOfText",
    value: function getGLBoundaryOfText(text, lastDrawTransformMatrix) {
      var contextIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var glBoundary = []; // const { scalingFactor } = this;
      // // Measure the text
      // text.font.set(this.drawContext2D.ctx, scalingFactor);
      // // const textMetrics = this.drawContext2D.ctx.measureText(text.text);
      // const textMetrics = this.measureText(this.drawContext2D.ctx, text);
      // // Create a box around the text
      // const { location } = text;
      // const box = [
      //   new Point(
      //     -textMetrics.actualBoundingBoxLeft / scalingFactor,
      //     textMetrics.fontBoundingBoxAscent / scalingFactor,
      //   ).add(location),
      //   new Point(
      //     textMetrics.actualBoundingBoxRight / scalingFactor,
      //     textMetrics.fontBoundingBoxAscent / scalingFactor,
      //   ).add(location),
      //   new Point(
      //     textMetrics.actualBoundingBoxRight / scalingFactor,
      //     -textMetrics.fontBoundingBoxDescent / scalingFactor,
      //   ).add(location),
      //   new Point(
      //     -textMetrics.actualBoundingBoxLeft / scalingFactor,
      //     -textMetrics.fontBoundingBoxDescent / scalingFactor,
      //   ).add(location),
      // ];

      var box = this.getBoundaryOfText(text, contextIndex);
      box.forEach(function (p) {
        glBoundary.push(p.transformBy(lastDrawTransformMatrix));
      });
      return glBoundary;
    }
  }]);

  return TextObject;
}(_DrawingObject__WEBPACK_IMPORTED_MODULE_2__["default"]);



/***/ }),

/***/ "./src/js/diagram/DrawingObjects/VertexObject/Triangles/TRIHoriztonalLine.js":
/*!***********************************************************************************!*\
  !*** ./src/js/diagram/DrawingObjects/VertexObject/Triangles/TRIHoriztonalLine.js ***!
  \***********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");


function TRIHorizontalLine() {
  var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.1;
  var rotation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var t = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().rotate(rotation).translate(start.x, start.y);
  var cx = 0;
  var cy = 0;
  var pList = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](cx, cy - width / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](cx + length, cy - width / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](cx + length, cy + width / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](cx, cy - width / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](cx + length, cy + width / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](cx, cy + width / 2)];
  var pListTransformed = pList.map(function (p) {
    return p.transformBy(t.matrix());
  });
  var points = [];
  pListTransformed.map(function (p) {
    points.push(p.x);
    points.push(p.y);
    return true;
  });
  var border = [pList[0], pList[1], pList[2], pList[5]];
  return {
    points: points,
    border: border
  };
}

/* harmony default export */ __webpack_exports__["default"] = (TRIHorizontalLine);

/***/ }),

/***/ "./src/js/diagram/DrawingObjects/VertexObject/Triangles/TRIParallelLines.js":
/*!**********************************************************************************!*\
  !*** ./src/js/diagram/DrawingObjects/VertexObject/Triangles/TRIParallelLines.js ***!
  \**********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");


function TRIParallelLines() {
  var num = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
  var spacing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.1;
  var start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
  var length = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.1;
  var width = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.01;
  var logarithmic = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
  var flip = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
  var points = [];
  var border = [];
  var sign = 1;

  if (flip) {
    sign = -1;
  }

  var cy = start.y;

  for (var i = 0; i < num; i += 1) {
    var cx = void 0;

    if (logarithmic) {
      cx = start.x + spacing * Math.floor(i / 10) + Math.log10(i % 10) * spacing;
    } else {
      cx = start.x + spacing * i;
    }

    cx -= width / 2;
    points.push(cx, sign * cy);
    points.push(cx + width, sign * cy);
    points.push(cx + width, sign * (cy + length));
    points.push(cx, cy);
    points.push(cx + width, sign * (cy + length));
    points.push(cx, sign * (cy + length));
    border.push([new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](cx, sign * cy), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](cx + width, sign * cy), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](cx + width, sign * (cy + length)), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](cx, sign * (cy + length))]);
  }

  return {
    points: points,
    border: border
  };
}

/* harmony default export */ __webpack_exports__["default"] = (TRIParallelLines);

/***/ }),

/***/ "./src/js/diagram/DrawingObjects/VertexObject/VertexArrow.js":
/*!*******************************************************************!*\
  !*** ./src/js/diagram/DrawingObjects/VertexObject/VertexArrow.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _VertexObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VertexObject */ "./src/js/diagram/DrawingObjects/VertexObject/VertexObject.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





var VertexArrow =
/*#__PURE__*/
function (_VertexObject) {
  _inherits(VertexArrow, _VertexObject);

  function VertexArrow(webgl) {
    var _this;

    var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var legWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.5;
    var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    var legHeight = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;
    var tip = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
    var rotation = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;

    _classCallCheck(this, VertexArrow);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(VertexArrow).call(this, webgl));
    _this.glPrimitive = _this.gl[0].TRIANGLE_FAN;
    _this.height = height;
    var arrowHeight = height - legHeight;
    var points = [];
    points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0));
    points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-width / 2, -arrowHeight));

    if (legHeight) {
      points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-legWidth / 2.0, -arrowHeight));
      points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-legWidth / 2.0, -height));
      points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](+legWidth / 2.0, -height));
      points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](+legWidth / 2.0, -arrowHeight));
    }

    points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](+width / 2, -arrowHeight));
    var t = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().rotate(rotation).translate(tip);
    var transformedPoints = points.map(function (p) {
      return p.transformBy(t.matrix());
    }); // this.points = [
    //   0, 0,
    //   -width / 2, -arrowHeight,
    //   -legWidth / 2.0, -arrowHeight,
    //   -legWidth / 2.0, -height,
    //   +legWidth / 2.0, -height,
    //   +legWidth / 2.0, -arrowHeight,
    //   +width / 2, -arrowHeight,
    // ];

    transformedPoints.forEach(function (p) {
      _this.points.push(p.x);

      _this.points.push(p.y);

      _this.border[0].push(p);
    }); // for (let i = 0; i < this.points.length; i += 2) {
    //   // this.points[i] += tip.x;
    //   // this.points[i + 1] += tip.y;
    //   this.border[0].push(new Point(this.points[i], this.points[i + 1]));
    // }

    _this.border[0].push(_this.border[0][0]._dup());

    _this.setupBuffer();

    return _this;
  }

  return VertexArrow;
}(_VertexObject__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (VertexArrow);

/***/ }),

/***/ "./src/js/diagram/DrawingObjects/VertexObject/VertexBox.js":
/*!*****************************************************************!*\
  !*** ./src/js/diagram/DrawingObjects/VertexObject/VertexBox.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return VertexBox; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _VertexObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VertexObject */ "./src/js/diagram/DrawingObjects/VertexObject/VertexObject.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





var VertexBox =
/*#__PURE__*/
function (_VertexObject) {
  _inherits(VertexBox, _VertexObject);

  function VertexBox(webgl) {
    var _this;

    var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var lineWidth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.01;
    var fill = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

    _classCallCheck(this, VertexBox);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(VertexBox).call(this, webgl));
    _this.glPrimitive = _this.gl[0].TRIANGLE_STRIP;
    _this.lineWidth = lineWidth;
    _this.fill = fill;

    var points = _this.getPoints(width, height, lineWidth, fill);

    _this.updatePoints(points, width, height, true);

    return _this;
  }

  _createClass(VertexBox, [{
    key: "updatePoints",
    value: function updatePoints(points, width, height) {
      var _this2 = this;

      var initialize = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      // let t;
      this.points = [];
      points.forEach(function (p) {
        _this2.points.push(p.x);

        _this2.points.push(p.y);
      });
      this.border[0] = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-width / 2, -height / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width / 2, -height / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width / 2, height / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-width / 2, height / 2)];

      if (initialize) {
        this.setupBuffer();
      } else {
        this.resetBuffer();
      }
    }
  }, {
    key: "updateBox",
    value: function updateBox(width, height) {
      var lineWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.lineWidth;
      var fill = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.fill;
      var points = this.getPoints(width, height, lineWidth, fill);
      this.updatePoints(points, width, height, false);
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "getPoints",
    value: function getPoints(width, height) {
      var lineWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.lineWidth;
      var fill = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.fill;
      var points;

      if (fill) {
        points = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-width / 2, -height / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-width / 2 + width, -height / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-width / 2, -height / 2 + height), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-width / 2 + width, -height / 2 + height)];
      } else {
        points = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-width / 2, -height / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-width / 2 + lineWidth, -height / 2 + lineWidth), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-width / 2, -height / 2 + height), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-width / 2 + lineWidth, -height / 2 + height - lineWidth), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-width / 2 + width, -height / 2 + height), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-width / 2 + width - lineWidth, -height / 2 + height - lineWidth), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-width / 2 + width, -height / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-width / 2 + width - lineWidth, -height / 2 + lineWidth), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-width / 2, -height / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-width / 2 + lineWidth, -height / 2 + lineWidth)];
      }

      return points;
    }
  }]);

  return VertexBox;
}(_VertexObject__WEBPACK_IMPORTED_MODULE_2__["default"]);



/***/ }),

/***/ "./src/js/diagram/DrawingObjects/VertexObject/VertexDashedLine.js":
/*!************************************************************************!*\
  !*** ./src/js/diagram/DrawingObjects/VertexObject/VertexDashedLine.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _VertexObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VertexObject */ "./src/js/diagram/DrawingObjects/VertexObject/VertexObject.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





function makeDash(start, length, width) {
  var p1 = start._dup();

  var p2 = start.add(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, width));
  var p3 = start.add(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](length, width));
  var p4 = start.add(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](length, 0));
  return [p1, p2, p3, p1, p3, p4];
}

var VertexDashedLine =
/*#__PURE__*/
function (_VertexObject) {
  _inherits(VertexDashedLine, _VertexObject);

  function VertexDashedLine(webgl) {
    var _this;

    var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
    var maxLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var width = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.1;
    var rotation = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    var dashStyle = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [1];

    _classCallCheck(this, VertexDashedLine);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(VertexDashedLine).call(this, webgl));
    _this.glPrimitive = _this.gl[0].TRIANGLES;
    _this.dashCumLength = [];
    _this.maxLength = maxLength;
    var cx = 0;
    var cy = 0 - width / 2.0;
    var points = [];
    var cumLength = 0;
    var startVertex = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](cx, cy);
    var isGap = false;

    while (cumLength < maxLength) {
      for (var i = 0; i < dashStyle.length && cumLength < maxLength; i += 1) {
        var length = dashStyle[i];

        if (length + cumLength > maxLength) {
          length = maxLength - cumLength;
        }

        if (!isGap) {
          var dash = makeDash(startVertex, length, width);
          dash.forEach(function (d) {
            points.push(d);
          });
        }

        cumLength += length;
        startVertex.x += length;
        isGap = !isGap;

        _this.dashCumLength.push(cumLength);
      }
    } // rotate points


    var t = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().rotate(rotation).translate(start.x, start.y);
    var transformedPoints = points.map(function (p) {
      return p.transformBy(t.matrix());
    });
    transformedPoints.forEach(function (p) {
      _this.points.push(p.x);

      _this.points.push(p.y);
    }); // const p = this.points;

    _this.border[0] = [transformedPoints[0], transformedPoints[1], transformedPoints[transformedPoints.length - 2], transformedPoints[transformedPoints.length - 1]];

    _this.border[0].push(_this.border[0][0]._dup());

    _this.setupBuffer();

    return _this;
  }

  _createClass(VertexDashedLine, [{
    key: "getPointCountForLength",
    value: function getPointCountForLength() {
      var drawLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.maxLength;

      if (drawLength >= this.maxLength) {
        return this.numPoints;
      }

      if (drawLength < this.dashCumLength[0]) {
        return 0;
      }

      for (var i = 0; i < this.dashCumLength.length; i += 1) {
        var _cumLength = this.dashCumLength[i];

        if (_cumLength > drawLength) {
          return (Math.floor((i - 1) / 2) + 1) * 6;
        }
      }

      return this.numPoints;
    }
  }]);

  return VertexDashedLine;
}(_VertexObject__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (VertexDashedLine);

/***/ }),

/***/ "./src/js/diagram/DrawingObjects/VertexObject/VertexFan.js":
/*!*****************************************************************!*\
  !*** ./src/js/diagram/DrawingObjects/VertexObject/VertexFan.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _VertexObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VertexObject */ "./src/js/diagram/DrawingObjects/VertexObject/VertexObject.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





var VertextFan =
/*#__PURE__*/
function (_VertexObject) {
  _inherits(VertextFan, _VertexObject);

  // WebGL primitive used
  // radius from center to outside of polygon
  // center point
  // angle between adjacent verteces to center lines
  function VertextFan(webgl, points) {
    var _this;

    _classCallCheck(this, VertextFan);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(VertextFan).call(this, webgl));
    _this.glPrimitive = webgl[0].gl.TRIANGLE_FAN;
    _this.points = [];
    points.forEach(function (p) {
      _this.points.push(p.x);

      _this.points.push(p.y);

      _this.border[0].push(p);
    });

    _this.setupBuffer();

    return _this;
  }

  return VertextFan;
}(_VertexObject__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (VertextFan);

/***/ }),

/***/ "./src/js/diagram/DrawingObjects/VertexObject/VertexGeneric.js":
/*!*********************************************************************!*\
  !*** ./src/js/diagram/DrawingObjects/VertexObject/VertexGeneric.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _VertexObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VertexObject */ "./src/js/diagram/DrawingObjects/VertexObject/VertexObject.js");
/* harmony import */ var _Geometries_copy_copy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Geometries/copy/copy */ "./src/js/diagram/DrawingObjects/Geometries/copy/copy.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

 // import { joinObjects } from '../../../tools/tools';





var VertexGeneric =
/*#__PURE__*/
function (_VertexObject) {
  _inherits(VertexGeneric, _VertexObject);

  // borderToPoint: TypeBorderToPoint;
  function VertexGeneric(webgl, vertices, border, holeBorder, drawType) {
    var _this;

    var textureLocation = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : '';
    var textureVertexSpace = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](-1, -1, 2, 2);
    var textureCoords = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](0, 0, 1, 1);
    var textureRepeat = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;
    var copy = arguments.length > 9 ? arguments[9] : undefined;

    _classCallCheck(this, VertexGeneric);

    if (textureLocation !== '') {
      _this = _possibleConstructorReturn(this, _getPrototypeOf(VertexGeneric).call(this, webgl, 'withTexture', 'withTexture'));
    } else {
      _this = _possibleConstructorReturn(this, _getPrototypeOf(VertexGeneric).call(this, webgl));
    } // super(webgl);


    if (drawType === 'lines') {
      _this.glPrimitive = _this.gl[0].LINES;
    } else if (drawType === 'strip') {
      _this.glPrimitive = _this.gl[0].TRIANGLE_STRIP;
    } else if (drawType === 'fan') {
      _this.glPrimitive = _this.gl[0].TRIANGLE_FAN;
    }

    _this.setupPoints(vertices, border, holeBorder, copy);

    _this.setupTexture(textureLocation, textureVertexSpace, textureCoords, textureRepeat);

    _this.setupBuffer();

    return _possibleConstructorReturn(_this);
  }

  _createClass(VertexGeneric, [{
    key: "change",
    value: function change(vertices, border, holeBorder) {
      this.setupPoints(vertices, border, holeBorder);
      this.resetBuffer();
    }
  }, {
    key: "setupTexture",
    value: function setupTexture() {
      var textureLocation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var textureVertexSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](-1, -1, 2, 2);
      var textureCoords = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](0, 0, 1, 1);
      var textureRepeat = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      if (textureLocation) {
        this.texture = {
          id: textureLocation,
          src: textureLocation,
          type: 'image',
          points: [],
          repeat: textureRepeat
        };
        this.createTextureMap(textureVertexSpace.left, textureVertexSpace.right, textureVertexSpace.bottom, textureVertexSpace.top, textureCoords.left, textureCoords.right, textureCoords.bottom, textureCoords.top);
      }
    }
  }, {
    key: "setupPoints",
    value: function setupPoints(vertices, border, holeBorder, copy) {
      var _this2 = this;

      this.points = [];
      var newVerts = vertices;
      newVerts = Object(_Geometries_copy_copy__WEBPACK_IMPORTED_MODULE_3__["copyPoints"])(vertices, copy);
      newVerts.forEach(function (v) {
        _this2.points.push(v.x);

        _this2.points.push(v.y);
      });

      if (border == null) {
        var bounds = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getBoundingRect"])(newVerts);
        this.border[0] = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](bounds.left, bounds.bottom), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](bounds.right, bounds.bottom), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](bounds.right, bounds.top), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](bounds.left, bounds.top)];
      } else {
        this.border = border;
      }

      if (holeBorder != null) {
        this.holeBorder = holeBorder;
      }
    }
  }]);

  return VertexGeneric;
}(_VertexObject__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (VertexGeneric);

/***/ }),

/***/ "./src/js/diagram/DrawingObjects/VertexObject/VertexHorizontalLine.js":
/*!****************************************************************************!*\
  !*** ./src/js/diagram/DrawingObjects/VertexObject/VertexHorizontalLine.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _VertexObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VertexObject */ "./src/js/diagram/DrawingObjects/VertexObject/VertexObject.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





var VertexHorizontalLine =
/*#__PURE__*/
function (_VertexObject) {
  _inherits(VertexHorizontalLine, _VertexObject);

  function VertexHorizontalLine(webgl) {
    var _this;

    var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
    var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var width = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.1;
    var rotation = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;

    _classCallCheck(this, VertexHorizontalLine);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(VertexHorizontalLine).call(this, webgl));
    var cx = 0;
    var cy = 0 - width / 2.0;
    var points = [];
    _this.glPrimitive = _this.gl[0].TRIANGLE_STRIP;
    points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](cx, cy));
    points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](cx, cy + width));
    points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](cx + length, cy));
    points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](cx + length, cy + width)); // transform points

    var t = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().rotate(rotation).translate(start.x, start.y);
    var transformedPoints = points.map(function (p) {
      return p.transformBy(t.matrix());
    });
    transformedPoints.forEach(function (p) {
      _this.points.push(p.x);

      _this.points.push(p.y);
    });
    _this.border[0] = [transformedPoints[0], transformedPoints[1], transformedPoints[transformedPoints.length - 1], transformedPoints[transformedPoints.length - 2]];

    _this.border[0].push(_this.border[0][0]._dup());

    _this.setupBuffer();

    return _this;
  }

  return VertexHorizontalLine;
}(_VertexObject__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (VertexHorizontalLine);

/***/ }),

/***/ "./src/js/diagram/DrawingObjects/VertexObject/VertexLines.js":
/*!*******************************************************************!*\
  !*** ./src/js/diagram/DrawingObjects/VertexObject/VertexLines.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _VertexObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VertexObject */ "./src/js/diagram/DrawingObjects/VertexObject/VertexObject.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





var VertexLines =
/*#__PURE__*/
function (_VertexObject) {
  _inherits(VertexLines, _VertexObject);

  function VertexLines(webgl, linePairs) {
    var _this;

    var numLinesThick = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

    _classCallCheck(this, VertexLines);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(VertexLines).call(this, webgl));
    _this.glPrimitive = _this.gl[0].LINES;
    _this.points = [];
    linePairs.forEach(function (line) {
      var _line = _slicedToArray(line, 2),
          p = _line[0],
          q = _line[1];

      var angle = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](p, q).angle() + Math.PI / 2;
      var spacing = 0.003;
      var startMag = -spacing * (numLinesThick - 1) / 2;

      for (var i = 0; i < numLinesThick; i += 1) {
        var mag = startMag + i * spacing;

        _this.points.push(p.x + mag * Math.cos(angle));

        _this.points.push(p.y + mag * Math.sin(angle));

        _this.points.push(q.x + mag * Math.cos(angle));

        _this.points.push(q.y + mag * Math.sin(angle));
      } // this.points.push(p.x);
      // this.points.push(p.y);
      // this.points.push(q.x);
      // this.points.push(q.y);

    });
    _this.border = [];

    _this.setupBuffer();

    return _this;
  }

  return VertexLines;
}(_VertexObject__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (VertexLines);

/***/ }),

/***/ "./src/js/diagram/DrawingObjects/VertexObject/VertexObject.js":
/*!********************************************************************!*\
  !*** ./src/js/diagram/DrawingObjects/VertexObject/VertexObject.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_m2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/m2 */ "./src/js/tools/m2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _DrawingObject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../DrawingObject */ "./src/js/diagram/DrawingObjects/DrawingObject.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

// import * as g2 from '../g2';



 // Base clase of all shape objects made from verteces for webgl.
// The job of a VertexObject is to:
//  - Have the points of a object/shape
//  - Have the shape's border (used to determine whether a location is
//    within the shape)
//  - Setup the webgl buffer
//  - Draw the shape

var VertexObject =
/*#__PURE__*/
function (_DrawingObject) {
  _inherits(VertexObject, _DrawingObject);

  // shortcut for the webgl context
  // webgl instance for a html canvas
  // primitive tyle (e.g. TRIANGLE_STRIP)
  // Vertex buffer
  // textureBuffer: WebGLBuffer;
  // Primitive vertices of shape
  // Number of primative vertices
  // Border vertices
  function VertexObject(webgl) {
    var _this;

    var vertexShader = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'simple';
    var fragmentShader = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'simple';

    _classCallCheck(this, VertexObject);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(VertexObject).call(this));
    _this.numPoints = 0;
    var webglArray;

    if (Array.isArray(webgl)) {
      webglArray = webgl;
    } else {
      webglArray = [webgl];
    }

    _this.gl = webglArray.map(function (w) {
      return w.gl;
    });
    _this.webgl = webglArray;
    _this.glPrimitive = webglArray[0].gl.TRIANGLES;
    _this.points = [];
    _this.z = 0;
    _this.buffer = webglArray.map(function () {
      return null;
    }); // this.textureLocation = '';
    // this.texturePoints = [];

    _this.texture = null;
    _this.programIndex = webglArray.map(function (w) {
      return w.getProgram(vertexShader, fragmentShader);
    });
    _this.type = 'vertexPrimitive';
    return _this;
  }

  _createClass(VertexObject, [{
    key: "addTextureToBuffer",
    value: function addTextureToBuffer(glIndex, glTexture, image, // image data
    repeat) {
      function isPowerOf2(value) {
        // eslint-disable-next-line no-bitwise
        return (value & value - 1) === 0;
      }

      var gl = this.gl[glIndex];
      var webgl = this.webgl[glIndex];
      var texture = this.texture;

      if (texture != null) {
        var index = webgl.textures[texture.id].index;
        gl.activeTexture(gl.TEXTURE0 + index);
        gl.bindTexture(gl.TEXTURE_2D, glTexture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image); // Check if the image is a power of 2 in both dimensions.

        if (isPowerOf2(image.width) && isPowerOf2(image.height)) {
          // Yes, it's a power of 2. Generate mips.
          gl.generateMipmap(gl.TEXTURE_2D);

          if (repeat != null && repeat === true) {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
          } else {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          }
        } else {
          // No, it's not a power of 2. Turn off mips and set wrapping to clamp to edge
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        }
      }
    }
  }, {
    key: "setupBuffer",
    value: function setupBuffer() {
      var _this2 = this;

      var numPoints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var _loop = function _loop(glIndex) {
        var gl = _this2.gl[glIndex];
        var webgl = _this2.webgl[glIndex]; // const texture = this.texture[glIndex];
        // const buffer = this.buffer[glIndex];

        _this2.state = 'loaded';

        if (numPoints === 0) {
          _this2.numPoints = _this2.points.length / 2.0;
        } else {
          _this2.numPoints = numPoints;
        } // if (this.texture && this.texture.points == null) {
        //   this.texture.points = [];
        //   this.createTextureMap();
        // }


        var texture = _this2.texture;

        if (texture != null) {
          if (texture.points == null) {
            texture.points = [];
          }

          if (texture.points.length === 0) {
            _this2.createTextureMap();
          }

          if (texture.buffer == null) {
            texture.buffer = _this2.gl.map(function () {
              return null;
            });
          } // $FlowFixMe


          texture.buffer[glIndex] = gl.createBuffer(); // $FlowFixMe

          gl.bindBuffer(gl.ARRAY_BUFFER, texture.buffer[glIndex]);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texture.points), gl.STATIC_DRAW);

          if (!(texture.id in webgl.textures) || texture.id in webgl.textures && webgl.textures[texture.id].glTexture == null) {
            var glTexture = gl.createTexture();
            webgl.addTexture(texture.id, glTexture, texture.type);
            gl.activeTexture(gl.TEXTURE0 + webgl.textures[texture.id].index);
            gl.bindTexture(gl.TEXTURE_2D, glTexture);
            var src = texture.src;

            if (src) {
              // Fill the texture with a 1x1 blue pixel.
              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 100]));
              var image = new Image();
              image.src = src;
              _this2.state = 'loading';
              webgl.textures[texture.id].state = 'loading';
              webgl.textures[texture.id].onLoad.push(_this2.executeOnLoad.bind(_this2));
              image.addEventListener('load', function () {
                // Now that the image has loaded make copy it to the texture.
                texture.data = image;

                _this2.addTextureToBuffer(glIndex, glTexture, texture.data, texture.repeat); // if (this.onLoad != null) {


                webgl.onLoad(texture.id); // this.onLoad();
                // }

                _this2.state = 'loaded';
                webgl.textures[texture.id].state = 'loaded';
              });
            } else if (texture.data != null) {
              _this2.addTextureToBuffer(glIndex, glTexture, texture.data, texture.repeat);
            }
          } else if (texture.id in webgl.textures) {
            if (webgl.textures[texture.id].state === 'loading') {
              _this2.state = 'loading';
              webgl.textures[texture.id].onLoad.push(_this2.executeOnLoad.bind(_this2));
            } else {
              _this2.state = 'loaded';
            }
          }
        }

        _this2.buffer[glIndex] = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, _this2.buffer[glIndex]);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(_this2.points), gl.STATIC_DRAW);
      };

      for (var glIndex = 0; glIndex < this.webgl.length; glIndex += 1) {
        _loop(glIndex);
      }
    }
  }, {
    key: "executeOnLoad",
    value: function executeOnLoad() {
      if (this.onLoad != null) {
        this.onLoad();
      }
    }
  }, {
    key: "resetBuffer",
    value: function resetBuffer() {
      var numPoints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      for (var glIndex = 0; glIndex < this.webgl.length; glIndex += 1) {
        var gl = this.gl[glIndex];
        var webgl = this.webgl[glIndex];
        var texture = this.texture;

        if (texture) {
          // this.gl.activeTexture(this.gl.TEXTURE0 + texture.index);
          // this.gl.bindTexture(this.gl.TEXTURE_2D, null);
          if (webgl.textures[texture.id].glTexture != null) {
            gl.deleteTexture(webgl.textures[texture.id].glTexture);
            webgl.textures[texture.id].glTexture = null;
          }

          if (texture.buffer != null) {
            gl.deleteBuffer(texture.buffer[glIndex]); // $FlowFixMe

            texture.buffer[glIndex] = null;
          } // texture.glTexture = null;

        } // this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);


        gl.deleteBuffer(this.buffer[glIndex]);
        this.setupBuffer(numPoints);
      }
    } // eslint-disable-next-line no-unused-vars

  }, {
    key: "change",
    value: function change(coords, border, holes) {
      this.resetBuffer();
    } // eslint-disable-next-line no-unused-vars

  }, {
    key: "update",
    value: function update(options) {
      this.resetBuffer();
    }
  }, {
    key: "changeVertices",
    value: function changeVertices(coords) {
      var _this3 = this;

      var border = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      this.points = [];
      this.border = [];
      var minX = null;
      var minY = null;
      var maxX = null;
      var maxY = null;
      coords.forEach(function (p) {
        _this3.points.push(p.x);

        _this3.points.push(p.y);

        if (minX === null || p.x < minX) {
          minX = p.x;
        }

        if (minY === null || p.y < minY) {
          minY = p.y;
        }

        if (maxY === null || p.y > maxY) {
          maxY = p.y;
        }

        if (maxX === null || p.x > maxX) {
          maxX = p.x;
        }
      });

      if (border.length === 0) {
        if (minX != null && minY != null && maxX != null && maxY != null) {
          this.border[0] = [new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"](minX, minY), new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"](minX, maxY), new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"](maxX, maxY), new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"](maxX, minY)];
        }
      } else {
        this.border = border;
      }

      this.resetBuffer();
    } // Abstract method - should be reimplemented for any vertexObjects that
    // eslint-disable-next-line no-unused-vars

  }, {
    key: "getPointCountForAngle",
    value: function getPointCountForAngle() {
      var drawAngle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Math.PI * 2;
      // return this.numPoints * drawAngle / (Math.PI * 2);
      return this.numPoints;
    } // Abstract method - should be reimplemented for any vertexObjects that
    // eslint-disable-next-line no-unused-vars

  }, {
    key: "getPointCountForLength",
    value: function getPointCountForLength(drawLength) {
      return this.numPoints;
    } // A texture map is a texture coords point that lines up with the texture
    // vertex point. So, if the vertex shape is rectangular, centered at the
    // origin and wants to incorporate the entire texture, then the map would
    // be:
    // vertex space            texture space
    // this.points         this.texture.points
    //    -1,  -1,                  0,  0
    //    -1,   1,                  0,  1
    //     1,   1,                  1,  1
    //     1,  -1,                  1,  0

  }, {
    key: "createTextureMap",
    value: function createTextureMap() {
      var xMinGL = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;
      var xMaxGL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var yMinGL = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
      var yMaxGL = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      var xMinTex = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var xMaxTex = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;
      var yMinTex = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
      var yMaxTex = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 1;
      var glWidth = xMaxGL - xMinGL;
      var glHeight = yMaxGL - yMinGL;
      var texWidth = xMaxTex - xMinTex;
      var texHeight = yMaxTex - yMinTex;
      var texture = this.texture;

      if (texture != null) {
        texture.points = [];

        for (var i = 0; i < this.points.length; i += 2) {
          var x = this.points[i];
          var y = this.points[i + 1];
          var texNormX = (x - xMinGL) / glWidth;
          var texNormY = (y - yMinGL) / glHeight;
          texture.points.push(texNormX * texWidth + xMinTex);
          texture.points.push(texNormY * texHeight + yMinTex);
        }
      }
    }
  }, {
    key: "draw",
    value: function draw(translation, rotation, scale, count, color) // webGLInstance: WebGLInstance = this.webgl,
    {
      var glIndex = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
      var transformation = _tools_m2__WEBPACK_IMPORTED_MODULE_0__["identity"]();
      transformation = _tools_m2__WEBPACK_IMPORTED_MODULE_0__["translate"](transformation, translation.x, translation.y);
      transformation = _tools_m2__WEBPACK_IMPORTED_MODULE_0__["rotate"](transformation, rotation);
      transformation = _tools_m2__WEBPACK_IMPORTED_MODULE_0__["scale"](transformation, scale.x, scale.y);
      this.drawWithTransformMatrix(_tools_m2__WEBPACK_IMPORTED_MODULE_0__["t"](transformation), color, glIndex, count);
    }
  }, {
    key: "drawWithTransformMatrix",
    value: function drawWithTransformMatrix(transformMatrix, color, glIndex, count) // webglInstance: WebGLInstance = this.webgl,
    {
      var gl = this.gl[glIndex];
      var webglInstance = this.webgl[glIndex];
      var size = 2; // 2 components per iteration

      var type = gl.FLOAT; // the data is 32bit floats

      var normalize = false; // don't normalize the data
      // 0 = move forward size * sizeof(type) each iteration to get
      // the next position

      var stride = 0;
      var offset = 0; // start at the beginning of the buffer

      var locations = webglInstance.useProgram(this.programIndex[glIndex]);

      if (this.texture && webglInstance.textures[this.texture.id].type === 'canvasText') {
        // this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
        // this.gl.blendFunc(this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      } else {
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      } // Turn on the attribute


      gl.enableVertexAttribArray(locations.a_position); // Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)

      gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer[glIndex]); // Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)

      gl.vertexAttribPointer(locations.a_position, size, type, normalize, stride, offset);
      gl.uniformMatrix3fv(locations.u_matrix, false, _tools_m2__WEBPACK_IMPORTED_MODULE_0__["t"](transformMatrix)); // Translate

      gl.uniform1f(locations.u_z, this.z);
      gl.uniform4f(locations.u_color, color[0], color[1], color[2], color[3]); // Translate

      var texture = this.texture;

      if (texture != null) {
        // Textures
        // Tell the position attribute how to get data out of positionBuffer (ARRAY_BUFFER)
        var texSize = 2; // 2 components per iteration

        var texType = gl.FLOAT; // the data is 32bit floats

        var texNormalize = false; // don't normalize the data

        var texStride = 0; // 0 = move forward size * sizeof(type) each iteration to get
        // the next position

        var texOffset = 0; // start at the beginning of the buffer

        gl.enableVertexAttribArray(locations.a_texcoord); // $FlowFixMe

        gl.bindBuffer(gl.ARRAY_BUFFER, texture.buffer[glIndex]);
        gl.vertexAttribPointer(locations.a_texcoord, texSize, texType, texNormalize, texStride, texOffset);
      }

      if (texture) {
        gl.uniform1i(locations.u_use_texture, 1);
        var index = webglInstance.textures[texture.id].index; // console.log(texture.id, index, webglInstance.textures)

        gl.uniform1i(locations.u_texture, index);
      } else {
        gl.uniform1i(locations.u_use_texture, 0);
      }

      gl.drawArrays(this.glPrimitive, offset, count);

      if (texture) {
        gl.disableVertexAttribArray(locations.a_texcoord);
      }
    }
  }, {
    key: "transform",
    value: function transform(transformMatrix) {
      for (var i = 0; i < this.points.length; i += 2) {
        var p = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"](this.points[i], this.points[i + 1]);
        p = p.transformBy(transformMatrix);
        this.points[i] = p.x;
        this.points[i + 1] = p.y;
      }

      for (var b = 0; b < this.border.length; b += 1) {
        for (var _p = 0; _p < this.border[b].length; _p += 1) {
          this.border[b][_p] = this.border[b][_p].transformBy(transformMatrix);
        }
      }
    } // calcBorder(lastDrawTransformMatrix: Array<number>) {
    //   const glBorders = [];
    //   this.border.forEach(border => {
    //     const glBorder = [];
    //     border.forEach(p => {
    //       glBorder.push(p.transformBy(lastDrawTransformMatrix));
    //     })
    //     glBorders.push(glBorder);
    //   });
    //   return glBorders;
    // }

  }]);

  return VertexObject;
}(_DrawingObject__WEBPACK_IMPORTED_MODULE_3__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (VertexObject);

/***/ }),

/***/ "./src/js/diagram/DrawingObjects/VertexObject/VertexRadialLines.js":
/*!*************************************************************************!*\
  !*** ./src/js/diagram/DrawingObjects/VertexObject/VertexRadialLines.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _VertexObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VertexObject */ "./src/js/diagram/DrawingObjects/VertexObject/VertexObject.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





var VertexRadialLines =
/*#__PURE__*/
function (_VertexObject) {
  _inherits(VertexRadialLines, _VertexObject);

  function VertexRadialLines(webgl) {
    var _this;

    var innerRadius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var outerRadius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var width = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.05;
    var dAngle = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Math.PI / 4;
    var maxAngle = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : Math.PI * 2;

    _classCallCheck(this, VertexRadialLines);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(VertexRadialLines).call(this, webgl));
    _this.innerRadius = innerRadius;
    _this.outerRadius = outerRadius;
    _this.dAngle = dAngle;
    _this.maxAngle = maxAngle;
    var currentAngle = 0;
    var j = -1;
    var b = -1;
    var referenceLine = [innerRadius, -width / 2.0, outerRadius, -width / 2.0, outerRadius, width / 2.0, innerRadius, -width / 2.0, outerRadius, width / 2.0, innerRadius, width / 2.0];

    while (currentAngle <= maxAngle) {
      for (var i = 0; i < 6; i += 1) {
        var newPoint = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](referenceLine[i * 2], referenceLine[i * 2 + 1]).rotate(currentAngle); // let newPoint = rotate(new coord(referenceLine[i*2],referenceLine[i*2+1]), currentAngle);

        _this.points[j += 1] = newPoint.x;
        _this.points[j += 1] = newPoint.y;
      }

      var radialLineBorder = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](_this.points[j - 11], _this.points[j - 10]), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](_this.points[j - 9], _this.points[j - 8]), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](_this.points[j - 7], _this.points[j - 6]), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](_this.points[j - 1], _this.points[j - 0]), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](_this.points[j - 11], _this.points[j - 10])];
      _this.border[b += 1] = radialLineBorder;
      currentAngle += dAngle;
    }

    _this.setupBuffer();

    return _this;
  }

  _createClass(VertexRadialLines, [{
    key: "drawToAngle",
    value: function drawToAngle(offset, rotate, scale, drawAngle, color) {
      var count = Math.floor(drawAngle / this.dAngle) * 6.0 + 6.0;

      if (drawAngle >= this.maxAngle) {
        count = this.numPoints;
      }

      this.draw(offset, rotate, scale, count, color);
    }
  }, {
    key: "getPointCountForAngle",
    value: function getPointCountForAngle() {
      var drawAngle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Math.PI * 2;
      var count = Math.floor(drawAngle / this.dAngle) * 6.0 + 6;

      if (drawAngle >= Math.PI * 2.0) {
        count = this.numPoints;
      }

      return count;
    }
  }]);

  return VertexRadialLines;
}(_VertexObject__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (VertexRadialLines);

/***/ }),

/***/ "./src/js/diagram/DrawingObjects/VertexObject/VertexRectangle.js":
/*!***********************************************************************!*\
  !*** ./src/js/diagram/DrawingObjects/VertexObject/VertexRectangle.js ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return VertexRectangle; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _VertexObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VertexObject */ "./src/js/diagram/DrawingObjects/VertexObject/VertexObject.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





var VertexRectangle =
/*#__PURE__*/
function (_VertexObject) {
  _inherits(VertexRectangle, _VertexObject);

  function VertexRectangle(webgl, xAlign, yAlign) {
    var _this;

    var width = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    var height = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
    var lineWidth = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0.01;
    var cornerRadius = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
    var cornerSides = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 20;

    _classCallCheck(this, VertexRectangle);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(VertexRectangle).call(this, webgl));
    _this.glPrimitive = _this.gl[0].TRIANGLE_STRIP;
    var points = []; // points.push(new Point(0, 0));

    var makeCorner = function makeCorner(radius, sides, rotation, offset) {
      var cornerPoints = [];

      if (radius === 0 || sides === 0) {
        cornerPoints.push(offset);
      } else {
        var step = Math.PI / 2 / sides;

        for (var i = 0; i < sides + 1; i += 1) {
          cornerPoints.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](radius * Math.cos(i * step + rotation) + offset.x, radius * Math.sin(i * step + rotation) + offset.y));
        }
      }

      return cornerPoints;
    };

    var rad = Math.min(cornerRadius, width / 2, height / 2);
    var innerRad = Math.max(cornerRadius - lineWidth, 0.0001);
    var sides = cornerSides;

    if (sides === 0) {
      rad = 0;
      innerRad = 0;
    }

    var outsidePoints = [].concat(_toConsumableArray(makeCorner(rad, sides, 0, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width / 2 - rad, height / 2 - rad))), _toConsumableArray(makeCorner(rad, sides, Math.PI / 2, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-width / 2 + rad, height / 2 - rad))), _toConsumableArray(makeCorner(rad, sides, Math.PI, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-width / 2 + rad, -height / 2 + rad))), _toConsumableArray(makeCorner(rad, sides, Math.PI / 2 * 3, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width / 2 - rad, -height / 2 + rad))));
    var insidePoints = [].concat(_toConsumableArray(makeCorner(innerRad, sides, 0, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width / 2 - innerRad - lineWidth, height / 2 - innerRad - lineWidth))), _toConsumableArray(makeCorner(innerRad, sides, Math.PI / 2, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-width / 2 + innerRad + lineWidth, height / 2 - innerRad - lineWidth))), _toConsumableArray(makeCorner(innerRad, sides, Math.PI, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-width / 2 + innerRad + lineWidth, -height / 2 + innerRad + lineWidth))), _toConsumableArray(makeCorner(innerRad, sides, Math.PI / 2 * 3, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width / 2 - innerRad - lineWidth, -height / 2 + innerRad + lineWidth))));
    outsidePoints.forEach(function (p, index) {
      points.push(p);
      points.push(insidePoints[index]);
    });

    if (yAlign === 'top') {
      points = points.map(function (p) {
        return p.add(0, -height / 2);
      });
    } else if (yAlign === 'bottom') {
      points = points.map(function (p) {
        return p.add(0, height / 2);
      });
    } else if (yAlign === 'middle') {
      points = points.map(function (p) {
        return p.add(0, 0);
      });
    } else {
      points = points.map(function (p) {
        return p.add(0, yAlign);
      });
    }

    if (xAlign === 'left') {
      points = points.map(function (p) {
        return p.add(width / 2, 0);
      });
    } else if (xAlign === 'right') {
      points = points.map(function (p) {
        return p.add(-width / 2, 0);
      });
    } else if (xAlign === 'center') {
      points = points.map(function (p) {
        return p.add(0, 0);
      });
    } else {
      points = points.map(function (p) {
        return p.add(xAlign, xAlign);
      });
    }

    points.forEach(function (p) {
      _this.points.push(p.x);

      _this.points.push(p.y);
    });

    _this.points.push(_this.points[0]);

    _this.points.push(_this.points[1]);

    _this.points.push(_this.points[2]);

    _this.points.push(_this.points[3]);

    _this.border[0] = points.slice(1);

    _this.setupBuffer();

    return _this;
  }

  return VertexRectangle;
}(_VertexObject__WEBPACK_IMPORTED_MODULE_2__["default"]);



/***/ }),

/***/ "./src/js/diagram/DrawingObjects/VertexObject/VertexRectangleFilled.js":
/*!*****************************************************************************!*\
  !*** ./src/js/diagram/DrawingObjects/VertexObject/VertexRectangleFilled.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return VertexRectangleFilled; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _VertexObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VertexObject */ "./src/js/diagram/DrawingObjects/VertexObject/VertexObject.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





var VertexRectangleFilled =
/*#__PURE__*/
function (_VertexObject) {
  _inherits(VertexRectangleFilled, _VertexObject);

  function VertexRectangleFilled(webgl, xAlign, yAlign) {
    var _this;

    var width = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    var height = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
    var cornerRadius = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
    var cornerSides = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 20;

    _classCallCheck(this, VertexRectangleFilled);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(VertexRectangleFilled).call(this, webgl));
    _this.glPrimitive = _this.gl[0].TRIANGLE_FAN;
    var points = [];
    points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0));

    var makeCorner = function makeCorner(radius, sides, rotation, offset) {
      var cornerPoints = [];

      if (radius === 0 || sides === 0) {
        cornerPoints.push(offset);
      } else {
        var step = Math.PI / 2 / sides;

        for (var i = 0; i < sides + 1; i += 1) {
          cornerPoints.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](radius * Math.cos(i * step + rotation) + offset.x, radius * Math.sin(i * step + rotation) + offset.y));
        }
      }

      return cornerPoints;
    };

    var rad = Math.min(cornerRadius, width / 2, height / 2);
    var sides = cornerSides;

    if (sides === 0) {
      rad = 0;
    }

    points = [].concat(_toConsumableArray(points), _toConsumableArray(makeCorner(rad, sides, 0, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width / 2 - rad, height / 2 - rad))));
    points = [].concat(_toConsumableArray(points), _toConsumableArray(makeCorner(rad, sides, Math.PI / 2, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-width / 2 + rad, height / 2 - rad))));
    points = [].concat(_toConsumableArray(points), _toConsumableArray(makeCorner(rad, sides, Math.PI, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-width / 2 + rad, -height / 2 + rad))));
    points = [].concat(_toConsumableArray(points), _toConsumableArray(makeCorner(rad, sides, Math.PI / 2 * 3, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width / 2 - rad, -height / 2 + rad))));

    if (yAlign === 'top') {
      points = points.map(function (p) {
        return p.add(0, -height / 2);
      });
    } else if (yAlign === 'bottom') {
      points = points.map(function (p) {
        return p.add(0, height / 2);
      });
    } else if (yAlign === 'middle') {
      points = points.map(function (p) {
        return p.add(0, 0);
      });
    } else {
      points = points.map(function (p) {
        return p.add(0, yAlign);
      });
    }

    if (xAlign === 'left') {
      points = points.map(function (p) {
        return p.add(width / 2, 0);
      });
    } else if (xAlign === 'right') {
      points = points.map(function (p) {
        return p.add(-width / 2, 0);
      });
    } else if (xAlign === 'center') {
      points = points.map(function (p) {
        return p.add(0, 0);
      });
    } else {
      points = points.map(function (p) {
        return p.add(xAlign, xAlign);
      });
    }

    points.forEach(function (p) {
      _this.points.push(p.x);

      _this.points.push(p.y);
    });

    _this.points.push(_this.points[2]);

    _this.points.push(_this.points[3]);

    _this.border[0] = points.slice(1);

    _this.setupBuffer();

    return _this;
  }

  return VertexRectangleFilled;
}(_VertexObject__WEBPACK_IMPORTED_MODULE_2__["default"]);



/***/ }),

/***/ "./src/js/diagram/DrawingObjects/VertexObject/VertexText.js":
/*!******************************************************************!*\
  !*** ./src/js/diagram/DrawingObjects/VertexObject/VertexText.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _VertexObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VertexObject */ "./src/js/diagram/DrawingObjects/VertexObject/VertexObject.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _tools_math__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../tools/math */ "./src/js/tools/math.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





 // import { identity } from '../../../tools/m2';

// type TypeTextOptions = {
//   text: string;
//   size: number;
//   family: string;
//   weight: number;
//   style: 'normal' | 'italic',
//   xAlign: 'left' | 'center' | 'right',
//   yAlign: 'top' | 'bottom' | 'middle' | 'baseline',
// };
var VertexText =
/*#__PURE__*/
function (_VertexObject) {
  _inherits(VertexText, _VertexObject);

  // WebGL primitive used
  // radius from center to outside of polygon
  // center point
  // angle between adjacent verteces to center lines
  function VertexText(webgl, textOptions) {
    var _this;

    _classCallCheck(this, VertexText);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(VertexText).call(this, webgl, 'withTexture', 'text'));
    _this.glPrimitive = webgl[0].gl.TRIANGLE_FAN;
    var defaultTextOptions = {
      text: 'DEFAULT_TEXT',
      size: '20px',
      // Text in pixels, or in vertex space units.
      family: 'Helvetica',
      style: 'normal',
      weight: 400,
      xAlign: 'center',
      yAlign: 'alphabetic',
      id: Object(_tools_tools__WEBPACK_IMPORTED_MODULE_3__["generateUniqueId"])('vertexText')
    };
    var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_3__["joinObjects"])({}, defaultTextOptions, textOptions);
    _this.size = options.size;
    _this.text = options.text;
    _this.family = options.family;
    _this.xAlign = options.xAlign;
    _this.yAlign = options.yAlign;
    _this.style = options.style;
    _this.weight = options.weight;
    _this.canvas = document.createElement('canvas');
    _this.canvas.id = options.id;
    _this.ctx = _this.canvas.getContext('2d');
    _this.texture = {
      id: options.id,
      points: [],
      type: 'canvasText'
    };
    _this.type = 'vertexText';

    _this.drawTextIntoBuffer();

    return _this;
  } // Text is positioned such that the text baseline will be at
  // vertex space y = 0.
  // The border will then cover the ascent and descent of the text.


  _createClass(VertexText, [{
    key: "resizeText",
    value: function resizeText() {
      var _this2 = this;

      var pixelToVertexSpaceScale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](1, 1);
      var width = this.canvas.width * pixelToVertexSpaceScale.x;
      var height = this.canvas.height * pixelToVertexSpaceScale.y;
      var start = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);

      if (this.xAlign === 'center') {
        start.x = -width / 2;
      } else if (this.xAlign === 'right') {
        start.x = -width;
      }

      if (this.yAlign === 'baseline') {
        start.y = -height * 0.25;
      } else if (this.yAlign === 'top') {
        start.y = -height;
      } else if (this.yAlign === 'middle') {
        start.y = -height / 2;
      }

      var points = [start, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](start.x, start.y + height), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](start.x + width, start.y + height), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](start.x + width, start.y)];
      this.width = width;
      this.height = height;
      this.calcAscentDescent();
      this.points = [];
      points.forEach(function (point) {
        _this2.points.push(point.x);

        _this2.points.push(point.y);
      });
      this.border = [[new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](start.x, -this.descent), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](start.x, this.ascent), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](start.x + width, this.ascent), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](start.x + width, -this.descent)]];
      var texture = this.texture;

      if (texture != null) {
        texture.points = [0, 0, 0, 1, 1, 1, 1, 0];
        texture.data = this.ctx.canvas;

        if (texture.buffer) {
          this.resetBuffer();
        } else {
          this.setupBuffer();
        }
      }
    }
  }, {
    key: "calcAscentDescent",
    value: function calcAscentDescent() {
      // const aWidth = this.ctx.measureText('a').width;
      // Estimations of FONT ascent and descent for a baseline of "alphabetic"
      var ascent = 0.75;
      var descent = 0;
      var lowAscentRe = /[,.]/g;
      var midAscentRe = /[acemnorsuvwxz*gyq:><;p=]/g;
      var midDecentRe = /[;,$]/g;
      var maxDescentRe = /[gjyqp@Q(){}[\]|]/g;
      var lowAscentMatches = this.text.match(lowAscentRe);

      if (Array.isArray(lowAscentMatches)) {
        if (lowAscentMatches.length === this.text.length) {
          ascent = 0.1;
        }
      }

      var midAscentMatches = this.text.match(midAscentRe);

      if (Array.isArray(midAscentMatches)) {
        if (midAscentMatches.length === this.text.length) {
          ascent = 0.5;
        }
      }

      var midDescentMatches = this.text.match(midDecentRe);

      if (Array.isArray(midDescentMatches)) {
        if (midDescentMatches.length > 0) {
          descent = 0.1;
        }
      }

      var maxDescentMatches = this.text.match(maxDescentRe);

      if (Array.isArray(maxDescentMatches)) {
        if (maxDescentMatches.length > 0) {
          descent = 0.25;
        }
      }

      this.ascent = ascent * this.height;
      this.descent = descent * this.height;
    } // If font size is defined in pixels, then the size will always be the size
    // in pixels independent of how the diagram window or scaling changes
    // If the font size is defined in vertex space units, then the font size
    // will always be scaled to look like the vertex space size, but a new canvas
    // will be drawn each time to minimize aliasing.

  }, {
    key: "drawTextIntoBuffer",
    value: function drawTextIntoBuffer() {
      var pixelToVertexSpaceScale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](1, 1);
      var pixelFontSize = 20;

      if (typeof this.size === 'string' && this.size.endsWith('px')) {
        pixelFontSize = parseInt(this.size, 10);
      } else {
        var diagramFontSize;

        if (typeof this.size === 'string') {
          diagramFontSize = parseFloat(this.size);
        } else {
          diagramFontSize = this.size;
        }

        pixelFontSize = Object(_tools_math__WEBPACK_IMPORTED_MODULE_4__["round"])(diagramFontSize / pixelToVertexSpaceScale.x, 0);
      }

      if (pixelFontSize < 1) {
        pixelFontSize = 1;
      }

      this.ctx.font = "".concat(this.style, " ").concat(this.weight, " ").concat(pixelFontSize, "px ").concat(this.family);
      var hBuffer = 0.3;
      var width = this.ctx.measureText(this.text).width + pixelFontSize * hBuffer;
      var height = pixelFontSize * 1.15;
      this.canvas.width = Math.max(width, 1);
      this.canvas.height = Math.max(height, 1);
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); // need to reset font after a canvas resize

      this.ctx.font = "".concat(this.style, " ").concat(this.weight, " ").concat(pixelFontSize, "px ").concat(this.family);
      this.ctx.textAlign = 'left';
      this.ctx.textBaseline = 'alphabetic'; // this.ctx.fillStyle = 'white';

      this.ctx.fillStyle = 'white'; // this.ctx.fillStyle = 'rgba(200,200,200,255)';   // debug only
      // this.ctx.fillStyle = 'blue';

      var startX = pixelFontSize * hBuffer / 2;
      var baselineHeightFromBottom = 0.25;
      var startY = this.canvas.height * (1 - baselineHeightFromBottom);
      this.ctx.fillText(this.text, startX, startY);
      this.resizeText(pixelToVertexSpaceScale);
    }
  }]);

  return VertexText;
}(_VertexObject__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (VertexText);

/***/ }),

/***/ "./src/js/diagram/Element.js":
/*!***********************************!*\
  !*** ./src/js/diagram/Element.js ***!
  \***********************************/
/*! exports provided: DiagramElementPrimitive, DiagramElementCollection, DiagramElement */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DiagramElementPrimitive", function() { return DiagramElementPrimitive; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DiagramElementCollection", function() { return DiagramElementCollection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DiagramElement", function() { return DiagramElement; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_m2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tools/m2 */ "./src/js/tools/m2.js");
/* harmony import */ var _tools_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tools/math */ "./src/js/tools/math.js");
/* harmony import */ var _DrawingObjects_HTMLObject_HTMLObject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DrawingObjects/HTMLObject/HTMLObject */ "./src/js/diagram/DrawingObjects/HTMLObject/HTMLObject.js");
/* harmony import */ var _DrawingObjects_DrawingObject__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./DrawingObjects/DrawingObject */ "./src/js/diagram/DrawingObjects/DrawingObject.js");
/* harmony import */ var _DrawingObjects_VertexObject_VertexObject__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DrawingObjects/VertexObject/VertexObject */ "./src/js/diagram/DrawingObjects/VertexObject/VertexObject.js");
/* harmony import */ var _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./DrawingObjects/TextObject/TextObject */ "./src/js/diagram/DrawingObjects/TextObject/TextObject.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _tools_color__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../tools/color */ "./src/js/tools/color.js");
/* harmony import */ var _Animation_Animation__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Animation/Animation */ "./src/js/diagram/Animation/Animation.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }


 // import type { pathOptionsType, TypeRotationDirection } from '../tools/g2';







 // import GlobalAnimation from './webgl/GlobalAnimation';
// import DrawContext2D from './DrawContext2D';

// eslint-disable-next-line import/no-cycle

 // eslint-disable-next-line import/no-cycle
// import {
//   AnimationPhase, ColorAnimationPhase, CustomAnimationPhase,
// } from './AnimationPhase';
// function checkCallback(callback: ?(boolean) => void): (boolean) => void {
//   let callbackToUse = () => {};
//   if (typeof callback === 'function') {
//     callbackToUse = callback;
//   }
//   return callbackToUse; + width
// }

// A diagram is composed of multiple diagram elements.
//
// A diagram element can either be a:
//  - Primitive: a basic element that has the webGL vertices, color
//  - Collection: a group of elements (either primatives or collections)
//
// A diagram element can be:
//  - transformed (resized, offset, rotated)
//  - animated (planned transform over time)
//  - moved with control (like dragging)
//  - moving freely (dragged then let go with an initial velocity)
//  - Pulsed
//
// This class manages:
//  - The diagram element
//  - Its current transformation
//  - Its animation plan, animation control and animation state
//  - Its movement state
//  - Its pulsing parameters
//
// A diagram element has an associated persistant transform that describes how
// to draw it. The transform includes any translation, rotation and/or scaling
// the element should be transformed by before drawing.
//
// If the diagram element is a collection of elements, then this transform is
// applied to all the child elements. Each child element will have it's own
// transform as well, and it will be multiplied by the parent transform.
//
// Whenever an element animated or moved, it's persistant transform is updated.
//
// Pulsing does not update an element's persistant transform, but does alter
// the element's current transform used for drawing itself and any children
// elements it has.
//
var DiagramElement =
/*#__PURE__*/
function () {
  // Transform of diagram element
  // presetTransforms: Object;       // Convenience dict of transform presets
  // Transform matrix used in last draw
  // Transform matrix used in last draw
  // lastDrawParentTransform: Transform;
  // lastDrawElementTransform: Transform;
  // lastDrawPulseTransform: Transform;
  // True if should be shown in diagram
  // Used to reference element in a collection
  // Element is able to be moved
  // Element can be touched
  // Touch event is not processed by Diagram
  // Callbacks
  // element.transform is updated
  // For the future when collections use color
  // this is in vertex space
  // Current animation/movement state of element
  // pulse: Object;                  // Pulse animation state
  // Rename to animate in future
  // pulse: (mixed) => void;
  // pulse: (?Array<string | DiagramElement> | mixed) => void;
  // +pulse: (Array<string | DiagramElement>) => void;
  // This will scale and position this element such that the center of the
  // diagram limits will will look like it is centered on a html element
  // when this figurone element is drawn.
  // Scale can be:
  //  1em: diagram units will be scaled so 0.2 diagram units (default
  //       font size) looks like 1em of the element font size in pixels
  //  100px: diagram units will be scaled so that the max diagram limit
  //         with be the pixel count
  //  stretch: diagram units be stretched so diagram limits extend to
  //           element dimensions independently in x and y
  //  max: -1 to 1 diagram units will be scaled to max dimension of element
  //  fit: diagram units will be scaled so that diagram limits aspect ratio
  //       fits within the element aspect ratio
  //  '': defaults to fit keeping aspect ratio.
  // scenarioSet: {
  //   quiz1: [
  //     { element: xyz, position: (), scale: (), rotation: (), length: () }
  //     { element: abc, position: (), }
  //   ],
  // };
  //  element1.scenarioSet['quiz'] = [
  //     { element: abc, position: [1, 2], scale: 2 },
  //     { element: xyz, position: [2, 2]},
  //  ];
  //  element.setScenarios('center', evenIfNotShown
  //  element.moveToScenarios('center', 1, callback))
  // element.animations.new()
  //    .parallel()
  //
  function DiagramElement() {
    var _this = this;

    var transform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();
    var diagramLimits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](-1, -1, 2, 2);
    var parent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    _classCallCheck(this, DiagramElement);

    this.name = ''; // This is updated when an element is added to a collection

    this.uid = (Math.random() * 1e18).toString(36);
    this.isShown = true;
    this.transform = transform._dup();
    this.isMovable = false;
    this.isTouchable = false;
    this.isInteractive = undefined;
    this.hasTouchableElements = false;
    this.color = [1, 1, 1, 1];
    this.dimColor = [0.5, 0.5, 0.5, 1];
    this.defaultColor = this.color.slice();
    this.opacity = 1;

    this.setTransformCallback = function () {};

    this.beforeDrawCallback = null;
    this.afterDrawCallback = null;

    this.internalSetTransformCallback = function () {};

    this.lastDrawTransform = this.transform._dup();
    this.lastDrawPulseTransform = this.transform._dup();
    this.onClick = null;
    this.lastDrawElementTransformPosition = {
      parentCount: 0,
      elementCount: 0
    };
    this.custom = {};
    this.parent = parent;
    this.drawPriority = 1;
    this.noRotationFromParent = false; // this.pulseDefault = (callback: ?() => void = null) => {
    //   this.pulseScaleNow(1, 2, 0, callback);
    // };

    this.pulseDefault = {
      frequency: 0,
      scale: 2,
      time: 1
    }; // Rename to animate in future

    this.anim = {
      rotation: function rotation() {
        for (var _len = arguments.length, optionsIn = new Array(_len), _key = 0; _key < _len; _key++) {
          optionsIn[_key] = arguments[_key];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_7__["joinObjects"].apply(void 0, [{}, {
          element: _this
        }].concat(optionsIn));
        return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_9__["RotationAnimationStep"](options);
      },
      scale: function scale() {
        for (var _len2 = arguments.length, optionsIn = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          optionsIn[_key2] = arguments[_key2];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_7__["joinObjects"].apply(void 0, [{}, {
          element: _this
        }].concat(optionsIn));
        return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_9__["ScaleAnimationStep"](options);
      },
      trigger: function trigger() {
        for (var _len3 = arguments.length, optionsIn = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          optionsIn[_key3] = arguments[_key3];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_7__["joinObjects"].apply(void 0, [{}].concat(optionsIn));
        return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_9__["TriggerStep"](options);
      },
      position: function position() {
        for (var _len4 = arguments.length, optionsIn = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          optionsIn[_key4] = arguments[_key4];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_7__["joinObjects"].apply(void 0, [{}, {
          element: _this
        }].concat(optionsIn));
        return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_9__["PositionAnimationStep"](options);
      },
      color: function color() {
        for (var _len5 = arguments.length, optionsIn = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          optionsIn[_key5] = arguments[_key5];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_7__["joinObjects"].apply(void 0, [{}, {
          elements: _this
        }].concat(optionsIn));
        return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_9__["ColorAnimationStep"](options);
      },
      opacity: function opacity() {
        for (var _len6 = arguments.length, optionsIn = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
          optionsIn[_key6] = arguments[_key6];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_7__["joinObjects"].apply(void 0, [{}, {
          elements: _this
        }].concat(optionsIn));
        return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_9__["OpacityAnimationStep"](options);
      },
      transform: function transform() {
        for (var _len7 = arguments.length, optionsIn = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
          optionsIn[_key7] = arguments[_key7];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_7__["joinObjects"].apply(void 0, [{}, {
          element: _this
        }].concat(optionsIn));
        return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_9__["TransformAnimationStep"](options);
      },
      pulse: function pulse() {
        for (var _len8 = arguments.length, optionsIn = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
          optionsIn[_key8] = arguments[_key8];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_7__["joinObjects"].apply(void 0, [{}, {
          element: this
        }].concat(optionsIn));
        return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_9__["PulseAnimationStep"](options);
      },
      // eslint-disable-next-line max-len
      dissolveIn: function dissolveIn() {
        var timeOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var defaultOptions = {
          element: _this
        };
        var options;

        for (var _len9 = arguments.length, args = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {
          args[_key9 - 1] = arguments[_key9];
        }

        if (typeof timeOrOptionsIn === 'number') {
          options = _tools_tools__WEBPACK_IMPORTED_MODULE_7__["joinObjects"].apply(void 0, [{}, defaultOptions, {
            duration: timeOrOptionsIn
          }].concat(args));
        } else {
          options = _tools_tools__WEBPACK_IMPORTED_MODULE_7__["joinObjects"].apply(void 0, [{}, defaultOptions, timeOrOptionsIn].concat(args));
        }

        return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_9__["DissolveInAnimationStep"](options);
      },
      // eslint-disable-next-line max-len
      dissolveOut: function dissolveOut() {
        var timeOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var defaultOptions = {
          element: _this
        };
        var options;

        for (var _len10 = arguments.length, args = new Array(_len10 > 1 ? _len10 - 1 : 0), _key10 = 1; _key10 < _len10; _key10++) {
          args[_key10 - 1] = arguments[_key10];
        }

        if (typeof timeOrOptionsIn === 'number') {
          options = _tools_tools__WEBPACK_IMPORTED_MODULE_7__["joinObjects"].apply(void 0, [{}, defaultOptions, {
            duration: timeOrOptionsIn
          }].concat(args));
        } else {
          options = _tools_tools__WEBPACK_IMPORTED_MODULE_7__["joinObjects"].apply(void 0, [{}, defaultOptions, timeOrOptionsIn].concat(args));
        }

        return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_9__["DissolveOutAnimationStep"](options);
      },
      // eslint-disable-next-line max-len
      dim: function dim() {
        var timeOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var defaultOptions = {
          element: _this
        };
        var options;

        for (var _len11 = arguments.length, args = new Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {
          args[_key11 - 1] = arguments[_key11];
        }

        if (typeof timeOrOptionsIn === 'number') {
          options = _tools_tools__WEBPACK_IMPORTED_MODULE_7__["joinObjects"].apply(void 0, [{}, defaultOptions, {
            duration: timeOrOptionsIn
          }].concat(args));
        } else {
          options = _tools_tools__WEBPACK_IMPORTED_MODULE_7__["joinObjects"].apply(void 0, [{}, defaultOptions, timeOrOptionsIn].concat(args));
        }

        return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_9__["DimAnimationStep"](options);
      },
      // eslint-disable-next-line max-len
      undim: function undim() {
        var timeOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var defaultOptions = {
          element: _this
        };
        var options;

        for (var _len12 = arguments.length, args = new Array(_len12 > 1 ? _len12 - 1 : 0), _key12 = 1; _key12 < _len12; _key12++) {
          args[_key12 - 1] = arguments[_key12];
        }

        if (typeof timeOrOptionsIn === 'number') {
          options = _tools_tools__WEBPACK_IMPORTED_MODULE_7__["joinObjects"].apply(void 0, [{}, defaultOptions, {
            duration: timeOrOptionsIn
          }].concat(args));
        } else {
          options = _tools_tools__WEBPACK_IMPORTED_MODULE_7__["joinObjects"].apply(void 0, [{}, defaultOptions, timeOrOptionsIn].concat(args));
        }

        return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_9__["UndimAnimationStep"](options);
      },
      // eslint-disable-next-line max-len
      builder: function builder() {
        for (var _len13 = arguments.length, optionsIn = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
          optionsIn[_key13] = arguments[_key13];
        }

        return _construct(_Animation_Animation__WEBPACK_IMPORTED_MODULE_9__["AnimationBuilder"], [_this].concat(optionsIn));
      },
      // eslint-disable-next-line max-len
      scenario: function scenario() {
        var defaultOptions = {
          element: _this
        };

        for (var _len14 = arguments.length, optionsIn = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {
          optionsIn[_key14] = arguments[_key14];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_7__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));

        if (options.target != null && options.target in options.element.scenarios) {
          var target = options.element.getScenarioTarget(options.target);
          options.target = target;
        }

        if (options.start != null && options.start in options.element.scenarios) {
          var start = options.element.getScenarioTarget(options.start);
          options.start = start;
        }

        if (options.delta != null && options.delta in options.element.scenarios) {
          var delta = options.element.getScenarioTarget(options.delta);
          options.delta = delta;
        }

        return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_9__["TransformAnimationStep"](options);
      },
      // eslint-disable-next-line max-len
      scenarios: function scenarios() {
        var defaultOptions = {};

        for (var _len15 = arguments.length, optionsIn = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {
          optionsIn[_key15] = arguments[_key15];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_7__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));

        var elements = _this.getAllElementsWithScenario(options.target);

        var steps = [];
        var simpleOptions = {};
        Object(_tools_tools__WEBPACK_IMPORTED_MODULE_7__["duplicateFromTo"])(options, simpleOptions, ['steps', 'element']);
        elements.forEach(function (element) {
          steps.push(element.anim.scenario(simpleOptions));
        });
        return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_9__["ParallelAnimationStep"](simpleOptions, {
          steps: steps
        });
      }
    };
    this.diagramLimits = diagramLimits;
    this.move = {
      maxTransform: this.transform.constant(1000),
      minTransform: this.transform.constant(-1000),
      boundary: null,
      maxVelocity: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["TransformLimit"](5, 5, 5),
      freely: {
        zeroVelocityThreshold: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["TransformLimit"](0.001, 0.001, 0.001),
        deceleration: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["TransformLimit"](5, 5, 5),
        callback: null
      },
      bounce: true,
      canBeMovedAfterLosingTouch: false,
      type: 'translation',
      element: null,
      limitLine: null,
      transformClip: null
    };
    this.scenarios = {};
    this.pulseSettings = {
      time: 1,
      frequency: 0.5,
      A: 1,
      B: 0.5,
      C: 0,
      style: _tools_math__WEBPACK_IMPORTED_MODULE_2__["sinusoid"],
      num: 1,
      delta: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
      transformMethod: function transformMethod(s, d) {
        if (d == null || d.x === 0 && d.y === 0) {
          return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(s, s);
        }

        return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().translate(-d.x, -d.y).scale(s, s).translate(d.x, d.y);
      },
      callback: function callback() {}
    };
    this.state = {
      isBeingMoved: false,
      isMovingFreely: false,
      movement: {
        previousTime: -1,
        previousTransform: this.transform._dup(),
        velocity: this.transform.zero()
      },
      isPulsing: false,
      pulse: {
        startTime: -1
      }
    };
    this.interactiveLocation = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
    this.animations = new _Animation_Animation__WEBPACK_IMPORTED_MODULE_9__["AnimationManager"](this);
    this.tieToHTML = {
      element: null,
      scale: 'fit',
      window: this.diagramLimits,
      updateOnResize: true
    };
    this.isRenderedAsImage = false;
    this.unrenderNextDraw = false;
    this.renderedOnNextDraw = false;
  }

  _createClass(DiagramElement, [{
    key: "setProperties",
    value: function setProperties(properties) {
      var except = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_7__["joinObjectsWithOptions"])({
        except: except
      }, this, properties);
    } // Space definition:
    //   * Pixel space: css pixels
    //   * GL Space: x,y = -1 to 1
    //   * Diagram Space: x,y = diagram limits
    //   * Element space: Combination of element transform and its
    //     parent transform's
    // A diagram element primative vertex object lives in GL SPACE.
    //
    // A diagram element has its own DIAGRAM ELEMENT SPACE, which is
    // the GL space transformed by `this.transform`.
    //
    // A diagram element is drawn in the DIAGRAM SPACE, by transforming
    // the DIAGRAM ELEMENT SPACE by an incoming transformation matrix in the draw
    // method. This incoming transformation matrix originates in the diagram
    // and waterfalls through each parent diagram collection element to the
    // current diagram element.
    //
    // this.lastDrawTransformationMatrix captures how a vertex was drawn in
    // the last frame, in DIAGRAM space as:
    //   vertex
    //     transformed by: DIAGRAM ELEMENT SPACE
    //     transfromed by: DIAGRAM SPACE transform
    //
    // By default, webgl clip space is a unit space from (-1, 1) to (1, 1)
    // independent of the aspect ratio of the canvas it is drawn on.
    //
    // A diagram object can have its own clip space with arbitrary limits. e.g.:
    //    * (-1, -1) to (1, 1)    similar to gl clip space
    //    * (0, 0) to (2, 2)      similar to gl clip space but offset
    //    * (0, 0) to (4, 2)      for rectangular aspect ratio diagram
    //
    // The diagram object clip space definition is stored in this.diagramLimits.
    //
    // To therefore transform a vertex (from GL SPACE) to DIAGRAM CLIP SPACE:
    //   * Take the vertex
    //   * Transform it to DIAGRAM SPACE (by transforming it with the
    //     lastDrawTransformMatrix)
    //   * Transform it to DIAGRAM CLIP SPACE by scaling and offsetting it
    //     to the clip space.
    //
    // Each diagram element holds a DIAGRAM ELMENT CLIP space

  }, {
    key: "updateHTMLElementTie",
    value: function updateHTMLElementTie(diagramCanvas) {
      var tieToElement;

      if (typeof this.tieToHTML.element === 'string') {
        tieToElement = document.getElementById(this.tieToHTML.element);
      }

      if (tieToElement != null) {
        var tie = tieToElement.getBoundingClientRect();
        var canvas = diagramCanvas.getBoundingClientRect();
        var diagram = this.diagramLimits;
        var dWindow = this.tieToHTML.window;
        var cAspectRatio = canvas.width / canvas.height;
        var dAspectRatio = diagram.width / diagram.height;
        var tAspectRatio = tie.width / tie.height;
        var wAspectRatio = dWindow.width / dWindow.height;
        var topLeftPixels = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](tie.left - canvas.left, tie.top - canvas.top);
        var bottomRightPixels = topLeftPixels.add(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](tie.width, tie.height));
        var pixelToDiagram = this.diagramTransforms.pixelToDiagram;
        var topLeft = topLeftPixels.transformBy(pixelToDiagram.m());
        var bottomRight = bottomRightPixels.transformBy(pixelToDiagram.m());
        var width = bottomRight.x - topLeft.x;
        var height = topLeft.y - bottomRight.y;
        var center = topLeft.add(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width / 2, -height / 2));
        var scaleString = this.tieToHTML.scale.trim().toLowerCase();
        var scaleX = 1;
        var scaleY = 1;
        var diagramToWindowScaleX = diagram.width / dWindow.width;
        var diagramToWindowScaleY = diagram.height / dWindow.height; // Window has no scaling impact on em, it only has impact on translation

        if (scaleString.endsWith('em')) {
          var scale = parseFloat(scaleString);
          var em = parseFloat(getComputedStyle(tieToElement).fontSize); // 0.2 is default font size in diagram units

          var defaultFontScale = diagram.width / 0.2;
          scaleX = scale * em * defaultFontScale / canvas.width;
          scaleY = scale * em * defaultFontScale / dAspectRatio / canvas.height;
        } // Scale the maximum dimension of the window to the pixel value


        if (scaleString.endsWith('px')) {
          var maxPixels = parseFloat(scaleString);

          if (wAspectRatio > 1) {
            var _scale = maxPixels / canvas.width;

            scaleX = _scale * diagramToWindowScaleX;
            scaleY = _scale * cAspectRatio / dAspectRatio * diagramToWindowScaleX;
          } else {
            var _scale2 = maxPixels / canvas.height;

            scaleX = _scale2 / cAspectRatio * dAspectRatio * diagramToWindowScaleY;
            scaleY = _scale2 * diagramToWindowScaleY;
          }
        } // Scale the window x to tie x, and window y to tie y


        if (scaleString === 'stretch') {
          scaleX = tie.width / canvas.width * diagramToWindowScaleX;
          scaleY = tie.height / canvas.height * diagramToWindowScaleY;
        } // Scale so window either fits within the tie element, or fits only
        // within the max dimension of the tie element


        if (scaleString === 'max' || scaleString === 'fit') {
          var fitHeightScale = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](tie.height / canvas.height / cAspectRatio * dAspectRatio * diagramToWindowScaleY, tie.height / canvas.height * diagramToWindowScaleY);
          var fitWidthScale = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](tie.width / canvas.width * diagramToWindowScaleX, tie.width / canvas.width * cAspectRatio / dAspectRatio * diagramToWindowScaleX);

          if (scaleString === 'max' && tAspectRatio > wAspectRatio || scaleString === 'fit' && tAspectRatio < wAspectRatio) {
            scaleX = fitWidthScale.x;
            scaleY = fitWidthScale.y;
          } else {
            scaleX = fitHeightScale.x;
            scaleY = fitHeightScale.y;
          }
        }

        this.setScale(scaleX, scaleY); // Offset the element relative to the tie

        this.setPosition(center.x - scaleX * (this.tieToHTML.window.left + this.tieToHTML.window.width / 2), center.y - scaleY * (this.tieToHTML.window.bottom + this.tieToHTML.window.height / 2));
        this.setFirstTransform(this.getParentLastDrawTransform());
      }
    } // eslint-disable-next-line no-unused-vars, class-methods-use-this

  }, {
    key: "setFirstTransform",
    value: function setFirstTransform(parentTransform) {}
  }, {
    key: "exec",
    value: function exec(execFunctionAndArgs) {
      // if (elementsToExec == null || typeof elementsToExec === 'function') {
      var execFunc;
      var args;

      if (Array.isArray(execFunctionAndArgs)) {
        var _execFunctionAndArgs = _toArray(execFunctionAndArgs);

        execFunc = _execFunctionAndArgs[0];
        args = _execFunctionAndArgs.slice(1);
      } else {
        execFunc = execFunctionAndArgs;
      } // $FlowFixMe


      if (this[execFunc] != null && typeof this[execFunc] === 'function') {
        if (args === undefined) {
          // $FlowFixMe
          this[execFunc]();
        } else {
          // $FlowFixMe
          this[execFunc].apply(this, _toConsumableArray(args));
        }
      }
    } // pulseScaleRelativeTo(
    //   e: DiagramElement | TypeParsablePoint | null,
    //   x: 'left' | 'center' | 'right' | 'origin' | number,
    //   y: 'bottom' | 'middle' | 'top' | 'origin' | number,
    //   space: 'diagram' | 'gl' | 'vertex' | 'local',
    //   time: number,
    //   scale: number,
    //   frequency: number = 0,
    //   callback: ?(?mixed) => void = null,
    // ) {
    //   if (e == null || e instanceof DiagramElement) {
    //     this.pulseScaleRelativeToElement(e, x, y, space, time, scale, frequency, callback);
    //   } else {
    //     this.pulseScaleRelativeToPoint(e, space, time, scale, frequency, callback)
    //   }
    // }

  }, {
    key: "pulse",
    value: function pulse() {
      var optionsOrDone = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var defaultPulseOptions = {
        frequency: 0,
        time: 1,
        scale: 2
      };

      if (typeof this.pulseDefault !== 'function') {
        defaultPulseOptions.frequency = this.pulseDefault.frequency;
        defaultPulseOptions.time = this.pulseDefault.time;
        defaultPulseOptions.scale = this.pulseDefault.scale;
      }

      var defaultOptions = {
        x: 'center',
        y: 'middle',
        space: 'diagram',
        centerOn: null,
        frequency: defaultPulseOptions.frequency,
        time: defaultPulseOptions.time,
        scale: defaultPulseOptions.scale,
        done: null
      };
      var done;
      var options = defaultOptions;

      if (typeof optionsOrDone === 'function') {
        options = defaultOptions;
        done = optionsOrDone;
      } else if (optionsOrDone == null) {
        options = defaultOptions;
        done = null;
      } else {
        options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_7__["joinObjects"])({}, defaultOptions, optionsOrDone);
        var _options = options;
        done = _options.done;
      }

      if (typeof this.pulseDefault === 'function') {
        this.pulseDefault(done);
      } else {
        // const { frequency, time, scale } = this.pulseDefault;
        // this.pulseScaleNow(time, scale, frequency, done);
        this.pulseScaleRelativeTo(options.centerOn, options.x, options.y, options.space, options.time, options.scale, options.frequency, done);
      }
    }
  }, {
    key: "pulseLegacy",
    value: function pulseLegacy() {
      var done = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (typeof this.pulseDefault === 'function') {
        this.pulseDefault(done);
      } else {
        var _this$pulseDefault = this.pulseDefault,
            frequency = _this$pulseDefault.frequency,
            time = _this$pulseDefault.time,
            scale = _this$pulseDefault.scale;
        this.pulseScaleNow(time, scale, frequency, done);
      }
    }
  }, {
    key: "getElement",
    value: function getElement() {
      return this;
    }
  }, {
    key: "getElements",
    value: function getElements() {
      return [this];
    } // eslint-disable-next-line no-unused-vars, class-methods-use-this

  }, {
    key: "highlight",
    value: function highlight() {
      this.undim();
    }
  }, {
    key: "setPosition",
    value: function setPosition(pointOrX) {
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var position = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(pointOrX);

      if (typeof pointOrX === 'number') {
        position = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](pointOrX, y);
      }

      var currentTransform = this.transform._dup();

      currentTransform.updateTranslation(position);
      this.setTransform(currentTransform);
    }
  }, {
    key: "setRotation",
    value: function setRotation(rotation) {
      var currentTransform = this.transform._dup();

      currentTransform.updateRotation(rotation);
      this.setTransform(currentTransform);
    }
  }, {
    key: "setScale",
    value: function setScale(scaleOrX) {
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var scale = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(scaleOrX);

      if (typeof scaleOrX === 'number') {
        if (y == null) {
          scale = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](scaleOrX, scaleOrX);
        } else {
          scale = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](scaleOrX, y);
        }
      }

      var currentTransform = this.transform._dup();

      currentTransform.updateScale(scale);
      this.setTransform(currentTransform);
    } // Use this method to set the element's transform in case a callback has been
    // connected that is tied to an update of the transform.

  }, {
    key: "setTransform",
    value: function setTransform(transform) {
      if (this.move.transformClip != null) {
        this.transform = this.move.transformClip(transform);
      } else {
        this.transform = transform._dup().clip(this.move.minTransform, this.move.maxTransform, this.move.limitLine);
      }

      if (this.internalSetTransformCallback) {
        this.internalSetTransformCallback(this.transform);
      }

      if (this.setTransformCallback) {
        this.setTransformCallback(this.transform);
      }
    } // Set the next transform (and velocity if moving freely) for the next
    // animation frame.
    //
    // If animating, this transform will be the next frame determined by
    // the currently executing animation phase. If time exceeds the current
    // phase, then either the next phase will be started, or if there are no
    // more phases, the animation will complete.
    //
    // If moving freely, this method will set the next velocity and transform
    // based on the current velocity, current transform, elapsed time,
    // deceleration (in freelyProperties) and zeroVelocityThreshold.
    // Once the velocity goes to zero, this metho will stop the element moving
    // freely.

  }, {
    key: "nextMovingFreelyFrame",
    value: function nextMovingFreelyFrame(now) {
      // If the element is moving freely, then calc it's next velocity and
      // transform. Save the new velocity into state.movement and return the
      // transform.
      if (this.state.isMovingFreely) {
        // If this is the first frame of moving freely, then record the current
        // time so can calculate velocity on next frame
        if (this.state.movement.previousTime < 0) {
          this.state.movement.previousTime = now;
          return;
        } // If got here, then we are now after the first frame, so calculate
        // the delta time from this frame to the previous


        var deltaTime = now - this.state.movement.previousTime; // Calculate the new velocity and position

        var next = this.decelerate(deltaTime);
        this.state.movement.velocity = next.velocity;
        this.state.movement.previousTime = now; // If the velocity is 0, then stop moving freely and return the current
        // transform

        if (this.state.movement.velocity.isZero()) {
          this.state.movement.velocity = this.state.movement.velocity.zero();
          this.stopMovingFreely(false);
        }

        this.setTransform(next.transform);
      }
    } // Used only to clear 2D context
    // eslint-disable-next-line class-methods-use-this

  }, {
    key: "clear",
    value: function clear() {}
  }, {
    key: "willStartAnimating",
    value: function willStartAnimating() {
      if (this.animations.willStartAnimating()) {
        return true;
      }

      return false;
    }
  }, {
    key: "setColor",
    value: function setColor(color) {
      var setDefault = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      this.color = color != null ? color.slice() : [0, 0, 0, 0];

      if (setDefault) {
        this.defaultColor = this.color.slice();
      }
    }
  }, {
    key: "dim",
    value: function dim() {
      this.setColor(this.dimColor, false);
    }
  }, {
    key: "setDimColor",
    value: function setDimColor(color) {
      this.dimColor = color != null ? color.slice() : [0, 0, 0, 0];
    }
  }, {
    key: "undim",
    value: function undim() {
      this.setColor(this.defaultColor, true);
    }
  }, {
    key: "setOpacity",
    value: function setOpacity(opacity) {
      // this.color[3] = opacity;
      this.opacity = opacity;
    }
  }, {
    key: "getScenarioTarget",
    value: function getScenarioTarget(scenarioName) {
      var target = this.transform._dup();

      if (scenarioName in this.scenarios) {
        var scenario = this.scenarios[scenarioName];

        if (scenario.position != null) {
          target.updateTranslation(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(scenario.position));
        }

        if (scenario.rotation != null) {
          target.updateRotation(scenario.rotation);
        }

        if (scenario.scale != null) {
          target.updateScale(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(scenario.scale));
        }
      }

      return target;
    }
  }, {
    key: "setScenario",
    value: function setScenario(scenarioName) {
      if (this.scenarios[scenarioName] != null) {
        var target = this.getScenarioTarget(scenarioName);
        this.setTransform(target._dup());
      }
    }
  }, {
    key: "setScenarios",
    value: function setScenarios(scenarioName) {
      if (this.scenarios[scenarioName] != null) {
        this.setScenario(scenarioName);
      }
    }
  }, {
    key: "getAllElementsWithScenario",
    value: function getAllElementsWithScenario(scenarioName) {
      if (this.scenarios[scenarioName] != null) {
        return [this];
      }

      return [];
    }
  }, {
    key: "getTimeToMoveToScenario",
    value: function getTimeToMoveToScenario(scenarioName) {
      var rotDirection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var target = this.getScenarioTarget(scenarioName);
      var velocity = this.transform.constant(0);
      velocity.updateTranslation(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](1 / 2, 1 / 2));
      velocity.updateRotation(2 * Math.PI / 6);
      velocity.updateScale(1, 1);
      var time = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getMaxTimeFromVelocity"])(this.transform._dup(), target, velocity, rotDirection);
      return time;
    } // Decelerate over some time when moving freely to get a new element
    // transform and movement velocity

  }, {
    key: "decelerate",
    value: function decelerate(deltaTime) {
      var next = this.transform.decelerate(this.state.movement.velocity, this.move.freely.deceleration, deltaTime, this.move.freely.zeroVelocityThreshold);

      if (deltaTime > 0) {
        for (var i = 0; i < next.t.order.length; i += 1) {
          var t = next.t.order[i];
          var min = this.move.minTransform.order[i];
          var max = this.move.maxTransform.order[i];
          var v = next.v.order[i];

          if (t instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Translation"] && v instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Translation"] && max instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Translation"] && min instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Translation"] || t instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Scale"] && v instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Scale"] && max instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Scale"] && min instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Scale"]) {
            var onLine = true;

            if (this.move.limitLine != null) {
              onLine = t.shaddowIsOnLine(this.move.limitLine, 4);
            }

            if (min.x >= t.x || max.x <= t.x || !onLine) {
              if (this.move.bounce) {
                v.x = -v.x * 0.5;
              } else {
                v.x = 0;
              }
            }

            if (min.y >= t.y || max.y <= t.y || !onLine) {
              if (this.move.bounce) {
                v.y = -v.y * 0.5;
              } else {
                v.y = 0;
              }
            }

            next.v.order[i] = v;
          }

          if (t instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rotation"] && v instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rotation"] && max instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rotation"] && min instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rotation"]) {
            if (min.r >= t.r || max.r <= t.r) {
              if (this.move.bounce) {
                v.r = -v.r * 0.5;
              } else {
                v.r = 0;
              }
            }

            next.v.order[i] = v;
          }
        }

        next.v.calcMatrix();
      }

      return {
        velocity: next.v,
        transform: next.t
      };
    }
  }, {
    key: "updateLastDrawTransform",
    value: function updateLastDrawTransform() {
      var _this2 = this;

      var parentCount = this.lastDrawElementTransformPosition.parentCount;
      var pLength = this.lastDrawTransform.order.length;
      var transform = this.getTransform();
      transform.order.forEach(function (t, index) {
        _this2.lastDrawTransform.order[pLength - parentCount - index - 1] = t._dup();
      });
      this.lastDrawTransform.calcMatrix();
    }
  }, {
    key: "getParentLastDrawTransform",
    value: function getParentLastDrawTransform() {
      var parentCount = this.lastDrawElementTransformPosition.parentCount;
      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"](this.lastDrawTransform.order.slice(-parentCount));
    } // Being Moved

  }, {
    key: "startBeingMoved",
    value: function startBeingMoved() {
      // this.stopAnimating();
      this.animations.cancelAll('noComplete');
      this.stopMovingFreely();
      this.state.movement.velocity = this.transform.zero();
      this.state.movement.previousTransform = this.transform._dup();
      this.state.movement.previousTime = Date.now() / 1000;
      this.state.isBeingMoved = true;
      this.unrender();
    }
  }, {
    key: "moved",
    value: function moved(newTransform) {
      this.calcVelocity(newTransform);
      this.setTransform(newTransform._dup());
    }
  }, {
    key: "stopBeingMoved",
    value: function stopBeingMoved() {
      var currentTime = Date.now() / 1000; // Check wether last movement was a long time ago, if it was, then make
      // velocity 0 as the user has stopped moving before releasing touch/click

      if (this.state.movement.previousTime !== -1) {
        if (currentTime - this.state.movement.previousTime > 0.05) {
          this.state.movement.velocity = this.transform.zero();
        }
      }

      this.state.isBeingMoved = false;
      this.state.movement.previousTime = -1;
    }
  }, {
    key: "calcVelocity",
    value: function calcVelocity(newTransform) {
      var currentTime = Date.now() / 1000;

      if (this.state.movement.previousTime < 0) {
        this.state.movement.previousTime = currentTime;
        return;
      }

      var deltaTime = currentTime - this.state.movement.previousTime; // If the time is too small, weird calculations may happen

      if (deltaTime < 0.0001) {
        return;
      }

      this.state.movement.velocity = newTransform.velocity(this.transform, deltaTime, this.move.freely.zeroVelocityThreshold, this.move.maxVelocity);
      this.state.movement.previousTime = currentTime;
    } // Moving Freely

  }, {
    key: "startMovingFreely",
    value: function startMovingFreely() {
      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      // this.stopAnimating();
      this.animations.cancelAll('noComplete');
      this.stopBeingMoved();

      if (callback) {
        // this.animate.transform.callback = callback;
        this.move.freely.callback = callback;
      }

      this.state.isMovingFreely = true;
      this.state.movement.previousTime = -1;
      this.state.movement.velocity = this.state.movement.velocity.clipMag(this.move.freely.zeroVelocityThreshold, this.move.maxVelocity);
    }
  }, {
    key: "stopMovingFreely",
    value: function stopMovingFreely() {
      var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      this.state.isMovingFreely = false;
      this.state.movement.previousTime = -1;

      if (this.move.freely.callback) {
        this.move.freely.callback(result); // if (result !== null && result !== undefined) {
        //   this.animate.transform.callback(result);
        // } else {
        //   this.animate.transform.callback();
        // }

        this.move.freely.callback = null;
      }
    } // Take an input transform matrix, and output a list of transform matrices
    // that have been transformed by a pulse. The first matrix in the list
    // will be the largest, so when saving lastDrawTransformMatrix it can be
    // used to determine if a touch has occured in the object.
    //
    // When an object is animated or moved, it's new transform is saved as the
    // new transform of the object. In contrast, pulsing is not saved as the
    // current transform of the object, and is used only in the current draw
    // of the element.

  }, {
    key: "transformWithPulse",
    value: function transformWithPulse(now, transform) {
      var pulseTransforms = []; // To output list of transform matrices
      // If the diagram element is currently pulsing, the calculate the current
      // pulse magnitude, and transform the input matrix by the pulse

      if (this.state.isPulsing) {
        // If this is the first pulse frame, then set the startTime
        if (this.state.pulse.startTime === -1) {
          this.state.pulse.startTime = now;
        } // Calculate how much time has elapsed between this frame and the first
        // pulse frame


        var deltaTime = now - this.state.pulse.startTime; // If the elapsed time is larger than the planned pulse time, then
        // clip the elapsed time to the pulse time, and end pulsing (after this
        // draw). If the pulse time is 0, that means pulsing will loop
        // indefinitely.

        if (deltaTime > this.pulseSettings.time && this.pulseSettings.time !== 0) {
          // this.state.isPulsing = false;
          this.stopPulsing(true);
          deltaTime = this.pulseSettings.time;
        } // Go through each pulse matrix planned, and transform the input matrix
        // with the pulse.


        for (var i = 0; i < this.pulseSettings.num; i += 1) {
          // Get the current pulse magnitude
          var pulseMag = this.pulseSettings.style(deltaTime, this.pulseSettings.frequency, this.pulseSettings.A instanceof Array ? this.pulseSettings.A[i] : this.pulseSettings.A, this.pulseSettings.B instanceof Array ? this.pulseSettings.B[i] : this.pulseSettings.B, this.pulseSettings.C instanceof Array ? this.pulseSettings.C[i] : this.pulseSettings.C); // Use the pulse magnitude to get the current pulse transform

          var pTransform = this.pulseSettings.transformMethod(pulseMag, Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(this.pulseSettings.delta)); // if(this.name === '_radius') {
          // }
          // Transform the current transformMatrix by the pulse transform matrix
          // const pMatrix = m2.mul(m2.copy(transform), pTransform.matrix());
          // Push the pulse transformed matrix to the array of pulse matrices

          pulseTransforms.push(transform.transform(pTransform));
        } // If not pulsing, then make no changes to the transformMatrix.

      } else {
        pulseTransforms.push(transform._dup());
      }

      return pulseTransforms;
    }
  }, {
    key: "pulseScaleNow",
    value: function pulseScaleNow(time, scale) {
      var frequency = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var delta = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      this.pulseSettings.time = time;

      if (frequency === 0 && time === 0) {
        this.pulseSettings.frequency = 1;
      }

      if (frequency !== 0) {
        this.pulseSettings.frequency = frequency;
      }

      if (time !== 0 && frequency === 0) {
        this.pulseSettings.frequency = 1 / (time * 2);
      }

      this.pulseSettings.A = 1;
      this.pulseSettings.B = scale - 1;
      this.pulseSettings.C = 0;
      this.pulseSettings.num = 1;
      this.pulseSettings.delta = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(delta); // this.pulseSettings.transformMethod = s => new Transform().scale(s, s);

      this.pulseSettings.callback = callback;
      this.pulseNow();
    }
  }, {
    key: "pulseScaleRelativeToPoint",
    value: function pulseScaleRelativeToPoint(p, space, time, scale) {
      var frequency = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var callback = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
      var currentPosition = this.getPosition(space);
      var delta = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(p).sub(currentPosition);
      this.pulseScaleNow(time, scale, frequency, callback, delta);
    }
  }, {
    key: "pulseScaleRelativeToElement",
    value: function pulseScaleRelativeToElement(e, x, y, space, time, scale) {
      var frequency = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
      var callback = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;
      var p;

      if (e == null) {
        p = this.getPositionInBounds(space, x, y);
      } else {
        p = e.getPositionInBounds(space, x, y);
      }

      this.pulseScaleRelativeToPoint(p, space, time, scale, frequency, callback);
    }
  }, {
    key: "pulseScaleRelativeTo",
    value: function pulseScaleRelativeTo(e, x, y, space, time, scale) {
      var frequency = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
      var callback = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;

      if (e == null || e instanceof DiagramElement) {
        this.pulseScaleRelativeToElement(e, x, y, space, time, scale, frequency, callback);
      } else {
        this.pulseScaleRelativeToPoint(e, space, time, scale, frequency, callback);
      }
    }
  }, {
    key: "pulseThickNow",
    value: function pulseThickNow(time, scale) {
      var num = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3;
      var callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var bArray = [scale];
      this.pulseSettings.num = num;

      if (this.pulseSettings.num > 1) {
        var b = Math.abs(1 - scale);
        var bMax = b;
        var bMin = -b;
        var range = bMax - bMin;
        var bStep = range / (this.pulseSettings.num - 1);
        bArray = [];

        for (var i = 0; i < this.pulseSettings.num; i += 1) {
          bArray.push(bMax - i * bStep);
        }
      }

      this.pulseSettings.time = time;
      this.pulseSettings.frequency = 1 / (time * 2);
      this.pulseSettings.A = 1;
      this.pulseSettings.B = bArray;
      this.pulseSettings.C = 0;
      this.pulseSettings.callback = callback;
      this.pulseNow();
    } // pulse(done: ?(mixed) => void = null) {
    //   this.pulseDefault(done);
    // }

  }, {
    key: "pulseNow",
    value: function pulseNow() {
      this.state.isPulsing = true;
      this.state.pulse.startTime = -1;
      this.unrender();
    }
  }, {
    key: "stopPulsing",
    value: function stopPulsing(result) {
      this.state.isPulsing = false;

      if (this.pulseSettings.callback) {
        var callback = this.pulseSettings.callback;
        this.pulseSettings.callback = null;
        callback(result);
      }
    }
  }, {
    key: "stop",
    value: function stop() {
      var cancelled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var forceSetToEndOfPlan = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (forceSetToEndOfPlan === true || forceSetToEndOfPlan === 'complete') {
        this.animations.cancelAll('complete');
      } else if (forceSetToEndOfPlan === false || forceSetToEndOfPlan === 'noComplete') {
        this.animations.cancelAll('noComplete');
      } else {
        this.animations.cancelAll(null);
      }

      this.stopMovingFreely(cancelled);
      this.stopBeingMoved();
      this.stopPulsing(cancelled);
    }
  }, {
    key: "cancel",
    value: function cancel() {
      var forceSetToEndOfPlan = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      this.stop(true, forceSetToEndOfPlan);
    }
  }, {
    key: "updateLimits",
    value: function updateLimits(limits) {
      var transforms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.diagramTransforms;
      this.diagramLimits = limits;
      this.diagramTransforms = transforms;
    }
  }, {
    key: "resize",
    value: function resize() {
      var diagramHTMLElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (diagramHTMLElement && this.tieToHTML.updateOnResize) {
        this.updateHTMLElementTie(diagramHTMLElement);
      }
    } // ***************************************************************
    // Boundaries
    // ***************************************************************
    // eslint-disable-next-line class-methods-use-this

  }, {
    key: "getVertexSpaceBoundaries",
    value: function getVertexSpaceBoundaries() {
      return [[]];
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "getGLBoundaries",
    value: function getGLBoundaries() {
      return [[]];
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "getLocalBoundaries",
    value: function getLocalBoundaries() {
      return [[]];
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "getDiagramBoundaries",
    value: function getDiagramBoundaries() {
      return [[]];
    }
  }, {
    key: "getBoundaries",
    value: function getBoundaries() {
      var space = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'local';

      if (space === 'local') {
        return this.getLocalBoundaries();
      }

      if (space === 'diagram') {
        return this.getDiagramBoundaries();
      }

      if (space === 'vertex') {
        return this.getVertexSpaceBoundaries();
      }

      if (space === 'gl') {
        return this.getGLBoundaries();
      }

      return [[]];
    } // ***************************************************************
    // Bounding Rect
    // ***************************************************************
    // eslint-disable-next-line class-methods-use-this

  }, {
    key: "getGLBoundingRect",
    value: function getGLBoundingRect() {
      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](0, 0, 1, 1);
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "getLocalBoundingRect",
    value: function getLocalBoundingRect() {
      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](0, 0, 1, 1);
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "getVertexSpaceBoundingRect",
    value: function getVertexSpaceBoundingRect() {
      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](0, 0, 1, 1);
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "getDiagramBoundingRect",
    value: function getDiagramBoundingRect() {
      var gl = this.getGLBoundingRect();
      var glToDiagramScale = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](this.diagramLimits.width / 2, this.diagramLimits.height / 2);
      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](gl.left * glToDiagramScale.x, gl.bottom * glToDiagramScale.y, gl.width * glToDiagramScale.x, gl.height * glToDiagramScale.y);
    }
  }, {
    key: "getBoundingRect",
    value: function getBoundingRect() {
      var space = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'local';

      if (space === 'local') {
        return this.getLocalBoundingRect();
      }

      if (space === 'diagram') {
        return this.getDiagramBoundingRect();
      }

      if (space === 'vertex') {
        return this.getVertexSpaceBoundingRect();
      }

      if (space === 'gl') {
        return this.getGLBoundingRect();
      }

      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](0, 0, 1, 1);
    } // ***************************************************************
    // Size
    // ***************************************************************

  }, {
    key: "getRelativeBoundingRect",
    value: function getRelativeBoundingRect() {
      var space = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'local';
      var rect = this.getBoundingRect(space);
      var position = this.getPosition(space);
      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](rect.left - position.x, rect.bottom - position.y, rect.width, rect.height);
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "getRelativeGLBoundingRect",
    value: function getRelativeGLBoundingRect() {
      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](0, 0, 1, 1);
    }
  }, {
    key: "getRelativeDiagramBoundingRect",
    value: function getRelativeDiagramBoundingRect() {
      var gl = this.getRelativeGLBoundingRect();
      var glToDiagramScale = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](this.diagramLimits.width / 2, this.diagramLimits.height / 2);
      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](gl.left * glToDiagramScale.x, gl.bottom * glToDiagramScale.y, gl.width * glToDiagramScale.x, gl.height * glToDiagramScale.y);
    }
  }, {
    key: "getCenterDiagramPosition",
    value: function getCenterDiagramPosition() {
      var rect = this.getDiagramBoundingRect();
      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](rect.left + rect.width / 2, rect.bottom + rect.height / 2);
    }
  }, {
    key: "getScale",
    value: function getScale() {
      var s = this.transform.s();
      var scale = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);

      if (s != null) {
        scale = s._dup();
      }

      return scale;
    }
  }, {
    key: "getRotation",
    value: function getRotation() {
      var normalize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var r = this.transform.r();
      var rotation = 0;

      if (r != null) {
        rotation = r;
      }

      if (normalize !== '' && r != null) {
        rotation = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["clipAngle"])(r, normalize);
      }

      return rotation;
    }
  }, {
    key: "getVertexSpaceDiagramPosition",
    value: function getVertexSpaceDiagramPosition(vertexSpacePoint) {
      var location = vertexSpacePoint.transformBy(this.lastDrawTransform.matrix());
      var glSpace = {
        x: {
          bottomLeft: -1,
          width: 2
        },
        y: {
          bottomLeft: -1,
          height: 2
        }
      };
      var diagramSpace = {
        x: {
          bottomLeft: this.diagramLimits.left,
          width: this.diagramLimits.width
        },
        y: {
          bottomLeft: this.diagramLimits.bottom,
          height: this.diagramLimits.height
        }
      };
      var glToDiagramSpace = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["spaceToSpaceTransform"])(glSpace, diagramSpace);
      return location.transformBy(glToDiagramSpace.matrix());
    }
  }, {
    key: "getLocalPosition",
    value: function getLocalPosition() {
      var t = this.transform.t();
      var position = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);

      if (t != null) {
        position = t._dup();
      }

      return position;
    } // // deprecated
    // getDiagramPosition() {
    //   // Note, this should be 0,0 as the current transform's translation will
    //   // be included in getVertexSpaceDiagramPosition
    //   return this.getVertexSpaceDiagramPosition(new Point(0, 0));
    // }
    // // eslint-disable-next-line class-methods-use-this
    // getGLPosition() {
    //   return new Point(0, 0);
    // }

  }, {
    key: "getPositionInBounds",
    value: function getPositionInBounds() {
      var space = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'local';
      var x = arguments.length > 1 ? arguments[1] : undefined;
      var y = arguments.length > 2 ? arguments[2] : undefined;
      var bounds = this.getBoundingRect(space);
      var p = this.getPosition(space);

      if (x === 'left') {
        p.x = bounds.left;
      } else if (x === 'right') {
        p.x = bounds.right;
      } else if (x === 'center') {
        p.x = bounds.left + bounds.width / 2;
      } else if (typeof x === 'number') {
        p.x = bounds.left + bounds.width * x;
      }

      if (y === 'top') {
        p.y = bounds.top;
      } else if (y === 'bottom') {
        p.y = bounds.bottom;
      } else if (y === 'middle') {
        p.y = bounds.bottom + bounds.height / 2;
      } else if (typeof y === 'number') {
        p.y = bounds.bottom + bounds.height * y;
      }

      return p;
    }
  }, {
    key: "getPosition",
    value: function getPosition() {
      var space = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'local';
      var x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'origin';
      var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'origin';

      // vertex space position doesn't mean much as it will always be 0, 0
      if (x !== 'origin' || y !== 'origin') {
        this.getPositionInBounds(space, x, y);
      }

      if (space === 'vertex') {
        return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      }

      if (space === 'local') {
        return this.getLocalPosition();
      }

      if (space === 'diagram') {
        // Note, this should be 0,0 as the current transform's translation will
        // be included in getVertexSpaceDiagramPosition
        return this.getVertexSpaceDiagramPosition(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0));
      }

      if (space === 'gl') {
        // Note, this should be 0,0 as the current transform's translation will
        // be included in getVertexSpaceDiagramPosition
        return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0).transformBy(this.lastDrawTransform.matrix());
      }

      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
    }
  }, {
    key: "getPixelToVertexSpaceScale",
    value: function getPixelToVertexSpaceScale() {
      var pixelToDiagram = this.diagramTransforms.pixelToDiagram.matrix();
      var diagramToVertex = this.diagramSpaceToVertexSpaceTransformMatrix();
      var scaleX = pixelToDiagram[0] * diagramToVertex[0];
      var scaleY = pixelToDiagram[4] * diagramToVertex[4];
      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](scaleX, scaleY);
    }
  }, {
    key: "getVertexToPixelSpaceScale",
    value: function getVertexToPixelSpaceScale() {
      var pixelToVertexSpaceScale = this.getPixelToVertexSpaceScale();
      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](1 / pixelToVertexSpaceScale.x, 1 / pixelToVertexSpaceScale.y);
    }
  }, {
    key: "getDiagramPositionInVertexSpace",
    value: function getDiagramPositionInVertexSpace(diagramPosition) {
      return diagramPosition.transformBy(this.diagramSpaceToVertexSpaceTransformMatrix());
    }
  }, {
    key: "diagramSpaceToVertexSpaceTransformMatrix",
    value: function diagramSpaceToVertexSpaceTransformMatrix() {
      // Diagram transform will always be two
      var t = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"](this.lastDrawTransform.order.slice(this.lastDrawElementTransformPosition.elementCount, this.lastDrawTransform.order.length - 2));
      return _tools_m2__WEBPACK_IMPORTED_MODULE_1__["inverse"](t.matrix());
    }
  }, {
    key: "vertexToDiagramSpaceTransformMatrix",
    value: function vertexToDiagramSpaceTransformMatrix() {
      var t = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"](this.lastDrawTransform.order.slice(0, this.lastDrawTransform.order.length - 2));
      return t.matrix();
    }
  }, {
    key: "setDiagramPosition",
    value: function setDiagramPosition(diagramPosition) {
      var glSpace = {
        x: {
          bottomLeft: -1,
          width: 2
        },
        y: {
          bottomLeft: -1,
          height: 2
        }
      };
      var diagramSpace = {
        x: {
          bottomLeft: this.diagramLimits.left,
          width: this.diagramLimits.width
        },
        y: {
          bottomLeft: this.diagramLimits.bottom,
          height: this.diagramLimits.height
        }
      };
      var diagramToGLSpace = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["spaceToSpaceTransform"])(diagramSpace, glSpace);
      var glLocation = diagramPosition.transformBy(diagramToGLSpace.matrix());
      var t = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"](this.lastDrawTransform.order.slice(this.transform.order.length));
      var newLocation = glLocation.transformBy(_tools_m2__WEBPACK_IMPORTED_MODULE_1__["inverse"](t.matrix()));
      this.setPosition(newLocation._dup());
    }
  }, {
    key: "setDiagramPositionToElement",
    value: function setDiagramPositionToElement(element) {
      var p = element.getPosition('diagram');
      this.setDiagramPosition(p._dup());
    }
  }, {
    key: "setPositionToElement",
    value: function setPositionToElement(element) {
      var p = element.transform.t();

      if (p != null) {
        this.setPosition(p._dup());
      }
    }
  }, {
    key: "setMoveBoundaryToDiagram",
    value: function setMoveBoundaryToDiagram() {
      var boundaryIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.move.boundary;
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](1, 1);

      if (!this.isMovable) {
        return;
      }

      if (boundaryIn != null) {
        this.move.boundary = boundaryIn;
      }

      if (this.move.boundary == null) {
        return;
      }

      var boundary;

      if (Array.isArray(this.move.boundary)) {
        var _this$move$boundary = _slicedToArray(this.move.boundary, 4),
            left = _this$move$boundary[0],
            bottom = _this$move$boundary[1],
            width = _this$move$boundary[2],
            height = _this$move$boundary[3];

        boundary = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](left, bottom, width, height);
      } else if (this.move.boundary === 'diagram') {
        boundary = this.diagramLimits;
      } else {
        boundary = this.move.boundary;
      }

      var glSpace = {
        x: {
          bottomLeft: -1,
          width: 2
        },
        y: {
          bottomLeft: -1,
          height: 2
        }
      };
      var diagramSpace = {
        x: {
          bottomLeft: this.diagramLimits.left,
          width: this.diagramLimits.width
        },
        y: {
          bottomLeft: this.diagramLimits.bottom,
          height: this.diagramLimits.height
        }
      };
      var glToDiagramSpace = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["spaceToSpaceTransform"])(glSpace, diagramSpace);
      var rect = this.getRelativeGLBoundingRect();
      var glToDiagramScaleMatrix = [glToDiagramSpace.matrix()[0], 0, 0, 0, glToDiagramSpace.matrix()[4], 0, 0, 0, 1];
      var minPoint = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](rect.left, rect.bottom).transformBy(glToDiagramScaleMatrix);
      var maxPoint = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](rect.right, rect.top).transformBy(glToDiagramScaleMatrix);
      var min = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      var max = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      min.x = boundary.left - minPoint.x * scale.x;
      min.y = boundary.bottom - minPoint.y * scale.y;
      max.x = boundary.right - maxPoint.x * scale.x;
      max.y = boundary.top - maxPoint.y * scale.y;
      this.move.maxTransform.updateTranslation(max.x, max.y);
      this.move.minTransform.updateTranslation(min.x, min.y);
    }
  }, {
    key: "show",
    value: function show() {
      this.isShown = true;
      this.setOpacity(1);

      if (this.parent != null) {
        if (!this.parent.isShown) {
          this.parent.show();
        }
      }
    }
  }, {
    key: "makeTouchable",
    value: function makeTouchable() {
      var makeThisElementTouchable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      if (makeThisElementTouchable) {
        this.isTouchable = true;
      } else {
        this.hasTouchableElements = true;
      }

      if (this.parent != null) {
        this.parent.makeTouchable(false);
      }
    }
  }, {
    key: "setMovable",
    value: function setMovable() {
      var movable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      if (movable) {
        this.isMovable = true;
        this.makeTouchable(true);
      } else {
        this.isMovable = false;
        this.isTouchable = false;
      }
    }
  }, {
    key: "clearRender",
    value: function clearRender() {
      var tieToElement;
      var elementId = '';

      if (typeof this.tieToHTML.element === 'string') {
        elementId = this.tieToHTML.element;
        tieToElement = document.getElementById(this.tieToHTML.element);
      }

      if (tieToElement) {
        var w = document.getElementById("".concat(elementId, "_webgl"));

        if (w != null) {
          // w.style.visibility = 'hidden';
          w.style.display = 'none';
        }

        var d = document.getElementById("".concat(elementId, "_2d"));

        if (d != null) {
          // d.style.visibility = 'hidden';
          d.style.display = 'none';
        }
      }
    }
  }, {
    key: "setRenderedOnNextDraw",
    value: function setRenderedOnNextDraw() {
      this.renderedOnNextDraw = true;
    }
  }, {
    key: "unrender",
    value: function unrender() {
      if (this.isRenderedAsImage) {
        this.unrenderNextDraw = true;
        this.isRenderedAsImage = false;
      }

      if (this.parent != null) {
        this.parent.unrender();
      }
    }
  }, {
    key: "showAll",
    value: function showAll() {
      this.show();
    }
  }, {
    key: "hide",
    value: function hide() {
      this.isShown = false;
    }
  }, {
    key: "hideAll",
    value: function hideAll() {
      this.hide();
    }
  }, {
    key: "toggleShow",
    value: function toggleShow() {
      if (this.isShown) {
        this.hide();
      } else {
        this.show();
      }
    }
  }, {
    key: "click",
    value: function click() {
      if (this.onClick !== null && this.onClick !== undefined) {
        this.onClick(this);
      }
    } // setMovable(movable: boolean = true) {
    //   if (movable) {
    //     this.isTouchable = true;
    //     this.isMovable = true;
    //   }
    // }

  }, {
    key: "getTransform",
    value: function getTransform() {
      return this.transform;
    }
  }]);

  return DiagramElement;
}(); // ***************************************************************
// Geometry Object
// ***************************************************************


var DiagramElementPrimitive =
/*#__PURE__*/
function (_DiagramElement) {
  _inherits(DiagramElementPrimitive, _DiagramElement);

  function DiagramElementPrimitive(drawingObject) {
    var _this3;

    var transform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();
    var color = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0.5, 0.5, 0.5, 1];
    var diagramLimits = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](-1, -1, 2, 2);
    var parent = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;

    _classCallCheck(this, DiagramElementPrimitive);

    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(DiagramElementPrimitive).call(this, transform, diagramLimits, parent));
    _this3.drawingObject = drawingObject;
    _this3.color = color != null ? color.slice() : [0, 0, 0, 0];
    _this3.defaultColor = _this3.color.slice();
    _this3.dimColor = [0.5, 0.5, 0.5, 1];
    _this3.pointsToDraw = -1;
    _this3.angleToDraw = -1;
    _this3.lengthToDraw = -1;
    _this3.cannotTouchHole = false;
    _this3.type = 'primitive'; // this.setMoveBoundaryToDiagram();

    return _this3;
  }

  _createClass(DiagramElementPrimitive, [{
    key: "setAngleToDraw",
    value: function setAngleToDraw() {
      var intputAngle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;
      this.angleToDraw = intputAngle;
    }
  }, {
    key: "isBeingTouched",
    value: function isBeingTouched(glLocation) {
      if (!this.isTouchable) {
        return false;
      }

      var boundaries = this.drawingObject.getGLBoundaries(this.lastDrawTransform.matrix());
      var holeBoundaries = this.drawingObject.getGLBoundaryHoles(this.lastDrawTransform.matrix());

      for (var i = 0; i < boundaries.length; i += 1) {
        var boundary = boundaries[i];

        if (glLocation.isInPolygon(boundary)) {
          var isTouched = true;

          if (this.cannotTouchHole) {
            for (var j = 0; j < holeBoundaries.length; j += 1) {
              var holeBoundary = holeBoundaries[j];

              if (Array.isArray(holeBoundary) && holeBoundary.length > 2) {
                if (glLocation.isInPolygon(holeBoundary)) {
                  isTouched = false;
                  j = holeBoundaries.length;
                }
              }
            }
          }

          if (isTouched) {
            return true;
          }
        }
      }

      return false;
    } // updateContext(context: DrawContext2D) {
    //   if (this.drawingObject instanceof TextObject) {
    //     this.drawingObject.drawContext2D = context;
    //   }
    // }

  }, {
    key: "_dup",
    value: function _dup() {
      var transform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      // const vertices = this.drawingObject._dup();
      var primative = new DiagramElementPrimitive(this.drawingObject._dup()); // const primative = new DiagramElementPrimitive(
      //   vertices,
      //   transform,
      //   color,
      //   this.diagramLimits._dup(),
      // );
      // primative.pointsToDraw = this.pointsToDraw;
      // primative.angleToDraw = this.angleToDraw;
      // primative.copyFrom(this);

      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_7__["duplicateFromTo"])(this, primative, ['parent']);

      if (transform != null) {
        primative.transform = transform._dup();
      }

      return primative;
    }
  }, {
    key: "clear",
    value: function clear() {
      var canvasIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      if (this.drawingObject instanceof _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_6__["TextObject"]) {
        this.drawingObject.clear(canvasIndex);
      }
    }
  }, {
    key: "resize",
    value: function resize() {
      var diagramHTMLElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      this.resizeHtmlObject();

      _get(_getPrototypeOf(DiagramElementPrimitive.prototype), "resize", this).call(this, diagramHTMLElement); // If gl canvas is resized, webgl text will need to be updated.


      if (this.drawingObject.type === 'vertexText') {
        var pixelToVertexScale = this.getPixelToVertexSpaceScale(); // $FlowFixMe

        this.drawingObject.drawTextIntoBuffer(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](pixelToVertexScale.x, Math.abs(pixelToVertexScale.y)));
      }
    }
  }, {
    key: "setColor",
    value: function setColor(color) {
      var setDefault = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      this.color = color != null ? color.slice() : [0, 0, 0, 0];

      if (setDefault) {
        this.defaultColor = this.color.slice();
      }

      if (this instanceof DiagramElementPrimitive) {
        if (this.drawingObject instanceof _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_6__["TextObject"]) {
          this.drawingObject.setColor(this.color);
        }

        if (this.drawingObject instanceof _DrawingObjects_HTMLObject_HTMLObject__WEBPACK_IMPORTED_MODULE_3__["default"]) {
          // $FlowFixMe
          this.drawingObject.element.style.color = Object(_tools_color__WEBPACK_IMPORTED_MODULE_8__["colorArrayToRGBA"])(this.color);
        }
      }
    }
  }, {
    key: "setOpacity",
    value: function setOpacity(opacity) {
      // this.color[3] = opacity;
      this.opacity = opacity;

      if (this instanceof DiagramElementPrimitive) {
        if (this.drawingObject instanceof _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_6__["TextObject"]) {
          this.drawingObject.setOpacity(opacity);
        }

        if (this.drawingObject instanceof _DrawingObjects_HTMLObject_HTMLObject__WEBPACK_IMPORTED_MODULE_3__["default"]) {
          // this.drawingObject.element.style.color =
          // colorArrayToRGBA([...this.color.slice(0, 2), opacity]);
          // console.log(this.drawingObject.element)
          this.drawingObject.element.style.opacity = "".concat(opacity);
        }
      }
    }
  }, {
    key: "show",
    value: function show() {
      _get(_getPrototypeOf(DiagramElementPrimitive.prototype), "show", this).call(this);

      if (this.drawingObject instanceof _DrawingObjects_HTMLObject_HTMLObject__WEBPACK_IMPORTED_MODULE_3__["default"]) {
        this.drawingObject.show = true; // This line is a challenge.
        // It will show a html element immediately before the next draw frame
        // meaning the draw matrix will be old.
        // If this line is removed, it causes a blanking between lesson pages
        // for html elements that are always on screen
        // Therefore, should use diagram.setFirstTransform before using this,
        // or in the future remove this line, and the line in hide(), and
        // somehow do the hide in the draw call

        this.drawingObject.transformHtml(this.lastDrawTransform.matrix());
      }
    } // showAll() {
    //   this.show();
    // }

  }, {
    key: "hide",
    value: function hide() {
      _get(_getPrototypeOf(DiagramElementPrimitive.prototype), "hide", this).call(this);

      if (this.drawingObject instanceof _DrawingObjects_HTMLObject_HTMLObject__WEBPACK_IMPORTED_MODULE_3__["default"]) {
        this.drawingObject.show = false;
        this.drawingObject.transformHtml(this.lastDrawTransform.matrix());
      }
    } // hideAll() {
    //   this.hide();
    // }

  }, {
    key: "getTouched",
    value: function getTouched(glLocation) {
      if (!this.isTouchable) {
        return [];
      }

      if (this.isBeingTouched(glLocation)) {
        return [this];
      }

      return [];
    }
  }, {
    key: "setFont",
    value: function setFont(fontSize) {
      if (this.drawingObject instanceof _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_6__["TextObject"]) {
        this.drawingObject.setFont(fontSize);
      }
    }
  }, {
    key: "resizeHtmlObject",
    value: function resizeHtmlObject() {
      if (this.drawingObject instanceof _DrawingObjects_HTMLObject_HTMLObject__WEBPACK_IMPORTED_MODULE_3__["default"]) {
        this.drawingObject.transformHtml(this.lastDrawTransform.matrix());
      }
    }
  }, {
    key: "draw",
    value: function draw() {
      var _this4 = this;

      var parentTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();
      var now = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var canvasIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

      if (this.isShown) {
        if (this.isRenderedAsImage === true) {
          if (this.willStartAnimating()) {
            this.unrender();
          } else {
            return;
          }
        }

        if (this.beforeDrawCallback != null) {
          this.beforeDrawCallback(now);
        }

        this.animations.nextFrame(now);
        this.nextMovingFreelyFrame(now);

        if (!this.isShown) {
          return;
        }

        this.lastDrawElementTransformPosition = {
          parentCount: parentTransform.order.length,
          elementCount: this.transform.order.length
        };
        var newTransform = parentTransform.transform(this.getTransform());
        this.lastDrawTransform = newTransform._dup();
        var pulseTransforms = this.transformWithPulse(now, newTransform); // eslint-disable-next-line prefer-destructuring

        this.lastDrawPulseTransform = pulseTransforms[0]; // this.lastDrawTransform = pulseTransforms[0];

        var pointCount = -1;

        if (this.drawingObject instanceof _DrawingObjects_VertexObject_VertexObject__WEBPACK_IMPORTED_MODULE_5__["default"]) {
          pointCount = this.drawingObject.numPoints;

          if (this.angleToDraw !== -1) {
            pointCount = this.drawingObject.getPointCountForAngle(this.angleToDraw);
          }

          if (this.lengthToDraw !== -1) {
            pointCount = this.drawingObject.getPointCountForLength(this.lengthToDraw);
          }

          if (this.pointsToDraw !== -1) {
            pointCount = this.pointsToDraw;
          }
        } else {
          pointCount = 1;
        }

        var colorToUse = [].concat(_toConsumableArray(this.color.slice(0, 3)), [this.color[3] * this.opacity]);

        if (pointCount > 0) {
          pulseTransforms.forEach(function (t) {
            _this4.drawingObject.drawWithTransformMatrix(t.matrix(), colorToUse, canvasIndex, pointCount);
          });
        }

        if (this.unrenderNextDraw) {
          this.clearRender();
          this.unrenderNextDraw = false;
        }

        if (this.renderedOnNextDraw) {
          this.isRenderedAsImage = true;
          this.renderedOnNextDraw = false;
        }

        if (this.afterDrawCallback != null) {
          this.afterDrawCallback(now);
        }
      }
    }
  }, {
    key: "setFirstTransform",
    value: function setFirstTransform() {
      var parentTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();
      this.lastDrawElementTransformPosition = {
        parentCount: parentTransform.order.length,
        elementCount: this.transform.order.length
      }; // const finalParentTransform = this.processParentTransform(parentTransform);

      var firstTransform = parentTransform.transform(this.getTransform());
      this.lastDrawTransform = firstTransform;

      if (this.drawingObject instanceof _DrawingObjects_HTMLObject_HTMLObject__WEBPACK_IMPORTED_MODULE_3__["default"]) {
        this.drawingObject.transformHtml(firstTransform.matrix());
      }

      this.setMoveBoundaryToDiagram();
    }
  }, {
    key: "isMoving",
    value: function isMoving() {
      if ( // this.state.isAnimating
      this.state.isMovingFreely || this.state.isBeingMoved || this.state.isPulsing // || this.state.isAnimatingColor
      // || this.state.isAnimatingCustom
      || this.animations.willStartAnimating()) {
        return true;
      }

      return false;
    } // setupWebGLBuffers(newWebgl: WebGLInstance) {
    //   const { drawingObject } = this;
    //   if (drawingObject instanceof VertexObject) {
    //     const oldWebgl = drawingObject.webgl;
    //     drawingObject.webgl = newWebgl;
    //     drawingObject.gl = newWebgl.gl;
    //     drawingObject.setupBuffer();
    //     drawingObject.webgl = oldWebgl;
    //     drawingObject.gl = oldWebgl.gl;
    //   }
    // }
    // changeWebGLInstance(newWebgl: WebGLInstance) {
    //   let oldWebgl;
    //   const { drawingObject } = this;
    //   if (drawingObject instanceof VertexObject) {
    //     oldWebgl = drawingObject.webgl;
    //     drawingObject.webgl = newWebgl;
    //     drawingObject.gl = newWebgl.gl;
    //   }
    //   return oldWebgl;
    // }

  }, {
    key: "getVertexSpaceBoundaries",
    value: function getVertexSpaceBoundaries() {
      return this.drawingObject.border;
    }
  }, {
    key: "getLocalBoundaries",
    value: function getLocalBoundaries() {
      return this.drawingObject.getGLBoundaries(this.getTransform().matrix());
    }
  }, {
    key: "getDiagramBoundaries",
    value: function getDiagramBoundaries() {
      return this.drawingObject.getGLBoundaries(this.vertexToDiagramSpaceTransformMatrix());
    }
  }, {
    key: "getGLBoundaries",
    value: function getGLBoundaries() {
      return this.drawingObject.getGLBoundaries(this.lastDrawTransform.matrix());
    }
  }, {
    key: "getVertexSpaceBoundingRect",
    value: function getVertexSpaceBoundingRect() {
      return this.drawingObject.getVertexSpaceBoundingRect();
    }
  }, {
    key: "getLocalBoundingRect",
    value: function getLocalBoundingRect() {
      return this.drawingObject.getGLBoundingRect(this.getTransform().matrix());
    }
  }, {
    key: "getGLBoundingRect",
    value: function getGLBoundingRect() {
      return this.drawingObject.getGLBoundingRect(this.lastDrawTransform.matrix());
    }
  }, {
    key: "getRelativeVertexSpaceBoundingRect",
    value: function getRelativeVertexSpaceBoundingRect() {
      return this.drawingObject.getRelativeVertexSpaceBoundingRect();
    }
  }, {
    key: "getRelativeGLBoundingRect",
    value: function getRelativeGLBoundingRect() {
      return this.drawingObject.getRelativeGLBoundingRect(this.lastDrawTransform.matrix());
    }
  }, {
    key: "getRelativeLocalBoundingRect",
    value: function getRelativeLocalBoundingRect() {
      return this.drawingObject.getRelativeGLBoundingRect(this.getTransform().matrix());
    }
  }, {
    key: "increaseBorderSize",
    value: function increaseBorderSize() {
      var xMultiplierOrPoint = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var yMultiplier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var xMulToUse;
      var yMulToUse;

      if (xMultiplierOrPoint instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"]) {
        xMulToUse = xMultiplierOrPoint.x;
        yMulToUse = xMultiplierOrPoint.y;
      } else {
        xMulToUse = xMultiplierOrPoint;

        if (yMultiplier == null) {
          yMulToUse = xMulToUse;
        } else {
          yMulToUse = yMultiplier;
        }
      }

      if (this.drawingObject instanceof _DrawingObjects_VertexObject_VertexObject__WEBPACK_IMPORTED_MODULE_5__["default"]) {
        for (var b = 0; b < this.drawingObject.border.length; b += 1) {
          var border = this.drawingObject.border[b];

          for (var i = 0; i < border.length; i += 1) {
            border[i].x *= xMulToUse;
            border[i].y *= yMulToUse;
          }
        }
      }
    }
  }]);

  return DiagramElementPrimitive;
}(DiagramElement); // ***************************************************************
// Collection of Geometry Objects or Collections
// ***************************************************************


var DiagramElementCollection =
/*#__PURE__*/
function (_DiagramElement2) {
  _inherits(DiagramElementCollection, _DiagramElement2);

  function DiagramElementCollection() {
    var _this5;

    var transform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();
    var diagramLimits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](-1, 1, 2, 2);
    var parent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    _classCallCheck(this, DiagramElementCollection);

    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(DiagramElementCollection).call(this, transform, diagramLimits, parent));
    _this5.elements = {};
    _this5.drawOrder = [];
    _this5.touchInBoundingRect = false;
    _this5.eqns = {};
    _this5.type = 'collection';
    return _this5;
  }

  _createClass(DiagramElementCollection, [{
    key: "_dup",
    value: function _dup() {
      var collection = new DiagramElementCollection(); // collection.touchInBoundingRect = this.touchInBoundingRect;
      // collection.copyFrom(this);

      var doNotDuplicate = this.drawOrder.map(function (e) {
        return "_".concat(e);
      });
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_7__["duplicateFromTo"])(this, collection, ['elements', 'drawOrder', 'parent'].concat(_toConsumableArray(doNotDuplicate)));

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var name = this.drawOrder[i];
        collection.add(name, this.elements[name]._dup());
      }

      return collection;
    }
  }, {
    key: "toFront",
    value: function toFront(elements) {
      var names = [];
      elements.forEach(function (element) {
        if (typeof element === 'string') {
          names.push(element);
        } else {
          names.push(element.name);
        }
      });
      var newOrder = [];
      this.drawOrder.forEach(function (element) {
        if (names.indexOf(element) === -1) {
          newOrder.push(element);
        }
      });
      this.drawOrder = [].concat(newOrder, names);
    }
  }, {
    key: "toBack",
    value: function toBack(elements) {
      var names = [];
      elements.forEach(function (element) {
        if (typeof element === 'string') {
          names.push(element);
        } else {
          names.push(element.name);
        }
      });
      var newOrder = [];
      this.drawOrder.forEach(function (element) {
        if (names.indexOf(element) === -1) {
          newOrder.push(element);
        }
      });
      this.drawOrder = [].concat(_toConsumableArray(names.reverse()), newOrder);
    }
  }, {
    key: "isMoving",
    value: function isMoving() {
      if (this.isShown === false) {
        return false;
      }

      if (this.state.isMovingFreely || this.state.isBeingMoved || this.state.isPulsing || this.animations.state === 'animating') {
        return true;
      }

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];

        if (element instanceof DiagramElementCollection) {
          if (element.isMoving()) {
            return true;
          }
        } else if (element.isShown && element.color[3] > 0 && element.isMoving()) {
          return true;
        }
      }

      return false;
    }
  }, {
    key: "add",
    value: function add(name, diagramElement) {
      var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
      // eslint-disable-next-line no-param-reassign
      diagramElement.parent = this;
      this.elements[name] = diagramElement;
      this.elements[name].name = name; // $FlowFixMe

      this["_".concat(name)] = this.elements[name];

      if (index !== -1) {
        this.drawOrder = [].concat(_toConsumableArray(this.drawOrder.slice(0, index)), [name], _toConsumableArray(this.drawOrder.slice(index)));
      } else {
        this.drawOrder.push(name);
      }
    }
  }, {
    key: "willStartAnimating",
    value: function willStartAnimating() {
      var result = _get(_getPrototypeOf(DiagramElementCollection.prototype), "willStartAnimating", this).call(this);

      if (result) {
        return true;
      }

      for (var i = 0, j = this.drawOrder.length; i < j; i += 1) {
        if (this.elements[this.drawOrder[i]].willStartAnimating()) {
          return true;
        }
      }

      return false;
    }
  }, {
    key: "draw",
    value: function draw() {
      var parentTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();
      var now = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var canvasIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

      if (this.isShown) {
        if (this.isRenderedAsImage === true) {
          if (this.willStartAnimating()) {
            this.unrender();
          } else {
            return;
          }
        }

        if (this.beforeDrawCallback != null) {
          this.beforeDrawCallback(now);
        }

        this.animations.nextFrame(now);
        this.nextMovingFreelyFrame(now); // set next color can end up hiding an element when disolving out

        if (!this.isShown) {
          return;
        }

        this.lastDrawElementTransformPosition = {
          parentCount: parentTransform.order.length,
          elementCount: this.transform.order.length
        };
        var newTransform = parentTransform.transform(this.getTransform());
        this.lastDrawTransform = newTransform._dup();
        var pulseTransforms = this.transformWithPulse(now, newTransform); // eslint-disable-next-line prefer-destructuring

        this.lastDrawPulseTransform = pulseTransforms[0]; // this.lastDrawTransform = pulseTransforms[0];
        // this.lastDrawPulseTransform = pulseTransforms[0]._dup();

        for (var k = 0; k < pulseTransforms.length; k += 1) {
          for (var i = 0, j = this.drawOrder.length; i < j; i += 1) {
            this.elements[this.drawOrder[i]].draw(pulseTransforms[k], now, canvasIndex);
          }
        }

        if (this.unrenderNextDraw) {
          this.clearRender();
          this.unrenderNextDraw = false;
        }

        if (this.renderedOnNextDraw) {
          this.isRenderedAsImage = true;
          this.renderedOnNextDraw = false;
        }

        if (this.afterDrawCallback != null) {
          this.afterDrawCallback(now);
        }
      }
    }
  }, {
    key: "exec",
    value: function exec(execFunctionAndArgs) {
      var _this6 = this;

      var elementsToExec = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (elementsToExec == null) {
        _get(_getPrototypeOf(DiagramElementCollection.prototype), "exec", this).call(this, execFunctionAndArgs);

        return;
      }

      if (Array.isArray(elementsToExec) && elementsToExec.length === 0) {
        return;
      }

      elementsToExec.forEach(function (elementToExec) {
        var element;

        if (typeof elementToExec === 'string') {
          element = _this6.getElement(elementToExec);
        } else {
          element = elementToExec;
        }

        if (element != null) {
          element.exec(execFunctionAndArgs);
        }
      });
    }
  }, {
    key: "pulse",
    value: function pulse() {
      var _this7 = this;

      var optionsOrElementsOrDone = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var done = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (optionsOrElementsOrDone == null || typeof optionsOrElementsOrDone === 'function') {
        _get(_getPrototypeOf(DiagramElementCollection.prototype), "pulse", this).call(this, optionsOrElementsOrDone);

        return;
      }

      var defaultPulseOptions = {
        frequency: 0,
        time: 1,
        scale: 2
      };

      if (typeof this.pulseDefault !== 'function') {
        defaultPulseOptions.frequency = this.pulseDefault.frequency;
        defaultPulseOptions.time = this.pulseDefault.time;
        defaultPulseOptions.scale = this.pulseDefault.scale;
      }

      var defaultOptions = {
        x: 'center',
        y: 'middle',
        space: 'diagram',
        centerOn: null,
        frequency: defaultPulseOptions.frequency,
        time: defaultPulseOptions.time,
        scale: defaultPulseOptions.scale,
        done: null,
        elements: null
      };
      var doneToUse;
      var options;
      var elements;

      if (Array.isArray(optionsOrElementsOrDone)) {
        options = defaultOptions;
        doneToUse = done;
        elements = optionsOrElementsOrDone;
      } else {
        options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_7__["joinObjects"])({}, defaultOptions, optionsOrElementsOrDone);
        var _options2 = options;
        elements = _options2.elements;
        doneToUse = options.done;

        if (optionsOrElementsOrDone.scale == null) {
          options.scale = undefined;
        }

        if (optionsOrElementsOrDone.frequency == null) {
          options.frequency = undefined;
        }

        if (optionsOrElementsOrDone.time == null) {
          options.time = undefined;
        }
      }

      options.elements = null;

      if (elements == null || elements.length === 0) {
        _get(_getPrototypeOf(DiagramElementCollection.prototype), "pulse", this).call(this, optionsOrElementsOrDone);

        return;
      }

      var counter = 0;

      var combinedCallback = function combinedCallback() {
        counter += 1;

        if (counter === elements.length) {
          if (doneToUse != null) {
            doneToUse();
          }
        }
      }; // $FlowFixMe


      options.done = combinedCallback; // let doneToUse = done;

      elements.forEach(function (elementToPulse) {
        var element;

        if (typeof elementToPulse === 'string') {
          element = _this7.getElement(elementToPulse);
        } else {
          element = elementToPulse;
        }

        if (element != null) {
          // element.pulseDefault(doneToUse);
          element.pulse(options); // doneToUse = null;
        }
      }); // if (doneToUse != null) {
      //   doneToUse();
      // }
      // if (typeof this.pulseDefault === 'function') {
      //   this.pulseDefault(done);
      // } else {
      //   // const { frequency, time, scale } = this.pulseDefault;
      //   // this.pulseScaleNow(time, scale, frequency, done);
      //   this.pulseScaleRelativeTo(
      //     options.centeredOn,
      //     options.x,
      //     options.y,
      //     options.space,
      //     options.time,
      //     options.scale,
      //     options.frequency,
      //     done,
      //   );
      // }
    }
  }, {
    key: "pulseLegacy",
    value: function pulseLegacy(elementsOrDone) {
      var _this8 = this;

      var done = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (elementsOrDone == null || typeof elementsOrDone === 'function') {
        _get(_getPrototypeOf(DiagramElementCollection.prototype), "pulse", this).call(this, elementsOrDone);

        return;
      }

      var doneToUse = done;
      elementsOrDone.forEach(function (elementToPulse) {
        var element;

        if (typeof elementToPulse === 'string') {
          element = _this8.getElement(elementToPulse);
        } else {
          element = elementToPulse;
        }

        if (element != null) {
          // element.pulseDefault(doneToUse);
          element.pulse(doneToUse);
          doneToUse = null;
        }
      });

      if (doneToUse != null) {
        doneToUse();
      }
    }
  }, {
    key: "getElement",
    value: function getElement() {
      var elementPath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (elementPath == null) {
        return this;
      }

      if (typeof elementPath !== 'string') {
        return elementPath;
      } // if (elementPath instanceof DiagramElement) {
      //   return elementPath;
      // }


      var getElement = function getElement(inputElementPath, parent) {
        var ep = inputElementPath.split('.');
        var newParent = parent.elements[ep[0]];

        if (newParent == null) {
          // $FlowFixMe
          newParent = parent[ep[0]];
        }

        if (newParent == null) {
          return null;
        }

        if (ep.length > 1) {
          return getElement(ep.slice(1).join('.'), newParent);
        }

        return newParent;
      };

      return getElement(elementPath, this);
    }
  }, {
    key: "getElements",
    value: function getElements(children) {
      var _this9 = this;

      var elements = [];
      children.forEach(function (child) {
        var element = _this9.getElement(child);

        if (element != null) {
          elements.push(element);
        }
      });
      return elements;
    }
  }, {
    key: "show",
    value: function show() {
      var listToShow = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      _get(_getPrototypeOf(DiagramElementCollection.prototype), "show", this).call(this);

      listToShow.forEach(function (element) {
        if (element instanceof DiagramElementCollection) {
          element.showAll();
        } else {
          element.show();
        }
      });
    }
  }, {
    key: "hide",
    value: function hide() {
      var listToShow = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      _get(_getPrototypeOf(DiagramElementCollection.prototype), "hide", this).call(this);

      listToShow.forEach(function (element) {
        if (element instanceof DiagramElementCollection) {
          element.hideAll();
        } else {
          element.show();
        }
      });
    }
  }, {
    key: "showAll",
    value: function showAll() {
      this.show();

      for (var i = 0, j = this.drawOrder.length; i < j; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.show();

        if (typeof element.hideAll === 'function') {
          element.showAll();
        }
      }
    }
  }, {
    key: "hideAll",
    value: function hideAll() {
      this.hide();

      for (var i = 0, j = this.drawOrder.length; i < j; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.hide();

        if (typeof element.hideAll === 'function') {
          element.hideAll();
        }
      }
    }
  }, {
    key: "showOnly",
    value: function showOnly(listToShow) {
      this.hideAll();
      this.show();

      for (var i = 0, j = listToShow.length; i < j; i += 1) {
        var element = listToShow[i];

        if (element) {
          element.show();
        } else {
          throw Error("Diagram Element Error: Element does not exist at position ".concat(i));
        }
      }
    }
  }, {
    key: "hideOnly",
    value: function hideOnly(listToHide) {
      this.showAll();

      for (var i = 0, j = listToHide.length; i < j; i += 1) {
        var element = listToHide[i];
        element.hide();
      }
    } // This will only search elements within the collection for a touch
    // if the collection is touchable. Note, the elements can be queried
    // directly still, and will return if they are touched if they themselves
    // are touchable.

  }, {
    key: "isBeingTouched",
    value: function isBeingTouched(glLocation) {
      if (!this.isTouchable) {
        return false;
      }

      if (this.touchInBoundingRect) {
        var boundingRect = this.getGLBoundingRect();

        if (glLocation.x >= boundingRect.left && glLocation.x <= boundingRect.right && glLocation.y <= boundingRect.top && glLocation.y >= boundingRect.bottom) {
          return true;
        }
      }

      for (var i = 0, j = this.drawOrder.length; i < j; i += 1) {
        var element = this.elements[this.drawOrder[i]];

        if (element.isShown === true) {
          if (element.isBeingTouched(glLocation)) {
            return true;
          }
        }
      }

      return false;
    }
  }, {
    key: "resizeHtmlObject",
    value: function resizeHtmlObject() {
      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.resizeHtmlObject();
      }
    }
  }, {
    key: "resize",
    value: function resize() {
      var diagramHTMLElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      _get(_getPrototypeOf(DiagramElementCollection.prototype), "resize", this).call(this, diagramHTMLElement);

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.resize(diagramHTMLElement);
      }
    }
  }, {
    key: "clear",
    value: function clear() {
      var canvasIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.clear(canvasIndex);
      }
    }
  }, {
    key: "setFirstTransform",
    value: function setFirstTransform() {
      var parentTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();
      // const finalParentTransform = this.processParentTransform(parentTransform);
      var firstTransform = parentTransform.transform(this.getTransform());
      this.lastDrawTransform = firstTransform;

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.setFirstTransform(firstTransform);
      }

      this.setMoveBoundaryToDiagram();
    }
  }, {
    key: "getAllBoundaries",
    value: function getAllBoundaries() {
      var space = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'local';
      var boundaries = [];

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];

        if (element.isShown) {
          var elementBoundaries = element.getBoundaries(space);
          boundaries = boundaries.concat(elementBoundaries);
        }
      }

      return boundaries;
    }
  }, {
    key: "getBoundaries",
    value: function getBoundaries() {
      var _this10 = this;

      var space = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'local';
      var children = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var boundaries = [];

      if (children == null) {
        return this.getAllBoundaries(space);
      }

      children.forEach(function (child) {
        var e = _this10.getElement(child);

        if (e == null) {
          return;
        }

        var elementBoundaries = e.getBoundaries(space);
        boundaries = boundaries.concat(elementBoundaries);
      });
      return boundaries;
    } // deprecated

  }, {
    key: "getGLBoundaries",
    value: function getGLBoundaries() {
      var boundaries = [];

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];

        if (element.isShown) {
          var elementBoundaries = element.getGLBoundaries();
          boundaries = boundaries.concat(elementBoundaries);
        }
      }

      return boundaries;
    } // deprecated

  }, {
    key: "getVertexSpaceBoundaries",
    value: function getVertexSpaceBoundaries() {
      var boundaries = [];

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];

        if (element.isShown) {
          var elementBoundaries = element.getVertexSpaceBoundaries();
          boundaries = boundaries.concat(elementBoundaries);
        }
      }

      return boundaries;
    } // getBoundaries() {
    //   let boundaries = [];
    //   for (let i = 0; i < this.drawOrder.length; i += 1) {
    //     const element = this.elements[this.drawOrder[i]];
    //     if (element.isShown) {
    //       const elementBoundaries = element.getBoundaries();
    //       boundaries = boundaries.concat(elementBoundaries);
    //     }
    //   }
    //   return boundaries;
    // }

  }, {
    key: "getPositionInBounds",
    value: function getPositionInBounds() {
      var space = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'local';
      var x = arguments.length > 1 ? arguments[1] : undefined;
      var y = arguments.length > 2 ? arguments[2] : undefined;
      var children = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var bounds = this.getBoundingRect(space, children);
      var p = this.getPosition(space);

      if (x === 'left') {
        p.x = bounds.left;
      } else if (x === 'right') {
        p.x = bounds.right;
      } else if (x === 'center') {
        p.x = bounds.left + bounds.width / 2;
      } else if (typeof x === 'number') {
        p.x = bounds.left + bounds.width * x;
      }

      if (y === 'top') {
        p.y = bounds.top;
      } else if (y === 'bottom') {
        p.y = bounds.bottom;
      } else if (y === 'middle') {
        p.y = bounds.bottom + bounds.height / 2;
      } else if (typeof y === 'number') {
        p.y = bounds.bottom + bounds.height * y;
      }

      return p;
    }
  }, {
    key: "getBoundingRect",
    value: function getBoundingRect() {
      var _this11 = this;

      var space = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'local';
      var children = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (children == null) {
        var boundaries = this.getBoundaries(space);
        return Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getBoundingRect"])(boundaries);
      }

      var points = [];
      children.forEach(function (child) {
        var e = _this11.getElement(child);

        if (e == null) {
          return;
        }

        var bound = e.getBoundingRect();
        points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](bound.left, bound.bottom));
        points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](bound.right, bound.top));
      });
      return Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getBoundingRect"])(points);
    }
  }, {
    key: "getGLBoundingRect",
    value: function getGLBoundingRect() {
      var glAbsoluteBoundaries = this.getGLBoundaries();
      return Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getBoundingRect"])(glAbsoluteBoundaries);
    }
  }, {
    key: "getVertexSpaceBoundingRect",
    value: function getVertexSpaceBoundingRect() {
      var _this12 = this;

      var elementsToBound = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (elementsToBound == null) {
        // return super.getDiagramBoundingRect();
        var boundaries = this.getVertexSpaceBoundaries();
        return Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getBoundingRect"])(boundaries);
      }

      var points = [];
      elementsToBound.forEach(function (element) {
        var e = _this12.getElement(element);

        if (e == null) {
          return;
        }

        var bound = e.getBoundingRect();
        points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](bound.left, bound.bottom));
        points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](bound.right, bound.top));
      });
      return Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getBoundingRect"])(points);
    }
  }, {
    key: "getRelativeGLBoundingRect",
    value: function getRelativeGLBoundingRect() {
      var boundingRect = this.getGLBoundingRect();
      var location = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0).transformBy(this.lastDrawTransform.matrix());
      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](boundingRect.left - location.x, boundingRect.bottom - location.y, boundingRect.width, boundingRect.height);
    } // deprecated

  }, {
    key: "getRelativeVertexSpaceBoundingRect",
    value: function getRelativeVertexSpaceBoundingRect() {
      var boundingRect = this.getVertexSpaceBoundingRect();
      var location = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](boundingRect.left - location.x, boundingRect.bottom - location.y, boundingRect.width, boundingRect.height);
    }
  }, {
    key: "updateLimits",
    value: function updateLimits(limits) {
      var transforms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.diagramTransforms;

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.updateLimits(limits, transforms);
      }

      this.diagramLimits = limits;
      this.diagramTransforms = transforms;
    }
  }, {
    key: "updateHTMLElementTie",
    value: function updateHTMLElementTie(container) {
      _get(_getPrototypeOf(DiagramElementCollection.prototype), "updateHTMLElementTie", this).call(this, container);

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.updateHTMLElementTie(container);
      }
    } // Returns an array of touched elements.
    // In a collection, elements defined later in the collection.order
    // array are on top of earlier elements. The touched array
    // is sorted to have elements on top first, where the collection containing
    // the elements will be before it's elements. For example, the array
    // would be ordered as:
    //  0: top collection
    //  1 to n: n top elements in collection
    //  n+1: second top collection
    //  n+2 to m: top elements in second top colleciton.

  }, {
    key: "getTouched",
    value: function getTouched(glLocation) {
      if (!this.isTouchable && !this.hasTouchableElements) {
        return [];
      }

      var touched = [];

      if (this.touchInBoundingRect || this.isTouchable) {
        if (this.isBeingTouched(glLocation)) {
          touched.push(this);
        }
      }

      for (var i = this.drawOrder.length - 1; i >= 0; i -= 1) {
        var element = this.elements[this.drawOrder[i]];

        if (element.isShown === true) {
          touched = touched.concat(element.getTouched(glLocation));
        } // If there is an element that is touched, then this collection should
        // also be touched.
        // if (touched.length > 0 && this.isTouchable) {
        //   touched = [this].concat(touched);
        // }

      }

      return touched;
    }
  }, {
    key: "stop",
    value: function stop() {
      var cancelled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var forceSetToEndOfPlan = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      _get(_getPrototypeOf(DiagramElementCollection.prototype), "stop", this).call(this, cancelled, forceSetToEndOfPlan);

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.stop(cancelled, forceSetToEndOfPlan); // element.cancel(forceSetToEndOfPlan);
      }
    }
  }, {
    key: "setFont",
    value: function setFont(fontSize) {
      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.setFont(fontSize);
      }
    }
  }, {
    key: "setColor",
    value: function setColor() {
      var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 0, 1];
      var setDefault = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var nonNullColor = color != null ? color : [0, 0, 0, 0];

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.setColor(nonNullColor, setDefault);
      }

      this.color = nonNullColor.slice();

      if (setDefault) {
        this.defaultColor = this.color.slice();
      } // this.color = [color[0], color[1], color[2], color[3]];

    }
  }, {
    key: "setDimColor",
    value: function setDimColor() {
      var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 0, 1];
      var nonNullColor = color != null ? color : [0, 0, 0, 0];

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.setDimColor(nonNullColor);
      }

      this.dimColor = nonNullColor.slice();
    }
  }, {
    key: "undim",
    value: function undim() {
      this.color = this.defaultColor.slice();

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.undim();
      }
    }
  }, {
    key: "dim",
    value: function dim(elementsToDim) {
      if (elementsToDim == null || Array.isArray(elementsToDim) && elementsToDim.length === 0) {
        // super.dim();
        this.color = this.dimColor.slice();

        for (var i = 0; i < this.drawOrder.length; i += 1) {
          var element = this.elements[this.drawOrder[i]];
          element.dim();
        }

        return;
      }

      this.exec('dim', elementsToDim);
    }
  }, {
    key: "highlight",
    value: function highlight() {
      var elementsToHighlight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (elementsToHighlight == null) {
        this.undim();
        return;
      }

      if (Array.isArray(elementsToHighlight) && elementsToHighlight.length === 0) {
        return;
      }

      this.dim();
      this.exec('undim', elementsToHighlight);
    }
  }, {
    key: "getDiagramBoundingRect",
    value: function getDiagramBoundingRect() {
      var _this13 = this;

      var elementsToBound = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (elementsToBound == null) {
        return _get(_getPrototypeOf(DiagramElementCollection.prototype), "getDiagramBoundingRect", this).call(this);
      }

      var points = [];
      elementsToBound.forEach(function (element) {
        var e;

        if (typeof element === 'string') {
          e = _this13.getElement(element);
        } else {
          e = element;
        }

        if (e == null) {
          return;
        }

        var bound = e.getDiagramBoundingRect();
        points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](bound.left, bound.bottom));
        points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](bound.right, bound.top));
      });
      return Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getBoundingRect"])(points);
    }
  }, {
    key: "setOpacity",
    value: function setOpacity(opacity) {
      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.setOpacity(opacity);
      } // this.color[3] = opacity;


      this.opacity = opacity;
    }
  }, {
    key: "getElementTransforms",
    value: function getElementTransforms() {
      var out = {};

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        out[element.name] = element.transform._dup();
      }

      return out;
    }
  }, {
    key: "setElementTransforms",
    value: function setElementTransforms(elementTransforms) {
      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];

        if (element.name in elementTransforms) {
          element.transform = elementTransforms[element.name];

          if (element.internalSetTransformCallback) {
            element.internalSetTransformCallback(element.transform);
          }
        }
      }
    }
  }, {
    key: "reorder",
    value: function reorder() {
      var _this14 = this;

      this.drawOrder.sort(function (a, b) {
        var elemA = _this14.elements[a];
        var elemB = _this14.elements[b];
        return elemB.drawPriority - elemA.drawPriority;
      }); // this.elements.sort((a, b) => {
      //   const elemA
      //   b.z - a.z});

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];

        if (element instanceof DiagramElementCollection) {
          element.reorder();
        }
      }
    }
  }, {
    key: "animateToTransforms",
    value: function animateToTransforms(elementTransforms) // translationPath: (Point, Point, number) => Point = linearPath,
    {
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var rotDirection = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var callback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      var easeFunction = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : _tools_math__WEBPACK_IMPORTED_MODULE_2__["easeinout"];
      var callbackMethod = callback;
      var timeToAnimate = 0;

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];

        if (element.name in elementTransforms) {
          if (element.isShown) {
            if (!elementTransforms[element.name].isEqualTo(element.transform)) {
              element.animations["new"]().delay(delay).transform({
                target: elementTransforms[element.name],
                duration: time,
                rotDirection: rotDirection,
                progression: easeFunction,
                onFinish: callbackMethod
              }).start(); // only want to send callback once

              callbackMethod = null;
              timeToAnimate = time + delay;
            }
          } else {
            element.transform = elementTransforms[element.name]._dup();

            if (element.internalSetTransformCallback) {
              element.internalSetTransformCallback(element.transform);
            }
          }
        }
      }

      if (timeToAnimate === 0 && callbackMethod != null) {
        callbackMethod(true);
      }

      return timeToAnimate;
    }
  }, {
    key: "getAllPrimitives",
    value: function getAllPrimitives() {
      var elements = [];

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];

        if (element instanceof DiagramElementCollection) {
          elements = [].concat(_toConsumableArray(elements), _toConsumableArray(element.getAllElements()));
        } else {
          elements.push(element);
        }
      }

      return elements;
    }
  }, {
    key: "getAllElements",
    value: function getAllElements() {
      var elements = [];

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        elements.push(element);
      }

      return elements;
    }
  }, {
    key: "getAllElementsWithScenario",
    value: function getAllElementsWithScenario(scenario) {
      var elements = _get(_getPrototypeOf(DiagramElementCollection.prototype), "getAllElementsWithScenario", this).call(this, scenario);

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];

        if (element.scenarios[scenario] != null) {
          elements.push(element);
        }

        if (element instanceof DiagramElementCollection) {
          elements = [].concat(_toConsumableArray(elements), _toConsumableArray(element.getAllElementsWithScenario(scenario)));
        }
      }

      return elements;
    } // // Get all ineractive elemnts, but only go as deep as a
    // // DiagramElementColleciton if it is touchable or movable
    // getAllCurrentlyInteractiveElements() {
    //   let elements = [];
    //   for (let i = 0; i < this.drawOrder.length; i += 1) {
    //     const element = this.elements[this.drawOrder[i]];
    //     // if (element.isShown) {
    //     if (element instanceof DiagramElementCollection) {
    //       if (!element.isTouchable
    //         && !element.isMovable
    //         && element.hasTouchableElements
    //         && (!element.isInteractive || element.isInteractive == null)
    //       ) {
    //         elements = [...elements, ...element.getAllCurrentlyInteractiveElements()];
    //       }
    //     }
    //     if (element.isInteractive !== false
    //       && (element.isTouchable || element.isMovable || element.isInteractive)) {
    //       elements.push(element);
    //     }
    //     // }
    //   }
    //   return elements;
    // }
    // Get all ineractive elemnts, but only go as deep as a
    // DiagramElementColleciton if it is touchable or movable

  }, {
    key: "getAllPossiblyInteractiveElements",
    value: function getAllPossiblyInteractiveElements() {
      var elements = [];

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]]; // if (element.isShown) {

        if (element instanceof DiagramElementCollection) {
          if (!element.isTouchable && !element.isMovable && element.hasTouchableElements && (!element.isInteractive || element.isInteractive == null)) {
            elements = [].concat(_toConsumableArray(elements), _toConsumableArray(element.getAllPossiblyInteractiveElements()));
          }
        }

        if (element.isInteractive !== undefined || element.isTouchable || element.isMovable) {
          elements.push(element);
        }
      }

      return elements;
    } // This method is here as a convenience method for content item selectors
    // eslint-disable-next-line class-methods-use-this

  }, {
    key: "goToStep",
    value: function goToStep(step) {
      var elem = document.getElementById('id__figureone_item_selector_0');
      var elems = [];

      if (elem != null) {
        if (elem.children.length > 0) {
          for (var i = 0; i < elem.children.length; i += 1) {
            elems.push(elem.children[i]);
          }
        }
      }

      elems.forEach(function (e, index) {
        if (index === step) {
          e.classList.add('figureone__item_selector_selected');
        } else {
          e.classList.remove('figureone__item_selector_selected');
        }
      });
    }
  }, {
    key: "setMovable",
    value: function setMovable() {
      var movable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      _get(_getPrototypeOf(DiagramElementCollection.prototype), "setMovable", this).call(this, movable);

      if (movable) {
        this.hasTouchableElements = true; // this.isMovable = true;
      }
    } // updateContext(context: DrawContext2D) {
    //   for (let i = 0; i < this.drawOrder.length; i += 1) {
    //     const element = this.elements[this.drawOrder[i]];
    //     element.updateContext(context);
    //   }
    // }

  }, {
    key: "setupWebGLBuffers",
    value: function setupWebGLBuffers(newWebgl) {
      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.setupWebGLBuffers(newWebgl);
      }
    }
  }, {
    key: "changeWebGLInstance",
    value: function changeWebGLInstance(newWebgl) {
      var oldInstance;

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        oldInstance = element.changeWebGLInstance(newWebgl);
      }

      return oldInstance;
    }
  }, {
    key: "getLoadingElements",
    value: function getLoadingElements() {
      var elems = [];

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];

        if (element instanceof DiagramElementPrimitive) {
          if (element.drawingObject.state === 'loading') {
            elems.push(element);
          }
        } else {
          elems = [].concat(_toConsumableArray(elems), _toConsumableArray(element.getLoadingElements()));
        }
      }

      return elems;
    }
  }, {
    key: "unrenderAll",
    value: function unrenderAll() {
      this.unrender();

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];

        if (element instanceof DiagramElementPrimitive) {
          element.unrender();
        } else {
          element.unrenderAll();
        }
      }
    }
  }, {
    key: "setScenarios",
    value: function setScenarios(scenarioName) {
      var onlyIfVisible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      _get(_getPrototypeOf(DiagramElementCollection.prototype), "setScenarios", this).call(this, scenarioName);

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];

        if (onlyIfVisible && element.isShown || onlyIfVisible === false) {
          element.setScenarios(scenarioName, onlyIfVisible);
        }
      }
    }
  }]);

  return DiagramElementCollection;
}(DiagramElement);



/***/ }),

/***/ "./src/js/diagram/Gesture.js":
/*!***********************************!*\
  !*** ./src/js/diagram/Gesture.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _Diagram__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Diagram */ "./src/js/diagram/Diagram.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

 // eslint-disable-next-line import/no-cycle



var Gesture =
/*#__PURE__*/
function () {
  function Gesture(diagram) {
    _classCallCheck(this, Gesture);

    this.diagram = diagram; // console.log(diagram.canvas.offsetWidth)
    // this.diagram.canvas.onmousedown = this.mouseDownHandler.bind(this);
    // this.diagram.canvas.onmouseup = this.mouseUpHandler.bind(this);
    // this.diagram.canvas.onmousemove = this.mouseMoveHandler.bind(this);

    this.addEvent('mousedown', this.mouseDownHandler, false);
    this.addEvent('mouseup', this.mouseUpHandler, false);
    this.addEvent('mousemove', this.mouseMoveHandler, false);
    this.addEvent('touchstart', this.touchStartHandler, false);
    this.addEvent('touchend', this.touchEndHandler, false);
    this.addEvent('touchmove', this.touchMoveHandler, false); // this.diagram.canvas.addEventListener(
    //   'touchstart',
    //   this.touchStartHandler.bind(this), false,
    // );
    // this.diagram.canvas.addEventListener(
    //   'touchend',
    //   this.touchEndHandler.bind(this), false,
    // );
    // this.diagram.canvas.addEventListener(
    //   'touchmove',
    //   this.touchMoveHandler.bind(this), false,
    // );

    this.enable = true; // Override these if you want to use your own touch handlers

    this.start = this.diagram.touchDownHandler.bind(this.diagram);
    this.end = this.diagram.touchUpHandler.bind(this.diagram);
    this.move = this.diagram.touchMoveHandler.bind(this.diagram);
  }

  _createClass(Gesture, [{
    key: "addEvent",
    value: function addEvent(event, method, flag) {
      this.diagram.gestureCanvas.addEventListener(event, method.bind(this), flag);
    }
  }, {
    key: "removeEvent",
    value: function removeEvent(event, method, flag) {
      this.diagram.gestureCanvas.removeEventListener(event, method.bind(this), flag);
    }
  }, {
    key: "startHandler",
    value: function startHandler(point) {
      if (this.enable) {
        this.mouseDown = true;
        this.previousPoint = point;
        return this.start(point);
      }

      return false;
    }
  }, {
    key: "endHandler",
    value: function endHandler() {
      this.mouseDown = false;
      this.end();
    }
  }, {
    key: "moveHandler",
    value: function moveHandler(event, point) {
      if (this.enable && this.mouseDown) {
        var disableEvent = this.move(this.previousPoint, point);

        if (disableEvent) {
          event.preventDefault();
        }

        this.previousPoint = point;
      } // event.preventDefault();

    }
  }, {
    key: "touchStartHandler",
    value: function touchStartHandler(event) {
      var touch = event.touches[0];
      var disableEvent = this.startHandler(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](touch.clientX, touch.clientY));

      if (disableEvent) {
        event.preventDefault();
      }
    }
  }, {
    key: "mouseDownHandler",
    value: function mouseDownHandler(event) {
      var disableEvent = this.startHandler(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](event.clientX, event.clientY));

      if (disableEvent) {
        event.preventDefault();
      }
    }
  }, {
    key: "touchMoveHandler",
    value: function touchMoveHandler(event) {
      var touch = event.touches[0];
      this.moveHandler(event, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](touch.clientX, touch.clientY));
    }
  }, {
    key: "mouseMoveHandler",
    value: function mouseMoveHandler(event) {
      this.moveHandler(event, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](event.clientX, event.clientY));
    }
  }, {
    key: "mouseUpHandler",
    value: function mouseUpHandler() {
      this.endHandler();
    }
  }, {
    key: "touchEndHandler",
    value: function touchEndHandler() {
      this.endHandler();
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.removeEvent('mousedown', this.mouseDownHandler, false);
      this.removeEvent('mouseup', this.mouseUpHandler, false);
      this.removeEvent('mousemove', this.mouseMoveHandler, false);
      this.removeEvent('touchstart', this.touchStartHandler, false);
      this.removeEvent('touchend', this.touchEndHandler, false);
      this.removeEvent('touchmove', this.touchMoveHandler, false);
    }
  }]);

  return Gesture;
}();

/* harmony default export */ __webpack_exports__["default"] = (Gesture);

/***/ }),

/***/ "./src/js/diagram/webgl/GlobalAnimation.js":
/*!*************************************************!*\
  !*** ./src/js/diagram/webgl/GlobalAnimation.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// Singleton class that contains projects global variables
var GlobalAnimation =
/*#__PURE__*/
function () {
  // Method for requesting the next animation frame
  // used to cancel animation frames
  function GlobalAnimation() {
    _classCallCheck(this, GlobalAnimation);

    // If the instance alread exists, then don't create a new instance.
    // If it doesn't, then setup some default values.
    if (!GlobalAnimation.instance) {
      this.requestNextAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
      GlobalAnimation.instance = this;
      this.drawQueue = [];
      this.nextDrawQueue = []; // this.drawScene = this.draw.bind(this);
    }

    return GlobalAnimation.instance;
  }

  _createClass(GlobalAnimation, [{
    key: "draw",
    value: function draw(now) {
      this.drawQueue = this.nextDrawQueue;
      this.nextDrawQueue = [];
      var nowSeconds = now * 0.001;

      for (var i = 0; i < this.drawQueue.length; i += 1) {
        this.drawQueue[i](nowSeconds);
      }

      this.drawQueue = [];
    }
  }, {
    key: "queueNextFrame",
    value: function queueNextFrame(func) {
      // if (!(func in this.nextDrawQueue)) {
      this.nextDrawQueue.push(func); // }
      // if (triggerFrameRequest) {
      //   this.animateNextFrame();
      // }

      if (this.nextDrawQueue.length === 1) {
        this.animateNextFrame();
      }
    } // Queue up an animation frame

  }, {
    key: "animateNextFrame",
    value: function animateNextFrame() {
      cancelAnimationFrame(this.animationId); // $FlowFixMe

      var nextFrame = this.requestNextAnimationFrame.call(window, this.draw.bind(this));
      this.animationId = nextFrame;
    }
  }]);

  return GlobalAnimation;
}(); // Do not automatically create and instance and return it otherwise can't
// mock elements in jest
// // const globalvars: Object = new GlobalVariables();
// // Object.freeze(globalvars);


/* harmony default export */ __webpack_exports__["default"] = (GlobalAnimation);

/***/ }),

/***/ "./src/js/diagram/webgl/shaders.js":
/*!*****************************************!*\
  !*** ./src/js/diagram/webgl/shaders.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var vertex = {
  simple: {
    source: 'attribute vec2 a_position;' + 'uniform mat3 u_matrix;' + 'uniform float u_z;' + 'void main() {' + 'gl_Position = vec4((u_matrix * vec3(a_position, 1)).xy, u_z, 1);' + '}',
    varNames: ['a_position', 'u_matrix', 'u_z']
  },
  withTexture: {
    source: 'attribute vec2 a_position;' + 'attribute vec2 a_texcoord;' + 'uniform mat3 u_matrix;' + 'uniform float u_z;' + 'varying vec2 v_texcoord;' + 'void main() {' + 'gl_Position = vec4((u_matrix * vec3(a_position, 1)).xy, u_z, 1);' + 'v_texcoord = a_texcoord;' + '}',
    varNames: ['a_position', 'a_texcoord', 'u_matrix', 'u_z']
  }
};
var fragment = {
  simple: {
    source: 'precision mediump float;' + 'uniform vec4 u_color;' + 'void main() {' + 'gl_FragColor = u_color;' + '}',
    varNames: ['u_color']
  },
  withTexture: {
    source: 'precision mediump float;' + 'uniform vec4 u_color;' + 'uniform int u_use_texture;' + 'uniform sampler2D u_texture;' + 'varying vec2 v_texcoord;' + 'void main() {' + 'if ( u_use_texture == 1) {' + 'gl_FragColor = texture2D(u_texture, v_texcoord);' + '} else {' + 'gl_FragColor = u_color;' + '}' + '}',
    varNames: ['u_color', 'u_use_texture', 'u_texture']
  },
  text: {
    source: 'precision mediump float;' + 'uniform vec4 u_color;' + 'uniform sampler2D u_texture;' + 'varying vec2 v_texcoord;' + 'void main() {' // + 'float a = texture2D(u_texture, v_texcoord).a;'
    // + 'if ( a < 0.2 ) {'
    //   + 'a = a / 1.2;'
    // + '}'
    // + 'gl_FragColor = vec4(u_color.rgb, min(a * 1.2, 1.0) * u_color.a);'
    // + '}'
    // + 'gl_FragColor = a * u_color;'
    + 'vec4 c = texture2D(u_texture, v_texcoord);' + 'gl_FragColor = vec4(c.a * u_color.rgb, c.a * u_color.a);' + '}',
    varNames: ['u_color', 'u_texture']
  }
};

var getShaders = function getShaders() {
  var vName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'simple';
  var fName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'simple';

  if (Object.hasOwnProperty.call(vertex, vName) && Object.hasOwnProperty.call(fragment, fName)) {
    return {
      vertexSource: vertex[vName].source,
      fragmentSource: fragment[fName].source,
      varNames: vertex[vName].varNames.concat(fragment[fName].varNames)
    };
  }

  return {
    vertexSource: '',
    fragmentSource: '',
    varNames: []
  };
};

/* harmony default export */ __webpack_exports__["default"] = (getShaders);

/***/ }),

/***/ "./src/js/diagram/webgl/webgl.js":
/*!***************************************!*\
  !*** ./src/js/diagram/webgl/webgl.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _shaders__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shaders */ "./src/js/diagram/webgl/shaders.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }


var glMock = {
  TRIANGLES: 1,
  TRIANGLE_STRIP: 2,
  TRIANGLE_FAN: 3,
  LINES: 4,
  LINK_STATUS: 1,
  VERTEX_SHADER: 1,
  COMPILE_STATUS: 1,
  FRAGMENT_SHADER: 1,
  SRC_ALPHA: 1,
  ONE_MINUS_SRC_ALPHA: 1,
  BLEND: 1,
  COLOR_BUFFER_BIT: 1,
  TEXTURE_2D: 1,
  RGBA: 1,
  UNSIGNED_BYTE: 1,
  TEXTURE_WRAP_S: 1,
  CLAMP_TO_EDGE: 1,
  TEXTURE_WRAP_T: 1,
  TEXTURE_MIN_FILTER: 1,
  LINEAR: 1,
  ARRAY_BUFFER: 1,
  STATIC_DRAW: 1,
  FLOAT: 1,
  UNPACK_PREMULTIPLY_ALPHA_WEBGL: 1,
  createBuffer: function createBuffer() {},
  bindBuffer: function bindBuffer() {},
  bufferData: function bufferData() {},
  enableVertexAttribArray: function enableVertexAttribArray() {},
  vertexAttribPointer: function vertexAttribPointer() {},
  disableVertexAttribArray: function disableVertexAttribArray() {},
  uniformMatrix3fv: function uniformMatrix3fv() {},
  uniform4f: function uniform4f() {},
  uniform1f: function uniform1f() {},
  uniform1i: function uniform1i() {},
  texParameteri: function texParameteri() {},
  drawArrays: function drawArrays() {},
  clearColor: function clearColor() {},
  clear: function clear() {},
  createTexture: function createTexture() {},
  activeTexture: function activeTexture() {},
  bindTexture: function bindTexture() {},
  pixelStorei: function pixelStorei() {},
  texImage2D: function texImage2D() {},
  blendFunc: function blendFunc() {},
  attachShader: function attachShader() {},
  linkProgram: function linkProgram() {},
  getProgramParameter: function getProgramParameter() {},
  createProgram: function createProgram() {},
  deleteProgram: function deleteProgram() {},
  createShader: function createShader() {},
  shaderSource: function shaderSource() {},
  compileShader: function compileShader() {},
  getShaderParameter: function getShaderParameter() {},
  getAttribLocation: function getAttribLocation() {},
  getUniformLocation: function getUniformLocation() {},
  enable: function enable() {},
  map: function map() {},
  getExtension: function getExtension() {
    return {
      loseContext: function loseContext() {}
    };
  },
  disable: function disable() {},
  deleteShader: function deleteShader() {},
  useProgram: function useProgram() {},
  viewport: function viewport() {},
  canvas: {
    toDataURL: function toDataURL() {
      return '';
    },
    width: 100,
    clientHeight: 100,
    height: 100,
    style: {
      top: 0,
      visibility: 'visible'
    }
  }
};

function createProgram(gl, vertexShader, fragmentShader) {
  var program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  var success = gl.getProgramParameter(program, gl.LINK_STATUS);

  if (success) {
    return program;
  }

  gl.deleteProgram(program);
  return null;
}

function createShader(gl, type, source) {
  var shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);

  if (success) {
    return shader;
  }

  gl.deleteShader(shader);
  return null;
}

function createProgramFromScripts(gl, vertexShaderSource, fragmentShaderSource) {
  // Get the strings for our GLSL shaders
  // const vertexShaderSource = document.getElementById(vertexScript).text;
  // const fragmentShaderSource = document.getElementById(fragScript).text;
  // create GLSL shaders, upload the GLSL source, compile the shaders
  var vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
  var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource); // Link the two shaders into a program

  if (vertexShader && fragmentShader) {
    return createProgram(gl, vertexShader, fragmentShader);
  }

  return null;
}

function getGLLocations(gl, program, locationsList) {
  var i;
  var newLocations = {};
  var loc;

  for (i = 0; i < locationsList.length; i += 1) {
    loc = locationsList[i];

    if (loc[0] === 'a') {
      newLocations[loc] = gl.getAttribLocation(program, loc);
    }

    if (loc[0] === 'u') {
      newLocations[loc] = gl.getUniformLocation(program, loc);
    }
  }

  return newLocations;
} // function resizeCanvasToDisplaySize(canvas) {
//   // const mul = multiplier || 1;
//   const mul = window.devicePixelRatio || 1;
//   const width = canvas.clientWidth * mul || 0;
//   const height = canvas.clientHeight * mul || 0;
//   if (canvas.width !== width || canvas.height !== height) {
//     canvas.width = width;     // eslint-disable-line no-param-reassign
//     canvas.height = height;   // eslint-disable-line no-param-reassign
//     return true;
//   }
//   return false;
// }

/* eslint-disable */


function autoResize(event) {// let contRect = document.getElementById('container').getBoundingClientRect();
  // let diagRect = document.getElementById('diagram').getBoundingClientRect();
  // let textRect = document.getElementById('learning_text_container').getBoundingClientRect();
  // let canvRect = this.gl.canvas.getBoundingClientRect();
  // // console.log(contRect)
  // console.log(this.gl.canvas.getBoundingClientRect());
  // // this.gl.canvas.height = 500;
  // // this.gl.canvas.width = 500;
  // // this.gl.canvas.width=500;
  // // this.gl.viewport(diagRect.left, canvRect.height+canvRect.top, textRect.width, textRect.height); 
  // // this.gl.viewport(0,0,100,100);
  // // console.log(document.getElementById('Diagram').left);
}

var WebGLInstance =
/*#__PURE__*/
function () {
  _createClass(WebGLInstance, [{
    key: "addTexture",
    // locations: Object;
    value: function addTexture(id, glTexture, type) {
      if (this.textures[id] && this.textures[id].glTexture != null) {
        return this.textures[id].index;
      }

      var index = 0;

      if (this.textures[id]) {
        index = this.textures[id].index;
      } else {
        index = Object.keys(this.textures).length;
      }

      this.textures[id] = {
        glTexture: glTexture,
        index: index,
        type: type,
        state: 'loaded',
        onLoad: []
      };
      return index;
    }
  }, {
    key: "onLoad",
    value: function onLoad(textureId) {
      this.textures[textureId].onLoad.forEach(function (f) {
        return f();
      });
      this.textures[textureId].onLoad = [];
    }
  }, {
    key: "getProgram",
    value: function getProgram(vertexShader, fragmentShader) {
      for (var i = 0; i < this.programs.length; i += 1) {
        var program = this.programs[i];

        if (program.vertexShader === vertexShader && program.fragmentShader === fragmentShader) {
          return i;
        }
      }

      var shaders = Object(_shaders__WEBPACK_IMPORTED_MODULE_0__["default"])(vertexShader, fragmentShader);
      var newProgram = createProgramFromScripts(this.gl, shaders.vertexSource, shaders.fragmentSource);
      var programDetails = {
        vertexShader: vertexShader,
        fragmentShader: fragmentShader,
        program: newProgram,
        locations: getGLLocations(this.gl, newProgram, shaders.varNames)
      };
      this.programs.push(programDetails);
      return this.programs.length - 1;
    }
  }, {
    key: "useProgram",
    value: function useProgram(programIndex) {
      var program = this.programs[programIndex];

      if (this.lastUsedProgram !== program) {
        this.gl.useProgram(program.program);
        this.lastUsedProgram = program.program;
      }

      return program.locations;
    }
  }]);

  function WebGLInstance(canvas, // vertexSource: string,
  // fragmentSource: string,
  // shaderLocations: Array<string>,
  backgroundColor) {
    _classCallCheck(this, WebGLInstance);

    var gl = canvas.getContext('webgl', {
      antialias: true
    });

    if (gl == null) {
      // $FlowFixMe
      gl = glMock;
    }

    this.programs = [];
    this.lastUsedProgram = null;
    this.textures = {};

    if (gl != null) {
      // $FlowFixMe
      this.gl = gl; // this.program = createProgramFromScripts(
      //   this.gl,
      //   vertexSource,
      //   fragmentSource,
      // );
      // this.locations = getGLLocations(this.gl, this.program, shaderLocations);
      // Prep canvas
      // resizeCanvasToDisplaySize(this.gl.canvas);

      this.resize(); // Tell WebGL how to convert from clip space to pixels
      // this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);
      // gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
      // this.gl.viewport(0, 500, 500, 500);   // Tell WebGL how to convert from clip space to pixels
      // Clear the canvas
      // const bc = backgroundColor;
      // this.gl.clearColor(bc[0], bc[1], bc[2], bc[3]);

      this.gl.clearColor(0, 0, 0, 0);
      this.gl.clear(this.gl.COLOR_BUFFER_BIT);
      this.gl.disable(this.gl.DEPTH_TEST);
      this.gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      this.gl.enable(gl.BLEND); // this.gl.useProgram(this.program);
      // window.addEventListener('resize', autoResize.bind(this, event));
    }
  }

  _createClass(WebGLInstance, [{
    key: "resize",
    value: function resize() {
      var realToCSSPixels = window.devicePixelRatio; // console.log("asdf");
      // Lookup the size the browser is displaying the canvas in CSS pixels
      // and compute a size needed to make our drawingbuffer match it in
      // device pixels.

      var displayWidth = Math.floor(this.gl.canvas.clientWidth * realToCSSPixels);
      var displayHeight = Math.floor(this.gl.canvas.clientHeight * realToCSSPixels); // console.log('in webgl', displayWidth)
      // Check if the canvas is not the same size.

      if (this.gl.canvas.width !== displayWidth || this.gl.canvas.height !== displayHeight) {
        // Make the canvas the same size
        this.gl.canvas.width = displayWidth;
        this.gl.canvas.height = displayHeight;
      }

      this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);
    } // resize() {
    //   var width = this.gl.canvas.clientWidth;
    //   var height = this.gl.canvas.clientHeight;
    //   if (this.gl.canvas.width != width ||
    //       this.gl.canvas.height != height) {
    //      this.gl.canvas.width = width;
    //      this.gl.canvas.height = height;
    //      return true;
    //   }
    //   return false;
    // }
    // var needToRender = true;  // draw at least once
    // function checkRender() {
    //    if (resize() || needToRender) {
    //      needToRender = false;
    //      drawStuff();
    //    }
    //    requestAnimationFrame(checkRender);
    // }
    // checkRender();

  }]);

  return WebGLInstance;
}();

/* harmony default export */ __webpack_exports__["default"] = (WebGLInstance);

/***/ }),

/***/ "./src/js/tools/color.js":
/*!*******************************!*\
  !*** ./src/js/tools/color.js ***!
  \*******************************/
/*! exports provided: RGBToArray, HexToArray, cssColorToArray, colorArrayToRGB, colorArrayToRGBA, getCSSColors */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBToArray", function() { return RGBToArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HexToArray", function() { return HexToArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cssColorToArray", function() { return cssColorToArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "colorArrayToRGB", function() { return colorArrayToRGB; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "colorArrayToRGBA", function() { return colorArrayToRGBA; });
/* harmony import */ var _colorNames__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./colorNames */ "./src/js/tools/colorNames.js");
/* harmony import */ var _getCssColors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getCssColors */ "./src/js/tools/getCssColors.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getCSSColors", function() { return _getCssColors__WEBPACK_IMPORTED_MODULE_1__["default"]; });

 // official css color names
// eslint-disable-next-line import/no-cycle

 // Function that converts any rgb or rgba string to an array of rgba numbers
// between 0 and 1

function RGBToArray(color) {
  // Reduce the rgb(a) string to just numbers
  var colString = color;
  colString = colString.replace(/.*\(/i, '');
  colString = colString.replace(/\)/i, '');
  var strArray = colString.split(','); // Go through each rgb(a) value and normalize to 1.0

  var value = strArray.map(function (x, index) {
    if (index < 3) {
      return parseInt(x, 10) / 255.0;
    }

    return parseFloat(x);
  }); // If an alpha value isn't included, then include it with default value 1.0

  if (value.length === 3) {
    value.push(1);
  }

  return value;
} // Function that converts any hex color string to an array of rgba numbers
// between 0 and 1 (where alpha is always 1)


function HexToArray(color) {
  var colHex = color.slice(1);

  if (colHex.length < 6) {
    colHex = "".concat(colHex[0]).concat(colHex[0]).concat(colHex[1]).concat(colHex[1]).concat(colHex[2]).concat(colHex[2]);
  }

  var col = [parseInt(colHex.slice(0, 2), 16) / 255.0, parseInt(colHex.slice(2, 4), 16) / 255.0, parseInt(colHex.slice(4, 6), 16) / 255.0, 1];
  return col;
}

function cssColorToArray(cssColorString) {
  var oNames = Object(_colorNames__WEBPACK_IMPORTED_MODULE_0__["default"])(); // Official css color names

  var color = cssColorString.slice(0); // If the color is an official name, then replace it with the hex rgb
  // equivalent

  if (color in oNames) {
    color = oNames[color];
  } // colorValue is the rgba array of colors between 0 and 1


  var colorValue = []; // If color string starts with 'rgb' (and therefore also 'rgba')

  if (color.toLowerCase().startsWith('rgb')) {
    colorValue = RGBToArray(color); // If color string starts with '#' it is hex
  } else if (color.startsWith('#')) {
    colorValue = HexToArray(color);
  } // If the color value array is defined, then add it to the final
  // dictionary


  if (colorValue.length > 0) {
    return colorValue;
  }

  return null;
}

function colorArrayToRGBA(color) {
  return "rgba(".concat(Math.floor(color[0] * 255), ",").concat(Math.floor(color[1] * 255), ",").concat(Math.floor(color[2] * 255), ",").concat(color[3], ")");
}

function colorArrayToRGB(color) {
  return "rgb(".concat(Math.floor(color[0] * 255), ",").concat(Math.floor(color[1] * 255), ",").concat(Math.floor(color[2] * 255), ")");
}



/***/ }),

/***/ "./src/js/tools/colorNames.js":
/*!************************************!*\
  !*** ./src/js/tools/colorNames.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// @ flow
function colorNames() {
  return {
    aliceblue: '#f0f8ff',
    antiquewhite: '#faebd7',
    aqua: '#00ffff',
    aquamarine: '#7fffd4',
    azure: '#f0ffff',
    beige: '#f5f5dc',
    bisque: '#ffe4c4',
    black: '#000000',
    blanchedalmond: '#ffebcd',
    blue: '#0000ff',
    blueviolet: '#8a2be2',
    brown: '#a52a2a',
    burlywood: '#deb887',
    cadetblue: '#5f9ea0',
    chartreuse: '#7fff00',
    chocolate: '#d2691e',
    coral: '#ff7f50',
    cornflowerblue: '#6495ed',
    cornsilk: '#fff8dc',
    crimson: '#dc143c',
    cyan: '#00ffff',
    darkblue: '#00008b',
    darkcyan: '#008b8b',
    darkgoldenrod: '#b8860b',
    darkgray: '#a9a9a9',
    darkgrey: '#a9a9a9',
    darkgreen: '#006400',
    darkkhaki: '#bdb76b',
    darkmagenta: '#8b008b',
    darkolivegreen: '#556b2f',
    darkorange: '#ff8c00',
    darkorchid: '#9932cc',
    darkred: '#8b0000',
    darksalmon: '#e9967a',
    darkseagreen: '#8fbc8f',
    darkslateblue: '#483d8b',
    darkslategray: '#2f4f4f',
    darkslategrey: '#2f4f4f',
    darkturquoise: '#00ced1',
    darkviolet: '#9400d3',
    deeppink: '#ff1493',
    deepskyblue: '#00bfff',
    dimgray: '#696969',
    dimgrey: '#696969',
    dodgerblue: '#1e90ff',
    firebrick: '#b22222',
    floralwhite: '#fffaf0',
    forestgreen: '#228b22',
    fuchsia: '#ff00ff',
    gainsboro: '#dcdcdc',
    ghostwhite: '#f8f8ff',
    gold: '#ffd700',
    goldenrod: '#daa520',
    gray: '#808080',
    grey: '#808080',
    green: '#008000',
    greenyellow: '#adff2f',
    honeydew: '#f0fff0',
    hotpink: '#ff69b4',
    indianred: '#cd5c5c',
    indigo: '#4b0082',
    ivory: '#fffff0',
    khaki: '#f0e68c',
    lavender: '#e6e6fa',
    lavenderblush: '#fff0f5',
    lawngreen: '#7cfc00',
    lemonchiffon: '#fffacd',
    lightblue: '#add8e6',
    lightcoral: '#f08080',
    lightcyan: '#e0ffff',
    lightgoldenrodyellow: '#fafad2',
    lightgray: '#d3d3d3',
    lightgrey: '#d3d3d3',
    lightgreen: '#90ee90',
    lightpink: '#ffb6c1',
    lightsalmon: '#ffa07a',
    lightseagreen: '#20b2aa',
    lightskyblue: '#87cefa',
    lightslategray: '#778899',
    lightslategrey: '#778899',
    lightsteelblue: '#b0c4de',
    lightyellow: '#ffffe0',
    lime: '#00ff00',
    limegreen: '#32cd32',
    linen: '#faf0e6',
    magenta: '#ff00ff',
    maroon: '#800000',
    mediumaquamarine: '#66cdaa',
    mediumblue: '#0000cd',
    mediumorchid: '#ba55d3',
    mediumpurple: '#9370db',
    mediumseagreen: '#3cb371',
    mediumslateblue: '#7b68ee',
    mediumspringgreen: '#00fa9a',
    mediumturquoise: '#48d1cc',
    mediumvioletred: '#c71585',
    midnightblue: '#191970',
    mintcream: '#f5fffa',
    mistyrose: '#ffe4e1',
    moccasin: '#ffe4b5',
    navajowhite: '#ffdead',
    navy: '#000080',
    oldlace: '#fdf5e6',
    olive: '#808000',
    olivedrab: '#6b8e23',
    orange: '#ffa500',
    orangered: '#ff4500',
    orchid: '#da70d6',
    palegoldenrod: '#eee8aa',
    palegreen: '#98fb98',
    paleturquoise: '#afeeee',
    palevioletred: '#db7093',
    papayawhip: '#ffefd5',
    peachpuff: '#ffdab9',
    peru: '#cd853f',
    pink: '#ffc0cb',
    plum: '#dda0dd',
    powderblue: '#b0e0e6',
    purple: '#800080',
    rebeccapurple: '#663399',
    red: '#ff0000',
    rosybrown: '#bc8f8f',
    royalblue: '#4169e1',
    saddlebrown: '#8b4513',
    salmon: '#fa8072',
    sandybrown: '#f4a460',
    seagreen: '#2e8b57',
    seashell: '#fff5ee',
    sienna: '#a0522d',
    silver: '#c0c0c0',
    skyblue: '#87ceeb',
    slateblue: '#6a5acd',
    slategray: '#708090',
    slategrey: '#708090',
    snow: '#fffafa',
    springgreen: '#00ff7f',
    steelblue: '#4682b4',
    tan: '#d2b48c',
    teal: '#008080',
    thistle: '#d8bfd8',
    tomato: '#ff6347',
    turquoise: '#40e0d0',
    violet: '#ee82ee',
    wheat: '#f5deb3',
    white: '#ffffff',
    whitesmoke: '#f5f5f5',
    yellow: '#ffff00',
    yellowgreen: '#9acd32'
  };
} // function a(input) {
//   console.log(input);
// }


/* harmony default export */ __webpack_exports__["default"] = (colorNames);

/***/ }),

/***/ "./src/js/tools/g2.js":
/*!****************************!*\
  !*** ./src/js/tools/g2.js ***!
  \****************************/
/*! exports provided: point, Point, line, Line, distance, minAngleDiff, deg, normAngle, Transform, TransformLimit, Rect, Translation, Scale, Rotation, spaceToSpaceTransform, getBoundingRect, linearPath, curvedPath, quadraticBezier, translationPath, polarToRect, rectToPolar, getDeltaAngle, normAngleTo90, threePointAngle, threePointAngleMin, randomPoint, getMaxTimeFromVelocity, getMoveTime, parsePoint, clipAngle, spaceToSpaceScale, getPoint, getPoints, quadBezierPoints, getRect */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "point", function() { return point; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Point", function() { return Point; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "line", function() { return line; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Line", function() { return Line; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "minAngleDiff", function() { return minAngleDiff; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deg", function() { return deg; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normAngle", function() { return normAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Transform", function() { return Transform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TransformLimit", function() { return TransformLimit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Rect", function() { return Rect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Translation", function() { return Translation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Scale", function() { return Scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Rotation", function() { return Rotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "spaceToSpaceTransform", function() { return spaceToSpaceTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBoundingRect", function() { return getBoundingRect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearPath", function() { return linearPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "curvedPath", function() { return curvedPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quadraticBezier", function() { return _quadraticBezier; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translationPath", function() { return translationPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polarToRect", function() { return polarToRect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rectToPolar", function() { return rectToPolar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDeltaAngle", function() { return getDeltaAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normAngleTo90", function() { return normAngleTo90; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "threePointAngle", function() { return threePointAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "threePointAngleMin", function() { return threePointAngleMin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randomPoint", function() { return randomPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMaxTimeFromVelocity", function() { return getMaxTimeFromVelocity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMoveTime", function() { return getMoveTime; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parsePoint", function() { return parsePoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clipAngle", function() { return clipAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "spaceToSpaceScale", function() { return spaceToSpaceScale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPoint", function() { return getPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPoints", function() { return getPoints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quadBezierPoints", function() { return quadBezierPoints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRect", function() { return getRect; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ "./src/js/tools/math.js");
/* harmony import */ var _m2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./m2 */ "./src/js/tools/m2.js");
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// 2D geometry functions including:
//  - Point
//  - Line
//  - minAngleDiff
//  - normAngle
 // import { Console } from '../../tools/tools';

 // function nullDefaultNum(input: number | null, defaultValue: number): number {
//   if (input === null) {
//     return defaultValue;
//   }
//   return input;
// }
// export type PointType = {
//   x: number;
//   y: number;
//   _dup(): PointType;
//   // sub(): PointType;
//   // add(): PointType;
//   // distance(): number;
//   // round(): PointType;
//   // rotate(): PointType;
//   // isEqualTo: boolean;
//   // isNotEqualTo: boolean;
//   // isOnLine: boolean;
//   // isOnUnboundLine: boolean;
//   // console: void;
//   // isInPolygon: boolean;
//   // isOnPolygon: boolean;
// };

function _quadraticBezier(P0, P1, P2, t) {
  return (1 - t) * ((1 - t) * P0 + t * P1) + t * ((1 - t) * P1 + t * P2);
}

function clipAngle(angleToClip, clipTo) {
  var angle = angleToClip;

  if (clipTo === '0to360') {
    if (angle < 0) {
      angle += Math.PI * 2;
    }

    if (angle >= Math.PI * 2) {
      angle -= Math.PI * 2;
    }
  }

  if (clipTo === '-180to180') {
    if (angle < -Math.PI) {
      angle += Math.PI * 2;
    }

    if (angle >= Math.PI) {
      angle -= Math.PI * 2;
    }
  }

  return angle;
}
/**
 * Rect
 * @class
 */


var Rect =
/*#__PURE__*/
function () {
  /**
   * Constructor
   * @constructor
   * @param {number} left - left location
   * @param {number} bottom - bottom location
   * @param {number} width - rectangle width
   * @param {number} bottom - rectangle height
   */
  function Rect(left, bottom, width, height) {
    _classCallCheck(this, Rect);

    this.left = left;
    this.width = width;
    this.height = height;
    this.bottom = bottom;
    this.top = bottom + height;
    this.right = left + width;
  }

  _createClass(Rect, [{
    key: "_dup",
    value: function _dup() {
      return new Rect(this.left, this.bottom, this.width, this.height);
    }
  }]);

  return Rect;
}();
/* eslint-disable comma-dangle */

/**
 * Point class
 *
 */


var Point =
/*#__PURE__*/
function () {
  _createClass(Point, null, [{
    key: "zero",

    /**
     * x value of point
    */

    /** y value of point */

    /**
     * Return a point at (0, 0)
     */
    value: function zero() {
      return new Point(0, 0);
    }
    /**
     * Return a point at (1, 1)
     */

  }, {
    key: "Unity",
    value: function Unity() {
      return new Point(1, 1);
    }
    /**
     * Constructor
     * @constructor
     * @param x x coordinate of point
     * @param y y coordinate of point
     */

  }]);

  function Point(x, y) {
    _classCallCheck(this, Point);

    this.x = x;
    this.y = y;
    this._type = 'point';
  }
  /**
   * Return a duplicate of the {@link Point} object
   */


  _createClass(Point, [{
    key: "_dup",
    value: function _dup() {
      return new Point(this.x, this.y);
    }
    /**
     * Scale x and y values of point by scalar
     * @example
     * p = new Point(1, 1);
     * s = p.scale(3);
     * // s = Point{x: 3, y: 3};
     */

  }, {
    key: "scale",
    value: function scale(scalar) {
      return new Point(this.x * scalar, this.y * scalar);
    }
    /**
     * Subtract (x, y) values or a {@link Point} and return the difference as a new {@link Point}
     * @example
     * p = new Point(3, 3);
     * d = p.sub(1, 1)
     * // d = Point{x: 2, y: 2}
     *
     * p = new Point(3, 3);
     * q = new Point(1, 1);
     * d = p.sub(q)
     * // d = Point{x: 2, y: 2}
     */

  }, {
    key: "sub",
    value: function sub(pointOrX) {
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      if (pointOrX instanceof Point) {
        return new Point(this.x - pointOrX.x, this.y - pointOrX.y);
      }

      return new Point(this.x - pointOrX, this.y - y);
    }
    /**
     * Add (x, y) values or a {@link Point} and return the sum as a new {@link Point}
     * @example
     * p = new Point(3, 3);
     * d = p.add(1, 1)
     * // d = Point{x: 4, y: 4}
     *
     * p = new Point(3, 3);
     * q = new Point(1, 1);
     * d = p.add(q)
     * // d = Point{x: 4, y: 4}
     */

  }, {
    key: "add",
    value: function add(pointOrX) {
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      if (pointOrX instanceof Point) {
        return new Point(this.x + pointOrX.x, this.y + pointOrX.y);
      }

      return new Point(this.x + pointOrX, this.y + y);
    }
    /**
     * Return the distance between the point and the origin
     * @example
     * p = new Point(1, 1);
     * d = p.distance();
     * // d = 1.4142135623730951
     */

  }, {
    key: "distance",
    value: function distance() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    /**
     * Return a new point with (x, y) values rounded to some precision
     * @example
     * p = new Point(1.234, 1.234);
     * q = p.round(2);
     * // q = Point{x: 1.23, y: 1.23}
     */

  }, {
    key: "round",
    value: function round() {
      var precision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;
      return new Point(Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.x, precision), Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.y, precision));
    }
    /**
     * Return a new point that is clipped to min and max values from the origin.
     *
     * Use a point as a parameter to define different (x, y) min/max values,
     * a number to define the same (x, y) min/max values, or null to have no
     * min/max values.
     * @example
     * p = new Point(2, 2);
     * q = p.clip(1, 1);
     * // q = Point{x: 1, y: 1}
     *
     * p = new Point(2, 2);
     * q = p.clip(1, null);
     * // q = Point{x: 1, y: 2}
     *
     * p = new Point(-2, -2);
     * minClip = new Point(-1, -1.5);
     * q = p.clip(minClip, null);
     * // q = Point{x: -1, y: -1.5}
     */

  }, {
    key: "clip",
    value: function clip(min, max) {
      var minX;
      var minY;
      var maxX;
      var maxY;

      if (min instanceof Point) {
        minX = min.x;
        minY = min.y;
      } else {
        minX = min;
        minY = min;
      }

      if (max instanceof Point) {
        maxX = max.x;
        maxY = max.y;
      } else {
        maxX = max;
        maxY = max;
      }

      var x = Object(_math__WEBPACK_IMPORTED_MODULE_0__["clipValue"])(this.x, minX, maxX);
      var y = Object(_math__WEBPACK_IMPORTED_MODULE_0__["clipValue"])(this.y, minY, maxY);
      return new Point(x, y);
    }
    /**
     * Transform the point with a 3x3 matrix (2 dimensional transform)
     * @example
     * // Transform a point with a (2, 2) translation then 90 rotation
     * p = new Point(1, 1);
     * m = new Transform().translate(2, 2).rotate(Math.PI / 2).matrix();
     * // m = [0, -1, -2, 1, 0, 2, 0, 0, 1]
     * q = p.transformBy(m)
     * // q = Point{x: -3, y: 3}
     */

  }, {
    key: "transformBy",
    value: function transformBy(matrix) {
      var transformedPoint = _m2__WEBPACK_IMPORTED_MODULE_1__["transform"](matrix, this.x, this.y);
      return new Point(transformedPoint[0], transformedPoint[1]);
    }
  }, {
    key: "quadraticBezier",
    value: function quadraticBezier(p1, p2, t) {
      var bx = _quadraticBezier(this.x, p1.x, p2.x, t);

      var by = _quadraticBezier(this.y, p1.y, p2.y, t);

      return new Point(bx, by);
    }
    /**
     * Rotate a point some angle around a center point
     * @param angle - in radians
     * @example
     * // Rotate a point around the origin
     * p = new Point(1, 0);
     * q = p.rotate(Math.PI)
     * // q = Point{x: -1, y: 0}
     *
     * // Rotate a point around (1, 1)
     * p = new Point(2, 1);
     * q = p.rotate(Math.PI, new Point(1, 1))
     * // q = Point{x: 0, y: 1}
     */

  }, {
    key: "rotate",
    value: function rotate(angle) {
      var center = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Point(0, 0);
      var c = Math.cos(angle);
      var s = Math.sin(angle);
      var matrix = [c, -s, s, c]; // eslint-disable-line indent

      var centerPoint = center;
      var pt = this.sub(centerPoint);
      return new Point(matrix[0] * pt.x + matrix[1] * pt.y + centerPoint.x, matrix[2] * pt.x + matrix[3] * pt.y + centerPoint.y);
    }
    /* eslint-enable comma-dangle */

    /**
     * Compare two points for equality to some precision
     * @example
     * p = new Point(1.123, 1.123);
     * q = new Point(1.124, 1.124);
     * p.isEqualTo(q)
     * // false
     *
     * p.isEqualTo(q, 2)
     * // true
     */

  }, {
    key: "isEqualTo",
    value: function isEqualTo(p) {
      var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
      var pr = this;
      var qr = p;

      if (typeof precision === 'number') {
        pr = this.round(precision);
        qr = qr.round(precision);
      }

      if (pr.x === qr.x && pr.y === qr.y) {
        return true;
      }

      return false;
    }
    /**
     * Compare two points for unequality to some precision
     * @example
     * p = new Point(1.123, 1.123);
     * q = new Point(1.124, 1.124);
     * p.isNotEqualTo(q)
     * // true
     *
     * p.isNotEqualTo(q, 2)
     * // false
     */

  }, {
    key: "isNotEqualTo",
    value: function isNotEqualTo(p, precision) {
      return !this.isEqualTo(p, precision);
    }
    /* eslint-disable no-use-before-define */

  }, {
    key: "isOnLine",
    value: function isOnLine(l, precision) {
      return l.hasPointOn(this, precision);
    }
  }, {
    key: "getShaddowOnLine",
    value: function getShaddowOnLine(l) {
      var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
      var shaddow = new Line(this, 1, l.angle() + Math.PI / 2);

      var _shaddow$intersectsWi = shaddow.intersectsWith(l),
          intersect = _shaddow$intersectsWi.intersect; // console.log(intersect, inLine, onLine, )


      if (intersect != null && intersect.isOnLine(l, precision)) {
        return intersect;
      }

      return null;
    }
  }, {
    key: "shaddowIsOnLine",
    value: function shaddowIsOnLine(l) {
      var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
      var intersect = this.getShaddowOnLine(l, precision);

      if (intersect != null) {
        return true;
      }

      return false;
    }
  }, {
    key: "isOnUnboundLine",
    value: function isOnUnboundLine(l, precision) {
      return l.hasPointAlong(this, precision);
    }
    /* eslint-enable no-use-before-define */
    // console(text?: string) {
    //   Console(`${text || ''} + ${this.x}, ${this.y}`);
    // }

  }, {
    key: "isInPolygon",
    value: function isInPolygon(polygonVertices) {
      var windingNumber = 0;
      var n = polygonVertices.length - 1;
      var v = polygonVertices.slice();
      var p = this;
      var popLastPoint = false; // polygonVertices needs to have the last vertex the same as the first vertex

      if (v[0].isNotEqualTo(v[n])) {
        v.push(v[0]);
        popLastPoint = true;
        n += 1;
      }

      for (var i = 0; i < n; i += 1) {
        if (v[i].y <= p.y) {
          if (v[i + 1].y > p.y) {
            // an upward crossing
            if (Point.isLeft(v[i], v[i + 1], p) > 0) {
              // P left of  edge
              windingNumber += 1; // have  a valid up intersect
            }
          }
        } else if (v[i + 1].y <= p.y) {
          // start y > P.y (no test needed)
          // a downward crossing
          if (Point.isLeft(v[i], v[i + 1], p) < 0) {
            // P right of  edge
            windingNumber -= 1; // have  a valid down intersect
          }
        }
      }

      if (popLastPoint) {
        v.pop();
      }

      if (windingNumber === 0) {
        return false;
      }

      return true;
    }
  }, {
    key: "isOnPolygon",
    value: function isOnPolygon(polygonVertices) {
      var popLastPoint = false;
      var p = this;
      var n = polygonVertices.length - 1; // Number of sides

      var v = polygonVertices.slice(); // polygonVertices needs to have the last vertex the same as the first vertex

      if (v[0].isNotEqualTo(v[n])) {
        v.push(v[0]);
        popLastPoint = true;
        n += 1;
      }

      for (var i = 0; i < n; i += 1) {
        // if(p.isEqualTo(v[i])) {
        //   return true;
        // }

        /* eslint-disable-next-line  no-use-before-define */
        var l = line(v[i], v[i + 1]);

        if (p.isOnLine(l)) {
          if (popLastPoint) {
            v.pop();
          }

          return true;
        }
      }

      if (p.isInPolygon(polygonVertices)) {
        if (popLastPoint) {
          v.pop();
        }

        return true;
      }

      if (popLastPoint) {
        v.pop();
      }

      return false;
    }
  }, {
    key: "toPolar",
    value: function toPolar() {
      return {
        mag: Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2)),
        angle: Math.atan2(this.y, this.x)
      };
    }
  }, {
    key: "toDelta",
    value: function toDelta(delta, percent) {
      var translationStyle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'linear';
      var translationOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {
        rot: 1,
        magnitude: 0.5,
        offset: 0.5,
        controlPoint: null,
        direction: ''
      };
      // eslint-disable-next-line no-use-before-define
      var pathPoint = translationPath(translationStyle, this._dup(), delta, percent, translationOptions);
      return pathPoint;
    }
  }], [{
    key: "isLeft",
    value: function isLeft(p0, p1, p2) {
      return (p1.x - p0.x) * (p2.y - p0.y) - (p2.x - p0.x) * (p1.y - p0.y);
    }
  }]);

  return Point;
}();

// point can be defined as:
//    - Point instance
//    - [1, 1]
//    - { x: 1, y: 1 }
function parsePoint(p, onFail) {
  if (p instanceof Point) {
    return p;
  }

  var onFailToUse = onFail;

  if (onFailToUse == null) {
    onFailToUse = null;
  }

  if (Array.isArray(p)) {
    if (p.length === 2) {
      return new Point(p[0], p[1]);
    }

    return onFailToUse;
  }

  if (typeof p === 'number') {
    return new Point(p, p);
  }

  if (_typeof(p) === 'object') {
    var keys = Object.keys(p);

    if (keys.indexOf('x') > -1 && keys.indexOf('y') > -1) {
      return new Point(p.x, p.y);
    }
  }

  return onFailToUse;
}

function getPoint(p) {
  var parsedPoint = parsePoint(p);

  if (parsedPoint == null) {
    parsedPoint = new Point(0, 0);
  }

  return parsedPoint;
}

function parseRect(r, onFail) {
  if (r instanceof Rect) {
    return r;
  }

  var onFailToUse = onFail;

  if (onFailToUse == null) {
    onFailToUse = null;
  }

  if (Array.isArray(r) && r.length === 4) {
    return new Rect(r[0], r[1], r[2], r[3]);
  }

  return onFailToUse;
}

function getRect(r) {
  var parsedRect = parseRect(r);

  if (parsedRect == null) {
    parsedRect = new Rect(0, 0, 1, 1);
  }

  return parsedRect;
}

function getPoints(points) {
  if (Array.isArray(points) && points.length > 0 && typeof points[0] === 'number') {
    // $FlowFixMe
    return [getPoint(points)];
  }

  if (Array.isArray(points)) {
    return points.map(function (p) {
      return getPoint(p);
    });
  }

  return [getPoint(points)];
}

function linearPath(start, delta, percent) {
  return start.add(delta.x * percent, delta.y * percent);
}

function curvedPath(start, delta, percent, options) {
  var o = options;
  var angle = Math.atan2(delta.y, delta.x);
  var midPoint = start.add(new Point(delta.x * o.offset, delta.y * o.offset));
  var dist = delta.toPolar().mag * o.magnitude;
  var controlPoint = options.controlPoint;

  if (controlPoint == null) {
    var direction = options.direction;
    var xDelta = Math.cos(angle + o.rot * Math.PI / 2);
    var yDelta = Math.sin(angle + o.rot * Math.PI / 2);

    if (direction === 'up') {
      if (yDelta < 0) {
        yDelta = Math.sin(angle + o.rot * Math.PI / 2 + Math.PI);
      }
    } else if (direction === 'down') {
      if (yDelta > 0) {
        yDelta = Math.sin(angle + o.rot * Math.PI / 2 + Math.PI);
      }
    } else if (direction === 'left') {
      if (xDelta > 0) {
        xDelta = Math.cos(angle + o.rot * Math.PI / 2 + Math.PI);
      }
    } else if (direction === 'right') {
      if (xDelta < 0) {
        xDelta = Math.cos(angle + o.rot * Math.PI / 2 + Math.PI);
      }
    }

    controlPoint = new Point(midPoint.x + dist * xDelta, midPoint.y + dist * yDelta);
  }

  var p0 = start;
  var p1 = controlPoint;
  var p2 = start.add(delta);
  var t = percent;

  var bx = _quadraticBezier(p0.x, p1.x, p2.x, t);

  var by = _quadraticBezier(p0.y, p1.y, p2.y, t);

  return new Point(bx, by);
}

function translationPath() {
  var pathType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'linear';
  var start = arguments.length > 1 ? arguments[1] : undefined;
  var delta = arguments.length > 2 ? arguments[2] : undefined;
  var percent = arguments.length > 3 ? arguments[3] : undefined;
  var options = arguments.length > 4 ? arguments[4] : undefined;

  if (pathType === 'linear') {
    return linearPath(start, delta, percent);
  }

  if (pathType === 'curved') {
    return curvedPath(start, delta, percent, options);
  }

  return new Point(0, 0);
}

function point(x, y) {
  return new Point(x, y);
}

function pointinRect(q, p1, p2, precision) {
  if (precision === undefined || precision === null) {
    if (q.x >= Math.min(p1.x, p2.x) && q.x <= Math.max(p1.x, p2.x) && q.y >= Math.min(p1.y, p2.y) && q.y <= Math.max(p1.y, p2.y)) {
      return true;
    }
  } else if (Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(q.x, precision) >= Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(Math.min(p1.x, p2.x), precision) && Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(q.x, precision) <= Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(Math.max(p1.x, p2.x), precision) && Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(q.y, precision) >= Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(Math.min(p1.y, p2.y), precision) && Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(q.y, precision) <= Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(Math.max(p1.y, p2.y), precision)) {
    return true;
  }

  return false;
}

function distance(p1, p2) {
  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
}

function deg(angle) {
  return angle * 180 / Math.PI;
}

function minAngleDiff(angle1, angle2) {
  if (angle1 === angle2) {
    return 0;
  }

  return Math.atan2(Math.sin(angle1 - angle2), Math.cos(angle1 - angle2));
}

function normAngle(angle) {
  var newAngle = angle;

  while (newAngle >= Math.PI * 2.0) {
    newAngle -= Math.PI * 2.0;
  }

  while (newAngle < 0) {
    newAngle += Math.PI * 2.0;
  }

  return newAngle;
}

function normAngleTo90(angle) {
  var newAngle = normAngle(angle);

  if (newAngle > Math.PI / 2 && newAngle < Math.PI) {
    newAngle += Math.PI;
  }

  if (newAngle === Math.PI) {
    newAngle = 0;
  }

  if (newAngle > Math.PI && newAngle < Math.PI * 3 / 2) {
    newAngle -= Math.PI;
  }

  return newAngle;
}

function getDeltaAngle(startAngle, targetAngle) {
  var rotDirection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var start = normAngle(startAngle);
  var target = normAngle(targetAngle);
  var dir = rotDirection;

  if (start === target) {
    return 0;
  }

  if (dir === 2) {
    if (start > target) {
      dir = -1;
    } else {
      dir = 1;
    }
  }

  if (rotDirection === 0) {
    return minAngleDiff(target, start);
  }

  if (rotDirection === 1) {
    if (start > target) {
      return Math.PI * 2 - start + target;
    }
  }

  if (rotDirection === -1) {
    if (target > start) {
      return -start - (Math.PI * 2 - target);
    }
  }

  return target - start; // if (rotDirection === 2) {
  //   if (target > start) {
  //     return target - start;
  //   }
  // }
  // if (rotDirection === 2) {
  //   if (start + rotDiff < 0) {
  //     rotDiff = Math.PI * 2 + rotDiff;
  //   } else if (start + rotDiff > Math.PI * 2) {
  //     rotDiff = -(Math.PI * 2 - rotDiff);
  //   }
  // } else if (rotDiff * rotDirection < 0) {
  //   rotDiff = rotDirection * Math.PI * 2.0 + rotDiff;
  // }
  // return rotDiff;
}

var Line =
/*#__PURE__*/
function () {
  function Line(p1, p2OrMag) {
    var angle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    _classCallCheck(this, Line);

    this.p1 = getPoint(p1);

    if (p2OrMag instanceof Point || Array.isArray(p2OrMag)) {
      this.p2 = getPoint(p2OrMag);
      this.ang = Math.atan2(this.p2.y - this.p1.y, this.p2.x - this.p1.x);
    } else {
      this.p2 = this.p1.add(p2OrMag * Math.cos(angle), p2OrMag * Math.sin(angle));
      this.ang = angle;
    } // this.A = this.p2.y - this.p1.y;
    // this.B = this.p1.x - this.p2.x;
    // this.C = this.A * this.p1.x + this.B * this.p1.y;
    // this.distance = distance(this.p1, this.p2);


    this.setupLine();
  }

  _createClass(Line, [{
    key: "setupLine",
    value: function setupLine() {
      this.A = this.p2.y - this.p1.y;
      this.B = this.p1.x - this.p2.x;
      this.C = this.A * this.p1.x + this.B * this.p1.y;
      this.distance = distance(this.p1, this.p2);
    }
  }, {
    key: "_dup",
    value: function _dup() {
      return new Line(this.p1, this.p2);
    }
  }, {
    key: "setP1",
    value: function setP1(p1) {
      this.p1 = getPoint(p1);
      this.ang = Math.atan2(this.p2.y - this.p1.y, this.p2.x - this.p1.x);
      this.setupLine();
    }
  }, {
    key: "setP2",
    value: function setP2(p2) {
      this.p2 = getPoint(p2);
      this.ang = Math.atan2(this.p2.y - this.p1.y, this.p2.x - this.p1.x);
      this.setupLine();
    }
  }, {
    key: "getPoint",
    value: function getPoint() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

      if (index === 2) {
        return this.p2;
      }

      return this.p1;
    }
  }, {
    key: "getYFromX",
    value: function getYFromX(x) {
      if (this.B !== 0) {
        return (this.C - this.A * x) / this.B;
      }

      return null;
    }
  }, {
    key: "getXFromY",
    value: function getXFromY(y) {
      if (this.A !== 0) {
        return (this.C - this.B * y) / this.A;
      }

      return null;
    }
  }, {
    key: "angle",
    value: function angle() {
      return this.ang;
    }
  }, {
    key: "round",
    value: function round() {
      var precision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;
      var lineRounded = new Line(this.p1, this.p2);
      lineRounded.A = Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(lineRounded.A, precision);
      lineRounded.B = Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(lineRounded.B, precision);
      lineRounded.C = Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(lineRounded.C, precision);
      lineRounded.ang = Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(lineRounded.ang, precision);
      lineRounded.distance = Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(lineRounded.distance, precision);
      return lineRounded;
    }
  }, {
    key: "length",
    value: function length() {
      // return this.p1.sub(this.p2).distance();
      return this.distance;
    }
    /* eslint-disable comma-dangle */

  }, {
    key: "midPoint",
    value: function midPoint() {
      // const length = this.length();
      // const direction = this.p2.sub(this.p1);
      // const angle = Math.atan2(direction.y, direction.x);
      // const midPoint = point(
      //   this.p1.x + length / 2 * Math.cos(angle),
      //   this.p1.y + length / 2 * Math.sin(angle)
      // );
      // return midPoint;
      return this.pointAtPercent(0.5);
    }
  }, {
    key: "pointAtPercent",
    value: function pointAtPercent(percent) {
      var length = this.length();
      var direction = this.p2.sub(this.p1);
      var angle = Math.atan2(direction.y, direction.x);
      var midPoint = point(this.p1.x + length * percent * Math.cos(angle), this.p1.y + length * percent * Math.sin(angle));
      return midPoint;
    }
  }, {
    key: "pointAtLength",
    value: function pointAtLength(length) {
      var direction = this.p2.sub(this.p1);
      var angle = Math.atan2(direction.y, direction.x);
      var midPoint = point(this.p1.x + length * Math.cos(angle), this.p1.y + length * Math.sin(angle));
      return midPoint;
    }
    /* eslint-enable comma-dangle */

  }, {
    key: "hasPointAlong",
    value: function hasPointAlong(p, precision) {
      if (precision === undefined || precision === null) {
        if (this.C === this.A * p.x + this.B * p.y) {
          return true;
        }
      } else if (Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.C, precision) === Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.A * p.x + this.B * p.y, precision)) {
        return true;
      }

      return false;
    } // perpendicular distance of line to point

  }, {
    key: "distanceToPoint",
    value: function distanceToPoint(p, precision) {
      return Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(Math.abs(this.A * p.x + this.B * p.y - this.C) / Math.sqrt(Math.pow(this.A, 2) + Math.pow(this.B, 2)), precision);
    }
  }, {
    key: "hasPointOn",
    value: function hasPointOn(p, precision) {
      if (this.hasPointAlong(p, precision)) {
        if (pointinRect(p, this.p1, this.p2, precision)) {
          return true;
        }
      }

      return false;
    }
  }, {
    key: "isEqualTo",
    value: function isEqualTo(line2, precision) {
      var l1 = this;
      var l2 = line2;

      if (typeof precision === 'number') {
        l1 = l1.round(precision);
        l2 = l2.round(precision);
        l1.p1 = l1.p1.round(precision);
        l1.p2 = l1.p2.round(precision);
        l2.p1 = l2.p1.round(precision);
        l2.p2 = l2.p2.round(precision);
      }

      if (l1.A !== l2.A) {
        return false;
      }

      if (l1.B !== l2.B) {
        return false;
      }

      if (l1.C !== l2.C) {
        return false;
      }

      if (l1.p1.isNotEqualTo(l2.p1) && l1.p1.isNotEqualTo(l2.p2)) {
        return false;
      }

      if (l1.p2.isNotEqualTo(l2.p1) && l1.p2.isNotEqualTo(l2.p2)) {
        return false;
      }

      return true;
    }
  }, {
    key: "isOnSameLineAs",
    value: function isOnSameLineAs(line2) {
      var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
      var l1 = this.round(precision);
      var l2 = line2.round(precision); // If A and B are zero, then this is not a line

      if (l1.A === 0 && l1.B === 0 || l2.A === 0 && l2.B === 0) {
        return false;
      } // If A is 0, then it must be 0 on the other line. Similar with B


      if (l1.A !== 0) {
        var scale = l2.A / l1.A;

        if (l1.B * scale !== l2.B) {
          return false;
        }

        if (l1.C * scale !== l2.C) {
          return false;
        }

        return true;
      }

      if (l2.A !== 0) {
        var _scale = l1.A / l2.A;

        if (l2.B * _scale !== l1.B) {
          return false;
        }

        if (l2.C * _scale !== l1.C) {
          return false;
        }

        return true;
      }

      if (l1.B !== 0) {
        var _scale2 = l2.B / l1.B;

        if (l1.A * _scale2 !== l2.A) {
          return false;
        }

        if (l1.C * _scale2 !== l2.C) {
          return false;
        }

        return true;
      }

      if (l2.B !== 0) {
        var _scale3 = l1.B / l2.B;

        if (l2.A * _scale3 !== l1.A) {
          return false;
        }

        if (l2.C * _scale3 !== l1.C) {
          return false;
        }

        return true;
      }

      return true;
    } // left, right, top, bottom is relative to cartesian coordinates
    // 'outside' is the outside of a polygon defined in the positive direction
    // (CCW).

  }, {
    key: "offset",
    value: function offset(direction, space) {
      var normalizedAngle = this.ang;

      if (normalizedAngle >= Math.PI) {
        normalizedAngle -= Math.PI;
      }

      if (normalizedAngle < 0) {
        normalizedAngle += Math.PI;
      }

      var offsetAngle = normalizedAngle - Math.PI / 2;

      if (direction === 'positive') {
        offsetAngle = clipAngle(this.ang, '0to360') + Math.PI / 2;
      } else if (direction === 'negative') {
        offsetAngle = clipAngle(this.ang, '0to360') - Math.PI / 2;
      } else if (normalizedAngle < Math.PI / 2) {
        if (direction === 'left' || direction === 'top') {
          offsetAngle = normalizedAngle + Math.PI / 2;
        }
      } else if (direction === 'left' || direction === 'bottom') {
        offsetAngle = normalizedAngle + Math.PI / 2;
      }

      var p1 = new Point(this.p1.x + space * Math.cos(offsetAngle), this.p1.y + space * Math.sin(offsetAngle));
      var p2 = new Point(this.p2.x + space * Math.cos(offsetAngle), this.p2.y + space * Math.sin(offsetAngle));
      return new Line(p1, p2);
    }
  }, {
    key: "intersectsWith",
    value: function intersectsWith(line2) {
      var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
      var l2 = line2; // line2.round(precision);

      var l1 = this; // this.round(precision);

      var det = l1.A * l2.B - l2.A * l1.B;

      if (Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(det, precision) !== 0) {
        var i = point(0, 0);
        i.x = (l2.B * l1.C - l1.B * l2.C) / det;
        i.y = (l1.A * l2.C - l2.A * l1.C) / det;

        if (pointinRect(i, l1.p1, l1.p2, precision) && pointinRect(i, l2.p1, l2.p2, precision)) {
          return {
            onLine: true,
            inLine: true,
            intersect: i
          };
        }

        return {
          onLine: true,
          inLine: false,
          intersect: i
        };
      }

      if (det === 0 && l1.isOnSameLineAs(l2, precision)) {
        // if the lines are colliner then:
        //   - if overlapping,
        //   - if partially overlapping: the intersect point is halfway between
        //     overlapping ends
        //   - if one line is within the other line, the intersect point is
        //     halfway between the midpoints
        //   - if not overlapping, the intersect point is halfway between the nearest ends
        // let l1 = this;
        if (!l1.p1.isOnLine(l2, precision) && !l1.p2.isOnLine(l2, precision) && !l2.p1.isOnLine(l1, precision) && !l2.p2.isOnLine(l1, precision)) {
          var line11 = new Line(l1.p1, l2.p1);
          var line12 = new Line(l1.p1, l2.p2);
          var line21 = new Line(l1.p2, l2.p1);
          var line22 = new Line(l1.p2, l2.p2);

          var _i2 = line11.midPoint();

          var len = line11.length();

          if (line12.length() < len) {
            _i2 = line12.midPoint();
            len = line12.length();
          }

          if (line21.length() < len) {
            _i2 = line21.midPoint();
            len = line21.length();
          }

          if (line22.length() < len) {
            _i2 = line22.midPoint();
            len = line22.length();
          }

          return {
            onLine: true,
            inLine: false,
            intersect: _i2
          };
        }

        if (l1.p1.isOnLine(l2, precision) && l1.p2.isOnLine(l2, precision) && (!l2.p1.isOnLine(l1, precision) || !l2.p2.isOnLine(l1, precision)) || l2.p1.isOnLine(l1, precision) && l2.p2.isOnLine(l1, precision) && (!l1.p1.isOnLine(l2, precision) || !l1.p2.isOnLine(l2, precision))) {
          var _midLine = new Line(l1.midPoint(), l2.midPoint());

          return {
            onLine: true,
            inLine: true,
            intersect: _midLine.midPoint()
          };
        }

        var midLine;

        if (l1.p1.isOnLine(l2, precision) && !l1.p2.isOnLine(l2, precision) && l2.p1.isOnLine(l1, precision) && !l2.p2.isOnLine(l1, precision)) {
          midLine = new Line(l1.p1, l2.p1);
        }

        if (l1.p1.isOnLine(l2, precision) && !l1.p2.isOnLine(l2, precision) && !l2.p1.isOnLine(l1, precision) && l2.p2.isOnLine(l1, precision)) {
          midLine = new Line(l1.p1, l2.p2);
        }

        if (!l1.p1.isOnLine(l2, precision) && l1.p2.isOnLine(l2, precision) && l2.p1.isOnLine(l1, precision) && !l2.p2.isOnLine(l1, precision)) {
          midLine = new Line(l1.p2, l2.p1);
        }

        if (!l1.p1.isOnLine(l2, precision) && l1.p2.isOnLine(l2, precision) && !l2.p1.isOnLine(l1, precision) && l2.p2.isOnLine(l1, precision)) {
          midLine = new Line(l1.p2, l2.p2);
        }

        var _i;

        if (midLine instanceof Line) {
          _i = midLine.midPoint();
        }

        return {
          onLine: true,
          inLine: true,
          intersect: _i
        };
      }

      return {
        onLine: false,
        inLine: false,
        intersect: undefined
      };
    }
  }]);

  return Line;
}();

function line(p1, p2) {
  return new Line(p1, p2);
}

var Rotation =
/*#__PURE__*/
function () {
  function Rotation(angle) {
    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

    _classCallCheck(this, Rotation);

    this.r = angle;
    this.name = name;
  }

  _createClass(Rotation, [{
    key: "matrix",
    value: function matrix() {
      return _m2__WEBPACK_IMPORTED_MODULE_1__["rotationMatrix"](this.r);
    }
  }, {
    key: "sub",
    value: function sub() {
      var rotToSub = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Rotation(0, this.name);
      return new Rotation(this.r - rotToSub.r, this.name);
    }
  }, {
    key: "round",
    value: function round() {
      var precision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;
      return new Rotation(Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.r, precision), this.name);
    }
  }, {
    key: "add",
    value: function add() {
      var rotToAdd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Rotation(0, this.name);
      return new Rotation(this.r + rotToAdd.r, this.name);
    }
  }, {
    key: "mul",
    value: function mul() {
      var rotToMul = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Rotation(1, this.name);
      return new Rotation(this.r * rotToMul.r, this.name);
    }
  }, {
    key: "_dup",
    value: function _dup() {
      return new Rotation(this.r, this.name);
    }
  }]);

  return Rotation;
}();

var Translation =
/*#__PURE__*/
function (_Point) {
  _inherits(Translation, _Point);

  function Translation(tx) {
    var _this;

    var ty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

    _classCallCheck(this, Translation);

    if (tx instanceof Point) {
      _this = _possibleConstructorReturn(this, _getPrototypeOf(Translation).call(this, tx.x, tx.y)); // this.x = tx.x;
      // this.y = tx.y;
    } else {
      _this = _possibleConstructorReturn(this, _getPrototypeOf(Translation).call(this, tx, ty)); // this.x = tx;
      // this.y = ty;
    }

    _this.name = name;
    return _possibleConstructorReturn(_this);
  }

  _createClass(Translation, [{
    key: "matrix",
    value: function matrix() {
      return _m2__WEBPACK_IMPORTED_MODULE_1__["translationMatrix"](this.x, this.y);
    }
  }, {
    key: "sub",
    value: function sub() {
      var translationToSub = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Translation(0, 0);
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var t = new Point(0, 0);

      if (typeof translationToSub === 'number') {
        t = new Translation(translationToSub, y);
      } else {
        t = translationToSub;
      }

      return new Translation(this.x - t.x, this.y - t.y, this.name);
    }
  }, {
    key: "add",
    value: function add() {
      var translationToAdd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Translation(0, 0);
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var t = new Point(0, 0);

      if (typeof translationToAdd === 'number') {
        t = new Translation(translationToAdd, y);
      } else {
        t = translationToAdd;
      }

      return new Translation(this.x + t.x, this.y + t.y, this.name);
    }
  }, {
    key: "mul",
    value: function mul() {
      var translationToMul = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Translation(1, 1);
      return new Translation(this.x * translationToMul.x, this.y * translationToMul.y, this.name);
    }
  }, {
    key: "round",
    value: function round() {
      var precision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;
      return new Translation(Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.x, precision), Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.y, precision), this.name);
    }
  }, {
    key: "_dup",
    value: function _dup() {
      return new Translation(this.x, this.y, this.name);
    }
  }]);

  return Translation;
}(Point);

var Scale =
/*#__PURE__*/
function (_Point2) {
  _inherits(Scale, _Point2);

  function Scale(sx, sy) {
    var _this2;

    var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

    _classCallCheck(this, Scale);

    if (sx instanceof Point) {
      _this2 = _possibleConstructorReturn(this, _getPrototypeOf(Scale).call(this, sx.x, sx.y)); // this.x = sx.x;
      // this.y = sx.y;
    } else {
      _this2 = _possibleConstructorReturn(this, _getPrototypeOf(Scale).call(this, sx, sy)); // this.x = sx;
      // this.y = sy;
    }

    _this2.name = name;
    return _possibleConstructorReturn(_this2);
  }

  _createClass(Scale, [{
    key: "matrix",
    value: function matrix() {
      return _m2__WEBPACK_IMPORTED_MODULE_1__["scaleMatrix"](this.x, this.y);
    }
  }, {
    key: "sub",
    value: function sub() {
      var scaleToSub = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Scale(0, 0);
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var s = new Point(0, 0);

      if (typeof scaleToSub === 'number') {
        s = new Scale(scaleToSub, y);
      } else {
        s = scaleToSub;
      }

      return new Scale(this.x - s.x, this.y - s.y, this.name);
    }
  }, {
    key: "round",
    value: function round() {
      var precision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;
      return new Scale(Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.x, precision), Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.y, precision), this.name);
    }
  }, {
    key: "add",
    value: function add() {
      var scaleToAdd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Scale(0, 0);
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var s = new Point(0, 0);

      if (typeof scaleToAdd === 'number') {
        s = new Scale(scaleToAdd, y);
      } else {
        s = scaleToAdd;
      }

      return new Scale(this.x + s.x, this.y + s.y, this.name);
    }
  }, {
    key: "mul",
    value: function mul() {
      var scaleToMul = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Scale(1, 1);

      if (scaleToMul instanceof Scale || scaleToMul instanceof Point) {
        return new Scale(this.x * scaleToMul.x, this.y * scaleToMul.y);
      }

      return new Scale(this.x * scaleToMul, this.y * scaleToMul, this.name);
    }
  }, {
    key: "_dup",
    value: function _dup() {
      return new Scale(this.x, this.y, this.name);
    }
  }]);

  return Scale;
}(Point);

var TransformLimit =
/*#__PURE__*/
function () {
  function TransformLimit(scale, rotation, translation) {
    _classCallCheck(this, TransformLimit);

    this.scale = scale;
    this.rotation = rotation;
    this.translation = translation;
  }

  _createClass(TransformLimit, [{
    key: "_dup",
    value: function _dup() {
      return new TransformLimit(this.scale, this.rotation, this.translation);
    }
  }]);

  return TransformLimit;
}();

var Transform =
/*#__PURE__*/
function () {
  function Transform() {
    var orderOrName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

    _classCallCheck(this, Transform);

    if (typeof orderOrName === 'string') {
      this.order = [];
      this.name = orderOrName;
    } else {
      this.order = orderOrName.map(function (t) {
        return t._dup();
      });
      this.name = name;
    } // this.order = order.slice();


    this.index = this.order.length;
    this._type = 'transform';
    this.calcMatrix();
  }

  _createClass(Transform, [{
    key: "standard",
    value: function standard() {
      return this.scale(1, 1).rotate(0).translate(0, 0);
    }
  }, {
    key: "translate",
    value: function translate(x) {
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var translation = new Translation(x, y, this.name);
      var order = this.order.slice();

      if (this.index === this.order.length) {
        order.push(translation);
      } else {
        this.order[this.index] = translation;
        this.index += 1;
        this.calcMatrix();
        return this;
      }

      return new Transform(order, this.name);
    }
  }, {
    key: "rotate",
    value: function rotate(r) {
      var rotation = new Rotation(r, this.name);
      rotation.name = this.name;
      var order = this.order.slice();

      if (this.index === this.order.length) {
        order.push(rotation);
      } else {
        this.order[this.index] = rotation;
        this.index += 1;
        this.calcMatrix();
        return this;
      } // this.order.push(new Rotation(r));
      // this.calcMatrix();


      return new Transform(order, this.name);
    }
  }, {
    key: "scale",
    value: function scale(x) {
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var scale = new Scale(x, y, this.name);
      var order = this.order.slice();

      if (this.index === this.order.length) {
        order.push(scale);
      } else {
        this.order[this.index] = scale;
        this.index += 1;
        this.calcMatrix();
        return this;
      }

      return new Transform(order, this.name);
    }
  }, {
    key: "remove",
    value: function remove(transformNames) {
      var newOrder = [];
      var names;

      if (typeof transformNames === 'string') {
        names = [transformNames];
      } else {
        names = transformNames;
      }

      this.order.forEach(function (transformElement) {
        if (names.indexOf(transformElement.name) === -1) {
          newOrder.push(transformElement._dup());
        }
      });
      return new Transform(newOrder, this.name);
    }
  }, {
    key: "calcMatrix",
    value: function calcMatrix() {
      var m = _m2__WEBPACK_IMPORTED_MODULE_1__["identity"]();

      for (var i = this.order.length - 1; i >= 0; i -= 1) {
        m = _m2__WEBPACK_IMPORTED_MODULE_1__["mul"](m, this.order[i].matrix());
      } // this.mat = m2.copy(m);
      // return m;


      this.mat = m;
    }
  }, {
    key: "update",
    value: function update(index) {
      if (index < this.order.length) {
        this.index = index;
      }

      return this;
    }
  }, {
    key: "t",
    value: function t() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var count = 0;

      for (var i = 0; i < this.order.length; i += 1) {
        var t = this.order[i];

        if (t instanceof Translation) {
          if (count === index) {
            return new Point(t.x, t.y);
          }

          count += 1;
        }
      }

      return null;
    }
  }, {
    key: "clipRotation",
    value: function clipRotation(clipTo) {
      for (var i = 0; i < this.order.length; i += 1) {
        var transformStep = this.order[i];

        if (transformStep instanceof Rotation) {
          transformStep.r = clipAngle(transformStep.r, clipTo);
        }
      }
    }
  }, {
    key: "updateTranslation",
    value: function updateTranslation(x) {
      var yOrIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var count = 0;
      var actualIndex = index;

      if (x instanceof Point) {
        actualIndex = yOrIndex;
      }

      for (var i = 0; i < this.order.length; i += 1) {
        var t = this.order[i];

        if (t instanceof Translation) {
          if (count === actualIndex) {
            this.order[i] = new Translation(x, yOrIndex, this.name);
            this.calcMatrix();
            return;
          }

          count += 1;
        }
      }
    }
  }, {
    key: "s",
    value: function s() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var count = 0;

      for (var i = 0; i < this.order.length; i += 1) {
        var t = this.order[i];

        if (t instanceof Scale) {
          if (count === index) {
            return new Point(t.x, t.y);
          }

          count += 1;
        }
      }

      return null;
    }
  }, {
    key: "toDelta",
    value: function toDelta(delta, percent, translationStyle, translationOptions) // translationPath: (Point, Point, number, ?number, ?number) => Point,
    // direction: number = 1,
    // mag: number = 0.5,
    // offset: number = 0.5,
    {
      var calcTransform = this._dup();

      for (var i = 0; i < this.order.length; i += 1) {
        var stepStart = this.order[i];
        var stepDelta = delta.order[i];

        if (stepStart instanceof Scale && stepDelta instanceof Scale) {
          calcTransform.order[i] = stepStart.add(stepDelta.mul(percent));
        }

        if (stepStart instanceof Rotation && stepDelta instanceof Rotation) {
          calcTransform.order[i] = new Rotation(stepStart.r + stepDelta.r * percent);
        }

        if (stepStart instanceof Translation && stepDelta instanceof Translation) {
          calcTransform.order[i] = new Translation(translationPath(translationStyle, stepStart, stepDelta, percent, translationOptions));
        }
      }

      return calcTransform;
    }
  }, {
    key: "updateScale",
    value: function updateScale(x) {
      var yOrIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var count = 0;
      var actualIndex = index;

      if (x instanceof Point) {
        actualIndex = yOrIndex;
      }

      for (var i = 0; i < this.order.length; i += 1) {
        var t = this.order[i];

        if (t instanceof Scale) {
          if (count === actualIndex) {
            this.order[i] = new Scale(x, yOrIndex, this.name);
            this.calcMatrix();
            return;
          }

          count += 1;
        }
      }
    }
  }, {
    key: "r",
    value: function r() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var count = 0;

      for (var i = 0; i < this.order.length; i += 1) {
        var t = this.order[i];

        if (t instanceof Rotation) {
          if (count === index) {
            return t.r;
          }

          count += 1;
        }
      }

      return null;
    }
  }, {
    key: "updateRotation",
    value: function updateRotation(r) {
      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var count = 0;

      for (var i = 0; i < this.order.length; i += 1) {
        var t = this.order[i];

        if (t instanceof Rotation) {
          if (count === index) {
            this.order[i] = new Rotation(r, this.name);
            this.calcMatrix();
            return;
          }

          count += 1;
        }
      }
    }
  }, {
    key: "m",
    value: function m() {
      return this.mat;
    }
  }, {
    key: "matrix",
    value: function matrix() {
      return this.mat;
    }
  }, {
    key: "isSimilarTo",
    value: function isSimilarTo(transformToCompare) {
      if (transformToCompare.order.length !== this.order.length) {
        return false;
      }

      for (var i = 0; i < this.order.length; i += 1) {
        if (this.order[i].constructor.name !== transformToCompare.order[i].constructor.name) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "isEqualTo",
    value: function isEqualTo(transformToCompare) {
      var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;

      // if (transformToCompare.order.length !== this.order.length) {
      //   return false;
      // }
      if (!this.isSimilarTo(transformToCompare)) {
        return false;
      }

      for (var i = 0; i < this.order.length; i += 1) {
        var compare = transformToCompare.order[i];
        var thisTrans = this.order[i];

        if (thisTrans.constructor.name !== compare.constructor.name) {
          return false;
        }

        if (thisTrans instanceof Translation && compare instanceof Translation || thisTrans instanceof Scale && compare instanceof Scale) {
          if (compare.isNotEqualTo(thisTrans, precision)) {
            return false;
          }
        }

        if (thisTrans instanceof Rotation) {
          if (compare.r !== thisTrans.r) {
            return false;
          }
        }
      }

      return true;
    } // Subtract a transform from the current one.
    // If the two transforms have different order types, then just return
    // the current transform.

  }, {
    key: "sub",
    value: function sub() {
      var transformToSubtract = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Transform();

      if (!this.isSimilarTo(transformToSubtract)) {
        return new Transform(this.order, this.name);
      }

      var order = [];

      for (var i = 0; i < this.order.length; i += 1) {
        // $FlowFixMe (this is already fixed in isSimilarTo check above)
        order.push(this.order[i].sub(transformToSubtract.order[i]));
      }

      return new Transform(order, this.name);
    } // Add a transform to the current one.
    // If the two transforms have different order types, then just return
    // the current transform.

  }, {
    key: "add",
    value: function add() {
      var transformToAdd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Transform();

      if (!this.isSimilarTo(transformToAdd)) {
        return new Transform(this.order, this.name);
      }

      var order = [];

      for (var i = 0; i < this.order.length; i += 1) {
        // $FlowFixMe (this is already fixed in isSimilarTo check above)
        order.push(this.order[i].add(transformToAdd.order[i]));
      }

      return new Transform(order, this.name);
    } // transform step wise multiplication

  }, {
    key: "mul",
    value: function mul() {
      var transformToMul = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Transform();

      if (!this.isSimilarTo(transformToMul)) {
        return new Transform(this.order, this.name);
      }

      var order = [];

      for (var i = 0; i < this.order.length; i += 1) {
        // $FlowFixMe (this is already fixed in isSimilarTo check above)
        order.push(this.order[i].mul(transformToMul.order[i]));
      }

      return new Transform(order, this.name);
    }
  }, {
    key: "transform",
    value: function transform(_transform) {
      var t = new Transform([], this.name);
      t.order = _transform.order.concat(this.order);
      t.mat = _m2__WEBPACK_IMPORTED_MODULE_1__["mul"](this.matrix(), _transform.matrix());
      return t;
    }
  }, {
    key: "transformBy",
    value: function transformBy(transform) {
      var t = new Transform([], this.name);
      t.order = this.order.concat(transform.order);
      t.mat = _m2__WEBPACK_IMPORTED_MODULE_1__["mul"](transform.matrix(), this.matrix());
      return t;
    }
  }, {
    key: "round",
    value: function round() {
      var precision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;
      var order = [];

      for (var i = 0; i < this.order.length; i += 1) {
        order.push(this.order[i].round(precision));
      }

      return new Transform(order, this.name);
    }
  }, {
    key: "clip",
    value: function clip(minTransform, maxTransform, limitLine) {
      if (!this.isSimilarTo(minTransform) || !this.isSimilarTo(maxTransform)) {
        return this._dup();
      }

      var order = [];

      for (var i = 0; i < this.order.length; i += 1) {
        var t = this.order[i];
        var min = minTransform.order[i];
        var max = maxTransform.order[i];

        if (t instanceof Translation && min instanceof Translation && max instanceof Translation) {
          var x = Object(_math__WEBPACK_IMPORTED_MODULE_0__["clipValue"])(t.x, min.x, max.x);
          var y = Object(_math__WEBPACK_IMPORTED_MODULE_0__["clipValue"])(t.y, min.y, max.y);
          order.push(new Translation(x, y, this.name));
        } else if (t instanceof Rotation && min instanceof Rotation && max instanceof Rotation) {
          order.push(new Rotation(Object(_math__WEBPACK_IMPORTED_MODULE_0__["clipValue"])(t.r, min.r, max.r), this.name));
        } else if (t instanceof Scale && min instanceof Scale && max instanceof Scale) {
          var _x = Object(_math__WEBPACK_IMPORTED_MODULE_0__["clipValue"])(t.x, min.x, max.x);

          var _y = Object(_math__WEBPACK_IMPORTED_MODULE_0__["clipValue"])(t.y, min.y, max.y);

          order.push(new Scale(_x, _y, this.name));
        }
      }

      var clippedTransform = new Transform(order, this.name);

      if (limitLine != null) {
        var _t = clippedTransform.t();

        if (_t != null) {
          var perpLine = new Line(_t, 1, limitLine.angle() + Math.PI / 2);

          var _perpLine$intersectsW = perpLine.intersectsWith(limitLine),
              intersect = _perpLine$intersectsW.intersect;

          if (intersect) {
            if (intersect.isOnLine(limitLine, 4)) {
              clippedTransform.updateTranslation(intersect);
            } else {
              var p1Dist = distance(intersect, limitLine.p1);
              var p2Dist = distance(intersect, limitLine.p2);

              if (p1Dist < p2Dist) {
                clippedTransform.updateTranslation(limitLine.p1);
              } else {
                clippedTransform.updateTranslation(limitLine.p2);
              }
            }
          }
        }
      }

      return clippedTransform;
    }
  }, {
    key: "clipMag",
    value: function clipMag(zeroThresholdTransform, maxTransform) {
      var vector = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      // const min = 0.00001;
      // const max = 1 / min;
      // const zeroS = zeroThresholdTransform.s() || new Point(min, min);
      // const zeroR = zeroThresholdTransform.r() || min;
      // const zeroT = zeroThresholdTransform.t() || new Point(min, min);
      // const maxS = maxTransform.s() || new Point(max, max);
      // const maxR = maxTransform.r() || max;
      // const maxT = maxTransform.t() || new Point(max, max);
      // if (!this.isSimilarTo(zeroThresholdTransform) ||
      //     !this.isSimilarTo(maxTransform)) {
      //   return new Transform(this.order);
      // }
      var order = [];
      var z = zeroThresholdTransform;
      var max = maxTransform;

      for (var i = 0; i < this.order.length; i += 1) {
        var t = this.order[i];

        if (t instanceof Translation) {
          if (vector) {
            var _t$toPolar = t.toPolar(),
                mag = _t$toPolar.mag,
                angle = _t$toPolar.angle;

            var clipM = Object(_math__WEBPACK_IMPORTED_MODULE_0__["clipMag"])(mag, z.translation, max.translation);

            order.push(new Translation(clipM * Math.cos(angle), clipM * Math.sin(angle), this.name));
          } else {
            var x = Object(_math__WEBPACK_IMPORTED_MODULE_0__["clipMag"])(t.x, z.translation, max.translation);

            var y = Object(_math__WEBPACK_IMPORTED_MODULE_0__["clipMag"])(t.y, z.translation, max.translation);

            order.push(new Translation(x, y, this.name));
          }
        } else if (t instanceof Rotation) {
          var r = Object(_math__WEBPACK_IMPORTED_MODULE_0__["clipMag"])(t.r, z.rotation, max.rotation);

          order.push(new Rotation(r, this.name));
        } else if (t instanceof Scale) {
          if (vector) {
            var _t$toPolar2 = t.toPolar(),
                _mag = _t$toPolar2.mag,
                _angle = _t$toPolar2.angle;

            var _clipM = Object(_math__WEBPACK_IMPORTED_MODULE_0__["clipMag"])(_mag, z.scale, max.scale);

            order.push(new Scale(_clipM * Math.cos(_angle), _clipM * Math.sin(_angle), this.name));
          } else {
            var _x2 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["clipMag"])(t.x, z.scale, max.scale);

            var _y2 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["clipMag"])(t.y, z.scale, max.scale);

            order.push(new Scale(_x2, _y2, this.name));
          }
        }
      }

      return new Transform(order, this.name);
    }
  }, {
    key: "constant",
    value: function constant() {
      var _constant = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var order = [];

      for (var i = 0; i < this.order.length; i += 1) {
        var t = this.order[i];

        if (t instanceof Translation) {
          order.push(new Translation(_constant, _constant, this.name));
        } else if (t instanceof Rotation) {
          order.push(new Rotation(_constant, this.name));
        } else if (t instanceof Scale) {
          order.push(new Scale(_constant, _constant, this.name));
        }
      }

      return new Transform(order, this.name);
    }
  }, {
    key: "zero",
    value: function zero() {
      return this.constant(0);
    }
  }, {
    key: "isZero",
    value: function isZero() {
      for (var i = 0; i < this.order.length; i += 1) {
        var t = this.order[i];

        if (t instanceof Translation || t instanceof Scale) {
          if (t.x !== 0 || t.y !== 0) {
            return false;
          }
        } else if (t instanceof Rotation) {
          if (t.r !== 0) {
            return false;
          }
        }
      }

      return true;
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var t = new Transform(this.order, this.name);
      t.index = this.index;
      return t;
    }
  }, {
    key: "decelerate",
    value: function decelerate(velocity, deceleration, deltaTime, zeroThreshold) {
      var nextV = new Transform();
      var nextT = new Transform();
      var z = zeroThreshold;
      var d = deceleration;

      for (var i = 0; i < this.order.length; i += 1) {
        var t = this.order[i];
        var v = velocity.order[i]; // const z = zeroThreshold.order[i];

        if (t instanceof Translation && v instanceof Translation) {
          var _v$toPolar = v.toPolar(),
              mag = _v$toPolar.mag,
              angle = _v$toPolar.angle;

          var next = Object(_math__WEBPACK_IMPORTED_MODULE_0__["decelerate"])(0, mag, d.translation, deltaTime, z.translation);

          nextV = nextV.translate(next.v * Math.cos(angle), next.v * Math.sin(angle));
          nextT = nextT.translate(t.x + next.p * Math.cos(angle), t.y + next.p * Math.sin(angle));
        } else if (t instanceof Rotation && v instanceof Rotation) {
          var r = Object(_math__WEBPACK_IMPORTED_MODULE_0__["decelerate"])(t.r, v.r, d.rotation, deltaTime, z.rotation);

          nextV = nextV.rotate(r.v);
          nextT = nextT.rotate(r.p);
        } else if (t instanceof Scale && v instanceof Scale) {
          var _v$toPolar2 = v.toPolar(),
              _mag2 = _v$toPolar2.mag,
              _angle2 = _v$toPolar2.angle;

          var _next = Object(_math__WEBPACK_IMPORTED_MODULE_0__["decelerate"])(0, _mag2, d.scale, deltaTime, z.scale);

          nextV = nextV.scale(_next.v * Math.cos(_angle2), _next.v * Math.sin(_angle2));
          nextT = nextT.scale(t.x + _next.p * Math.cos(_angle2), t.y + _next.p * Math.sin(_angle2));
        } else {
          return {
            v: new Transform(),
            t: new Transform()
          };
        }
      }

      return {
        v: nextV,
        t: nextT
      };
    } // Return the velocity of each element in the transform
    // If the current and previous transforms are inconsistent in type order,
    // then a transform of value 0, but with the same type order as "this" will
    // be returned.

  }, {
    key: "velocity",
    value: function velocity(previousTransform, deltaTime, zeroThreshold, maxTransform) {
      var order = [];

      if (!this.isSimilarTo(previousTransform)) {
        return this.zero();
      }

      var deltaTransform = this.sub(previousTransform);

      for (var i = 0; i < deltaTransform.order.length; i += 1) {
        var t = deltaTransform.order[i];

        if (t instanceof Translation) {
          order.push(new Translation(t.x / deltaTime, t.y / deltaTime));
        } else if (t instanceof Rotation) {
          order.push(new Rotation(t.r / deltaTime));
        } else if (t instanceof Scale) {
          order.push(new Scale(t.x / deltaTime, t.y / deltaTime));
        }
      }

      var v = new Transform(order); // let z = zeroThreshold;
      // let m = maxTransform;
      // if (!this.isSimilarTo(zeroThreshold)) {
      //   z = this.constant(0);
      // }
      // if (!this.isSimilarTo(maxTransform)) {
      //   m = v._dup();
      // }

      return v.clipMag(zeroThreshold, maxTransform);
    }
  }]);

  return Transform;
}();

function spaceToSpaceTransform(s1, s2) {
  var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  var xScale = s2.x.width / s1.x.width;
  var yScale = s2.y.height / s1.y.height;
  var t = new Transform(name).scale(xScale, yScale).translate(s2.x.bottomLeft - s1.x.bottomLeft * xScale, s2.y.bottomLeft - s1.y.bottomLeft * yScale);
  return t;
}

function spaceToSpaceScale(s1, s2) {
  var xScale = s2.x.width / s1.x.width;
  var yScale = s2.y.height / s1.y.height;
  return new Point(xScale, yScale);
}

function comparePoints(p, currentMin, currentMax, firstPoint) {
  var min = new Point(0, 0);
  var max = new Point(0, 0);

  if (firstPoint) {
    min.x = p.x;
    min.y = p.y;
    max.x = p.x;
    max.y = p.y;
  } else {
    min.x = p.x < currentMin.x ? p.x : currentMin.x;
    min.y = p.y < currentMin.y ? p.y : currentMin.y;
    max.x = p.x > currentMax.x ? p.x : currentMax.x;
    max.y = p.y > currentMax.y ? p.y : currentMax.y;
  }

  return {
    min: min,
    max: max
  };
}

function polarToRect(mag, angle) {
  return new Point(mag * Math.cos(angle), mag * Math.sin(angle));
}

function rectToPolar(x) {
  var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var rect;

  if (typeof x === 'number') {
    rect = new Point(x, y);
  } else {
    rect = x;
  }

  var mag = rect.distance();
  var angle = Math.atan2(rect.y, rect.x);

  if (angle < 0) {
    angle += Math.PI * 2;
  }

  return {
    mag: mag,
    angle: angle
  };
} // $FlowFixMe


function getBoundingRect(pointArrays) {
  var firstPoint = true;
  var result = {
    min: new Point(0, 0),
    max: new Point(0, 0)
  };
  pointArrays.forEach(function (pointOrArray) {
    if (Array.isArray(pointOrArray)) {
      pointOrArray.forEach(function (p) {
        result = comparePoints(p, result.min, result.max, firstPoint);
        firstPoint = false;
      });
    } else {
      result = comparePoints(pointOrArray, result.min, result.max, firstPoint);
    }

    firstPoint = false;
  });
  return new Rect(result.min.x, result.min.y, result.max.x - result.min.x, result.max.y - result.min.y);
} // // Finds the min angle between three points
// function threePointAngleMin(p2: Point, p1: Point, p3: Point) {
//   const p12 = distance(p1, p2);
//   const p13 = distance(p1, p3);
//   const p23 = distance(p2, p3);
//   return Math.acos((p12 ** 2 + p13 ** 2 - p23 ** 2) / (2 * p12 * p13));
// }
// Finds the angle between three points for p12 to p13 in the positive
// angle direction


function threePointAngle(p2, p1, p3) {
  var r12 = p2.sub(p1);
  var r13 = p3.sub(p1); // const p12 = distance(p1, p2);
  // const p13 = distance(p1, p3);
  // const p23 = distance(p2, p3);
  // const minAngle = Math.acos((p12 ** 2 + p13 ** 2 - p23 ** 2) / (2 * p12 * p13));

  var angle12 = r12.toPolar().angle;
  var angle13 = r13.toPolar().angle;
  angle13 -= angle12;
  angle12 = 0;
  return clipAngle(angle13, '0to360');
}

function threePointAngleMin(p2, p1, p3) {
  var a12 = clipAngle(Math.atan2(p2.y - p1.y, p2.x - p1.x), '0to360');
  var a13 = clipAngle(Math.atan2(p3.y - p1.y, p3.x - p1.x), '0to360');
  var delta = a13 - a12;

  if (delta > Math.PI) {
    delta = -(Math.PI * 2 - delta);
  } else if (delta < -Math.PI) {
    delta = Math.PI * 2 + delta;
  }

  return delta;
}

function randomPoint(withinRect) {
  var randPoint = Object(_math__WEBPACK_IMPORTED_MODULE_0__["rand2D"])(withinRect.left, withinRect.bottom, withinRect.right, withinRect.top);
  return new Point(randPoint.x, randPoint.y);
}

function getMaxTimeFromVelocity(startTransform, stopTransform, velocityTransform) {
  var rotDirection = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var deltaTransform = stopTransform.sub(startTransform);
  var time = 0;
  var velocityTransformToUse;

  if (typeof velocityTransform === 'number') {
    velocityTransformToUse = startTransform._dup().constant(velocityTransform);
  } else {
    velocityTransformToUse = velocityTransform;
  }

  deltaTransform.order.forEach(function (delta, index) {
    if (delta instanceof Translation || delta instanceof Scale) {
      var v = velocityTransformToUse.order[index];

      if ((v instanceof Translation || v instanceof Scale) && v.x !== 0 && v.y !== 0) {
        var xTime = Math.abs(delta.x) / v.x;
        var yTime = Math.abs(delta.y) / v.y;
        time = xTime > time ? xTime : time;
        time = yTime > time ? yTime : time;
      }
    }

    var start = startTransform.order[index];
    var target = stopTransform.order[index];

    if (delta instanceof Rotation && start instanceof Rotation && target instanceof Rotation) {
      var rotDiff = getDeltaAngle(start.r, target.r, rotDirection); // eslint-disable-next-line no-param-reassign

      delta.r = rotDiff;
      var _v = velocityTransformToUse.order[index];

      if (_v instanceof Rotation && _v !== 0) {
        var rTime = Math.abs(delta.r / _v.r);
        time = rTime > time ? rTime : time;
      }
    }
  });
  return time;
}

function getMoveTime(startTransform, stopTransform) // 100%/s
{
  var rotDirection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var translationVelocity = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Point(0.25, 0.25);
  var rotationVelocity = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 2 * Math.PI / 6;
  var scaleVelocity = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new Point(1, 1);
  var startTransforms;

  if (startTransform instanceof Transform) {
    startTransforms = [startTransform];
  } else {
    startTransforms = startTransform;
  }

  var stopTransforms;

  if (stopTransform instanceof Transform) {
    stopTransforms = [stopTransform];
  } else {
    stopTransforms = stopTransform;
  }

  if (stopTransforms.length !== startTransforms.length) {
    return 0;
  }

  var maxTime = 0;
  startTransforms.forEach(function (startT, index) {
    var stopT = stopTransforms[index];

    var velocity = startT._dup();

    for (var i = 0; i < velocity.order.length; i += 1) {
      var v = velocity.order[i];

      if (v instanceof Translation) {
        v.x = translationVelocity.x;
        v.y = translationVelocity.y;
      } else if (v instanceof Rotation) {
        v.r = rotationVelocity;
      } else {
        v.x = scaleVelocity.x;
        v.y = scaleVelocity.y;
      }
    }

    var time = getMaxTimeFromVelocity(startT, stopT, velocity, rotDirection);

    if (time > maxTime) {
      maxTime = time;
    }
  });
  return maxTime;
}

function quadBezierPoints(p0, p1, p2, sides) {
  var step = 1 / sides;

  if (sides === 0 || sides === 1 || sides === 2) {
    return [p0, p1, p2];
  }

  var points = [];

  for (var i = 0; i < sides + 1; i += 1) {
    var t = 0 + i * step;
    points.push(new Point(Math.pow(1 - t, 2) * p0.x + 2 * (1 - t) * t * p1.x + t * t * p2.x, Math.pow(1 - t, 2) * p0.y + 2 * (1 - t) * t * p1.y + t * t * p2.y));
  }

  return points;
}



/***/ }),

/***/ "./src/js/tools/getCssColors.js":
/*!**************************************!*\
  !*** ./src/js/tools/getCssColors.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getCSSColors; });
/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color */ "./src/js/tools/color.js");
/* harmony import */ var _getCssVariables__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getCssVariables */ "./src/js/tools/getCssVariables.js");
// eslint-disable-next-line import/no-cycle


var baseColors = ['blue', 'red', 'yellow', 'green', 'cyan', 'brown', 'orange', 'violet', 'grey', 'black', 'white'];
var shades = ['base', 'lighter', 'light', 'dark', 'darker', 'higher', 'high', 'low', 'lower'];
var paletteColorNames = [];
baseColors.forEach(function (color) {
  shades.forEach(function (shade) {
    paletteColorNames.push("--palette-".concat(color, "-").concat(shade));
  });
});
var diagramColorNames = ['--diagram-background', '--diagram-primary', '--diagram-warning', '--diagram-safe', '--diagram-passive', '--diagram-construction1', '--diagram-construction2', '--diagram-construction3', '--diagram-construction4', '--diagram-construction5', '--diagram-construction6', '--diagram-construction7', '--diagram-construction8', '--diagram-construction9', '--diagram-disabled', '--diagram-disabledDark', '--diagram-disabledDarker', '--diagram-disabledDarkest', '--diagram-push', '--diagram-action', '--diagram-text-base', '--diagram-text-warning', '--diagram-text-plot', '--diagram-text-keyword', '--diagram-text-keyword2', '--diagram-text-latin', '--diagram-text-greek', '--diagram-text-english', '--diagram-text-note', '--diagram-qr-background'];
function getCSSColors() {
  var customColorNames = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var colors = {};
  var paletteColors = {};
  var diagramColors = {};
  var colorNames = customColorNames.map(function (name) {
    return "--colors-".concat(name);
  });
  var _document = document,
      body = _document.body;

  if (body) {
    colors = Object(_getCssVariables__WEBPACK_IMPORTED_MODULE_1__["getDefinedCSSVariables"])(body, colorNames, '--colors-', false, // $FlowFixMe
    _color__WEBPACK_IMPORTED_MODULE_0__["cssColorToArray"]);
    paletteColors = Object(_getCssVariables__WEBPACK_IMPORTED_MODULE_1__["getDefinedCSSVariables"])(body, paletteColorNames, '--palette-', false, // $FlowFixMe
    _color__WEBPACK_IMPORTED_MODULE_0__["cssColorToArray"]);
    diagramColors = Object(_getCssVariables__WEBPACK_IMPORTED_MODULE_1__["getDefinedCSSVariables"])(body, diagramColorNames, '--diagram-', false, // $FlowFixMe
    _color__WEBPACK_IMPORTED_MODULE_0__["cssColorToArray"]);
  }

  colors.palette = paletteColors;
  colors.diagram = diagramColors;
  return colors;
}

/***/ }),

/***/ "./src/js/tools/getCssVariables.js":
/*!*****************************************!*\
  !*** ./src/js/tools/getCssVariables.js ***!
  \*****************************************/
/*! exports provided: getCSSVariables, getDefinedCSSVariables, searchObject */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCSSVariables", function() { return getCSSVariables; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDefinedCSSVariables", function() { return getDefinedCSSVariables; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "searchObject", function() { return searchObject; });
/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tools */ "./src/js/tools/tools.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }



function searchObject(obj, path, text) {
  var results = [];
  Object.keys(obj).forEach(function (key) {
    var newPath = "".concat(path, ".").concat(key);

    if (key.includes(text)) {
      results.push(newPath);
    } else if (_typeof(obj[key]) === 'object') {
      var newResult = searchObject(obj[key], newPath, text);

      if (newResult) {
        results = results.concat(newResult);
      }
    } else if (typeof obj[key] === 'string') {
      if (obj[key].includes(text)) {
        results.push(newPath);
      }
    }
  });
  return results;
}

function toCamelCase(input, prefix) {
  var rePrefix = new RegExp(prefix, 'g');
  var reCamelCase1 = /-[a-z]/g;
  var reCamelCase2 = /_[a-z]/g;

  var repl = function repl(str) {
    return str[1].toUpperCase();
  };

  var noPrefix = input.replace(rePrefix, '');
  var camelCase1 = noPrefix.replace(reCamelCase1, repl);
  var camelCase2 = camelCase1.replace(reCamelCase2, repl);
  var noDash = camelCase2.replace(/-/g, '');
  return noDash;
}

function getDefinedCSSVariables(idOrElement, propertyNames) {
  var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  var makeFlat = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var modifier = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function (a) {
    return a;
  };
  var variables = {};
  var elem = idOrElement;

  if (typeof idOrElement === 'string') {
    elem = document.getElementById(idOrElement);
  }

  if (elem instanceof HTMLElement) {
    var style = window.getComputedStyle(elem);

    if (style) {
      propertyNames.forEach(function (propertyName) {
        var value = style.getPropertyValue(propertyName);

        if (value == null) {
          return;
        }

        value = value.trim();
        var fValue = parseFloat(value);
        var valueToAdd = value;

        if (!Number.isNaN(fValue)) {
          valueToAdd = fValue;
        }

        valueToAdd = modifier(valueToAdd);

        if (makeFlat) {
          var shortName = toCamelCase(propertyName, prefix);
          variables[shortName] = valueToAdd;
        } else {
          var rePrefix = new RegExp(prefix, 'g');
          var noPrefix = propertyName.replace(rePrefix, '');
          Object(_tools__WEBPACK_IMPORTED_MODULE_0__["addToObject"])(variables, noPrefix, valueToAdd, '-');
        }
      });
    }
  }

  return variables;
}

function getCSSVariables(idOrElement) {
  var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var makeFlat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var variables = {};
  var elem = idOrElement;

  if (typeof idOrElement === 'string') {
    elem = document.getElementById(idOrElement);
  }

  if (elem instanceof HTMLElement) {
    var style = window.getComputedStyle(elem);

    if (style) {
      var numProperties = style.length;

      for (var i = 0; i < numProperties; i += 1) {
        var propertyName = style[i];

        if (prefix === '' || propertyName.startsWith(prefix)) {
          var value = style.getPropertyValue(propertyName);

          if (value != null) {
            value = value.trim();
            var fValue = parseFloat(value);
            var valueToAdd = value;

            if (!Number.isNaN(fValue)) {
              valueToAdd = fValue;
            }

            if (makeFlat) {
              var shortName = toCamelCase(propertyName, prefix);
              variables[shortName] = valueToAdd;
            } else {
              var rePrefix = new RegExp(prefix, 'g');
              var noPrefix = propertyName.replace(rePrefix, '');
              Object(_tools__WEBPACK_IMPORTED_MODULE_0__["addToObject"])(variables, noPrefix, valueToAdd, '-');
            }
          }
        }
      }
    }
  }

  return variables;
}



/***/ }),

/***/ "./src/js/tools/htmlGenerator.js":
/*!***************************************!*\
  !*** ./src/js/tools/htmlGenerator.js ***!
  \***************************************/
/*! exports provided: actionWord, click, highlight, addClass, addId, onClickId, highlightWord, centerV, centerH, centerVH, toHTML, itemSelector, unit, applyModifiers, setOnClicks, setHTML, withClass, style, clickW, link */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "actionWord", function() { return actionWord; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "click", function() { return click; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "highlight", function() { return highlight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addClass", function() { return addClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addId", function() { return addId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onClickId", function() { return onClickId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "highlightWord", function() { return highlightWord; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "centerV", function() { return centerV; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "centerH", function() { return centerH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "centerVH", function() { return centerVH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toHTML", function() { return toHTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "itemSelector", function() { return itemSelector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unit", function() { return unit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyModifiers", function() { return applyModifiers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setOnClicks", function() { return setOnClicks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setHTML", function() { return setHTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "withClass", function() { return withClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "style", function() { return style; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clickW", function() { return clickW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "link", function() { return link; });
/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color */ "./src/js/tools/color.js");
/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tools */ "./src/js/tools/tools.js");



function convertTextArrayToParagraphs(text) {
  var firstParagraphMargin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var textToUse = '';
  var firstPStyle = '';

  if (firstParagraphMargin != null) {
    firstPStyle = " style=\"margin-top:".concat(firstParagraphMargin, "%\"");
  }

  if (Array.isArray(text)) {
    text.forEach(function (t, index) {
      if (t.startsWith('<')) {
        textToUse += t;
      } else if (index === 0) {
        textToUse += "<p style=\"margin-top:".concat(firstPStyle, "\">").concat(t, "</p>");
      } else {
        textToUse += "<p>".concat(t, "</p>");
      }
    }); // textToUse = `<p${style}>${text.join('</p><p>')}</p>`;
  } else {
    textToUse = text;
  }

  return textToUse;
}

function withClass() {
  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var classText = arguments.length > 1 ? arguments[1] : undefined;
  var textToUse = convertTextArrayToParagraphs(text);
  return "<div class=\"".concat(classText, "\">").concat(textToUse, "</div>");
}

function centerV() {
  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var textToUse = convertTextArrayToParagraphs(text, 0);
  return "<div style=\"display: table; height: 100%; width: 100%;\">\n        <div style=\"display: table-cell; vertical-align: middle; height: 100%; width: 100%;\">\n        ".concat(textToUse, "</div></div>");
}

function centerVH() {
  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var textToUse = convertTextArrayToParagraphs(text, 0);
  return "<div style=\"display: table; height: 100%; text-align:center; width:100%;\">\n        <div style=\"display: table-cell; vertical-align: middle; height: 100%; width: 100%;\">\n        ".concat(textToUse, "</div></div>");
}

function centerH() {
  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var textToUse = convertTextArrayToParagraphs(text);
  return "<div style=\"text-align:center;\">\n        ".concat(textToUse, "</div>");
}

function style() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var text = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var marginLeft = '';
  var marginRight = '';
  var marginTop = '';
  var marginLine = '';
  var size = '';
  var className = '';
  var color = '';
  var listStyleType = '';

  if (typeof options === 'number') {
    marginTop = "margin-top:".concat(options, "%");
  } else {
    if (options.left != null) {
      marginLeft = "margin-left:".concat(options.left, "%;");
    }

    if (options.right != null) {
      marginRight = "margin-right:".concat(options.right, "%;");
    }

    if (options.centerV) {
      marginTop = 'margin-top:0;';
    }

    if (options.top != null) {
      marginTop = "margin-top:".concat(options.top, "%;");
    }

    if (options.line != null) {
      marginLine = "margin-top:".concat(options.line, "%;");
    }

    if (options.size != null) {
      size = "font-size:".concat(options.size, "em;");
    }

    if (options.className) {
      className = "class=\"".concat(options.className, "\"");
    }

    if (options.color) {
      color = "color:".concat(Object(_color__WEBPACK_IMPORTED_MODULE_0__["colorArrayToRGBA"])(options.color), ";");
    }

    if (options.listStyleType) {
      listStyleType = "list-style-type:".concat(options.listStyleType, ";");
    }
  }

  var p = "<p style=\"".concat(marginLeft).concat(marginRight).concat(marginLine).concat(size).concat(color, "\"").concat(className, ">");
  var pFirst = "<p style=\"".concat(marginLeft).concat(marginRight).concat(marginTop).concat(size).concat(color, "\"").concat(className, ">");
  var li = "<li style=\"".concat(marginLeft).concat(marginRight).concat(marginLine).concat(size).concat(color).concat(listStyleType, "\"").concat(className, ">");
  var ul = "<ul style=\"".concat(marginLeft).concat(marginRight).concat(marginTop).concat(size).concat(color, "\"").concat(className, ">");
  var ol = "<ol style=\"".concat(marginLeft).concat(marginRight).concat(marginTop).concat(size).concat(color, "\"").concat(className, ">");
  var textToUse;

  if (options.list != null) {
    if (Array.isArray(text)) {
      textToUse = text.join("</li>".concat(li));
    } else {
      textToUse = text;
    }

    if (options.list === 'unordered') {
      textToUse = "".concat(ul).concat(li).concat(textToUse, "</ul>");
    } else {
      textToUse = "".concat(ol).concat(li).concat(textToUse, "</ol>");
    }
  } else {
    if (Array.isArray(text)) {
      textToUse = text.join("</p>".concat(p));
    } else {
      textToUse = text;
    }

    textToUse = "".concat(pFirst).concat(textToUse, "</p>");
  }

  if (options.centerH) {
    textToUse = centerH(textToUse);
  }

  if (options.centerV) {
    textToUse = centerV(textToUse);
  }

  return textToUse;
}

function itemSelector() {
  var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [''];
  var classes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var selectorIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var outStr = "<ul id=\"id__figureone_item_selector_".concat(selectorIndex, "\" \n                    class=").concat(classes, ">");
  items.forEach(function (item, index) {
    outStr += "<li id=\"id__figureone_item_selector_".concat(index, "\">").concat(item, "</li>");
  });
  outStr += '</ul>';
  return outStr;
}

var unit = function unit(deg, rad) {
  return "<span class=\"figureone__unit_deg\">".concat(deg, "</span><span class=\"figureone__unit_rad\">").concat(rad, "</span>\n  ");
};

function toHTML() {
  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var classes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  var color = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var idStr = '';

  if (id) {
    idStr = " id=\"".concat(id, "\"");
  }

  var classStr = '';

  if (classes) {
    classStr = " class=\"".concat(classes, "\"");
  }

  var colorStr = '';

  if (color) {
    colorStr = " style=\"color:".concat(Object(_color__WEBPACK_IMPORTED_MODULE_0__["colorArrayToRGBA"])(color), ";\"");
  }

  return {
    replacementText: "<span".concat(idStr).concat(classStr, "\"").concat(colorStr, ">").concat(text.replace(RegExp(/_/, 'gi'), ' ').trim(), "</span>")
  };
}

function highlight() {
  var classesOrColor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var classStr = 'highlight_word';

  if (typeof classesOrColor === 'string') {
    classStr = "".concat(classesOrColor, " ").concat(classStr);
  }

  var color = null;

  if (Array.isArray(classesOrColor)) {
    color = classesOrColor;
  }

  return {
    replacementText: function replacementText(text) {
      return toHTML(text, '', classStr, color);
    }
  };
}

function link(linkStr) {
  var colorOrOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var classStr = 'action_word interactive_word';
  var colorToUse = null;
  var defaultOptions = {
    color: null,
    id: "figureone__id_".concat(Object(_tools__WEBPACK_IMPORTED_MODULE_1__["generateUniqueId"])()),
    interactive: true,
    classes: '',
    text: null,
    newTab: true
  };
  var options = defaultOptions;

  if (Array.isArray(colorOrOptions)) {
    colorToUse = colorOrOptions;
  } else if (colorOrOptions != null) {
    options = Object(_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, colorOrOptions);
  }

  var _options = options,
      color = _options.color,
      id = _options.id,
      classes = _options.classes,
      text = _options.text;

  if (color != null) {
    colorToUse = color;
  }

  if (classes !== '') {
    classStr = "".concat(classStr, " ").concat(classes);
  }

  var target = options.newTab ? ' target="_blank"' : '';

  var idToUse = function idToUse() {
    return id;
  };

  return {
    replacementText: function replacementText(textIn) {
      var idStr = id ? " id=\"".concat(id, "\"") : '';
      var colorStr = colorToUse ? " style=\"color:".concat(Object(_color__WEBPACK_IMPORTED_MODULE_0__["colorArrayToRGBA"])(colorToUse), ";\"") : '';
      return {
        replacementText: "<a href=".concat(linkStr).concat(idStr, "class=\"").concat(classStr, "\"").concat(colorStr, " rel=\"noreferrer noopener\"").concat(target, ">").concat((text || textIn).trim(), "</a>")
      };
    },
    id: idToUse
  };
}

function highlightWord(text) {
  var classesOrColor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var classStr = 'highlight_word';

  if (typeof classesOrColor === 'string') {
    classStr = "".concat(classesOrColor, " ").concat(classStr);
  }

  var color = null;

  if (Array.isArray(classesOrColor)) {
    color = classesOrColor;
  }

  return {
    replacementText: toHTML(text, '', classStr, color).replacementText
  };
}

function addClass() {
  var classes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return {
    replacementText: function replacementText(text) {
      return toHTML(text, '', classes);
    } // id: '',

  };
}

function addId() {
  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return {
    replacementText: function replacementText(text) {
      return toHTML(text, id);
    } // id: '',

  };
}

function click(actionMethod, bind) {
  var colorOrOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var classStr = 'action_word';
  var colorToUse = null;
  var defaultOptions = {
    color: null,
    id: "figureone__id_".concat(Object(_tools__WEBPACK_IMPORTED_MODULE_1__["generateUniqueId"])()),
    interactive: true,
    classes: '',
    text: null
  };
  var options = defaultOptions;

  if (Array.isArray(colorOrOptions)) {
    colorToUse = colorOrOptions;
  } else if (colorOrOptions != null) {
    options = Object(_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, colorOrOptions);
  }

  var _options2 = options,
      interactive = _options2.interactive,
      color = _options2.color,
      id = _options2.id,
      classes = _options2.classes,
      text = _options2.text;

  if (color != null) {
    colorToUse = color;
  }

  if (interactive) {
    classStr = "".concat(classStr, " interactive_word");
  }

  if (classes !== '') {
    classStr = "".concat(classStr, " ").concat(classes);
  }

  var idToUse = function idToUse() {
    return id;
  };

  return {
    replacementText: function replacementText(textIn) {
      return toHTML(text || textIn, idToUse(), classStr, colorToUse);
    },
    id: idToUse,
    actionMethod: actionMethod,
    bind: bind
  };
}

function clickW(textToUse, actionMethod, bind) {
  var color = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  return click(actionMethod, bind, {
    color: color,
    text: textToUse
  });
}

function actionWord(text) {
  var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Object(_tools__WEBPACK_IMPORTED_MODULE_1__["generateUniqueId"])();
  var classesOrColor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var interactive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var classStr = 'action_word';

  if (interactive) {
    classStr = "".concat(classStr, " interactive_word");
  }

  if (typeof classesOrColor === 'string') {
    classStr = "".concat(classesOrColor, " ").concat(classStr);
  }

  var color = null;

  if (Array.isArray(classesOrColor)) {
    color = classesOrColor;
  }

  return {
    replacementText: toHTML(text, id, classStr, color).replacementText,
    id: id
  };
}

function modifyText(text, key, mod) {
  var outText = '';
  var expression = new RegExp("\\|".concat(key, "\\|"), 'gi');
  var replacement = '';

  if (typeof mod === 'string') {
    replacement = mod;
  } else if (typeof mod.replacementText === 'string') {
    replacement = mod.replacementText;
  } else {
    replacement = mod.replacementText(key).replacementText;
  }

  outText = text.replace(expression, replacement);
  return outText;
}

function onClickId(id, actionMethod, bind) {
  var additionalClassesToAdd = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
  var element = document.getElementById(id);

  if (element) {
    element.classList.add('action_word_enabled');
    additionalClassesToAdd.split(' ').forEach(function (classString) {
      if (classString) {
        element.classList.add(classString);
      }
    });

    if (bind.length === 1) {
      element.onclick = actionMethod.bind(bind[0]);
    }

    if (bind.length === 2) {
      element.onclick = actionMethod.bind(bind[0], bind[1]);
    }

    if (bind.length === 3) {
      element.onclick = actionMethod.bind(bind[0], bind[1], bind[2]);
    }

    if (bind.length === 4) {
      element.onclick = actionMethod.bind(bind[0], bind[1], bind[2], bind[3]);
    }

    if (bind.length === 5) {
      element.onclick = actionMethod.bind(bind[0], bind[1], bind[2], bind[3], bind[4]);
    }

    if (bind.length === 6) {
      element.onclick = actionMethod.bind(bind[0], bind[1], bind[2], bind[3], bind[4], bind[5]);
    }

    if (bind.length === 7) {
      element.onclick = actionMethod.bind(bind[0], bind[1], bind[2], bind[3], bind[4], bind[5], bind[6]);
    }

    if (bind.length === 8) {
      element.onclick = actionMethod.bind(bind[0], bind[1], bind[2], bind[3], bind[4], bind[5], bind[6], bind[7]);
    }

    if (bind.length === 9) {
      element.onclick = actionMethod.bind(bind[0], bind[1], bind[2], bind[3], bind[4], bind[5], bind[6], bind[7], bind[8]);
    }
  }
}

function applyModifiers(text, modifiers) {
  var highlightClass = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'highlight_word';
  var monochrome = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var outText = text;
  Object.keys(modifiers).forEach(function (key) {
    var mod = modifiers[key]; // if (mod.replacementText != null) {

    outText = modifyText(outText, key, mod); // }
  });
  var r = RegExp(/\|([^|]*)\|/gi);
  outText = outText.replace(r, "<span class=\"".concat(highlightClass, "\">$1</span>"));

  if (monochrome) {
    var c = RegExp(/style="color:rgba\([^)]*\);"/gi);
    outText = outText.replace(c, '');
    var h = RegExp(/highlight_word/gi);
    outText = outText.replace(h, '');
    var i = RegExp(/interactive_word/gi);
    outText = outText.replace(i, '');
    var id = RegExp(/id="[^"]*"/gi);
    outText = outText.replace(id, '');
  }

  return outText;
}

function setOnClicks(modifiers) {
  var additionalClassesToAdd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  Object.keys(modifiers).forEach(function (key) {
    var mod = modifiers[key];

    if (typeof mod !== 'string' && 'actionMethod' in mod) {
      onClickId(mod.id(key), mod.actionMethod, mod.bind, additionalClassesToAdd);
    }
  });
}

function setHTML(element, text) {
  var modifiers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var classesToAdd = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
  var modifiedText = applyModifiers(text, modifiers); // eslint-disable-next-line no-param-reassign

  element.innerHTML = modifiedText;
  setOnClicks(modifiers, classesToAdd);
}



/***/ }),

/***/ "./src/js/tools/m2.js":
/*!****************************!*\
  !*** ./src/js/tools/m2.js ***!
  \****************************/
/*! exports provided: mul, identity, t, copy, translate, rotate, transform, scale, inverse, rotationMatrix, translationMatrix, scaleMatrix */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "t", function() { return t; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transform", function() { return transform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotationMatrix", function() { return rotationMatrix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translationMatrix", function() { return translationMatrix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleMatrix", function() { return scaleMatrix; });
// 2D Matrix functions
function mul(a, b) {
  return [a[0] * b[0] + a[1] * b[3] + a[2] * b[6], a[0] * b[1] + a[1] * b[4] + a[2] * b[7], a[0] * b[2] + a[1] * b[5] + a[2] * b[8], a[3] * b[0] + a[4] * b[3] + a[5] * b[6], a[3] * b[1] + a[4] * b[4] + a[5] * b[7], a[3] * b[2] + a[4] * b[5] + a[5] * b[8], a[6] * b[0] + a[7] * b[3] + a[8] * b[6], a[6] * b[1] + a[7] * b[4] + a[8] * b[7], a[6] * b[2] + a[7] * b[5] + a[8] * b[8]];
}

function t(a) {
  return [a[0], a[3], a[6], a[1], a[4], a[7], a[2], a[5], a[8]];
}

function identity() {
  return [1, 0, 0, 0, 1, 0, 0, 0, 1];
}

function copy(a) {
  return [a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]];
}

function translationMatrix(tx, ty) {
  return [1, 0, tx, 0, 1, ty, 0, 0, 1];
}

function translate(m, tx, ty) {
  return mul(m, translationMatrix(tx, ty));
}

function rotationMatrix(angle) {
  var c = Math.cos(angle);
  var s = Math.sin(angle);
  return [c, -s, 0, s, c, 0, 0, 0, 1];
}

function rotate(m, angle) {
  return mul(m, rotationMatrix(angle));
}

function scaleMatrix(sx, sy) {
  return [sx, 0, 0, 0, sy, 0, 0, 0, 1];
}

function scale(m, sx, sy) {
  return mul(m, scaleMatrix(sx, sy));
}

function transform(m, px, py) {
  return [m[0] * px + m[1] * py + m[2], m[3] * px + m[4] * py + m[5]];
}

function inverse(m) {
  var det = m[0] * (m[4] * m[8] - m[7] * m[5]) - // eslint-disable-line
  m[1] * (m[3] * m[8] - m[5] * m[6]) + // eslint-disable-line
  m[2] * (m[3] * m[7] - m[4] * m[6]);
  var invdet = 1 / det;
  var minv00 = (m[4] * m[8] - m[7] * m[5]) * invdet;
  var minv01 = (m[2] * m[7] - m[1] * m[8]) * invdet;
  var minv02 = (m[1] * m[5] - m[2] * m[4]) * invdet;
  var minv10 = (m[5] * m[6] - m[3] * m[8]) * invdet;
  var minv11 = (m[0] * m[8] - m[2] * m[6]) * invdet;
  var minv12 = (m[3] * m[2] - m[0] * m[5]) * invdet;
  var minv20 = (m[3] * m[7] - m[6] * m[4]) * invdet;
  var minv21 = (m[6] * m[1] - m[0] * m[7]) * invdet;
  var minv22 = (m[0] * m[4] - m[3] * m[1]) * invdet;
  return [minv00, minv01, minv02, minv10, minv11, minv12, minv20, minv21, minv22];
}



/***/ }),

/***/ "./src/js/tools/math.js":
/*!******************************!*\
  !*** ./src/js/tools/math.js ***!
  \******************************/
/*! exports provided: round, roundNum, decelerate, easeinout, easeout, easein, sinusoid, linear, clipMag, clipValue, range, randInt, rand, randElement, removeRandElement, randElements, rand2D, randSign */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "roundNum", function() { return roundNum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decelerate", function() { return decelerate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "easeinout", function() { return easeinout; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "easeout", function() { return easeout; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "easein", function() { return easein; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinusoid", function() { return sinusoid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linear", function() { return linear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clipMag", function() { return clipMag; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clipValue", function() { return clipValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "range", function() { return range; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randInt", function() { return randInt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rand", function() { return rand; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randElement", function() { return randElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeRandElement", function() { return removeRandElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randElements", function() { return randElements; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rand2D", function() { return rand2D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randSign", function() { return randSign; });
var roundNum = function roundNum(value) {
  var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;
  var multiplier = Math.pow(10, precision);
  var result = Math.round(value * multiplier) / multiplier; // if (Object.is(result, -0)) {
  // if (result === -0) {
  //   result = 0;
  // }

  var objectIsPolyfill = function objectIsPolyfill(x, y) {
    if (x === y) {
      // 0 === -0, but they are not identical
      return x !== 0 || 1 / x === 1 / y;
    } // NaN !== NaN, but they are identical.
    // NaNs are the only non-reflexive value, i.e., if x !== x,
    // then x is a NaN.
    // isNaN is broken: it converts its argument to number, so
    // isNaN("foo") => true
    // eslint-disable-next-line no-self-compare


    return x !== x && y !== y;
  };

  if (objectIsPolyfill(result, -0)) {
    result = 0;
  } // if (result === -0) {
  //   // 0 === -0, but they are not identical
  //   return result !== 0 || 1 / x === 1 / y;
  // }


  return result;
};

/**
 * Rounds a number or numbers in an array
 * @method
 * @param {number | Array<number>} arrayOrValue - Value or array of values to be rounded
 * @param {number} precision - Number of decimal places to round to
 * @returns {number | Array<number>} Rounded value or array of values
 */
function round(arrayOrValue) {
  var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;
  var result = 0;

  if (Array.isArray(arrayOrValue)) {
    return arrayOrValue.map(function (elem) {
      return round(elem, precision);
    });
  }

  if (typeof arrayOrValue === 'number') {
    result = roundNum(arrayOrValue, precision);
  } else if (arrayOrValue != null && arrayOrValue.round != null) {
    result = arrayOrValue.round(precision);
  } // $FlowFixMe


  return result;
} // // clipValue clips a value to either 0 if it's small enough, or to a max value
// // Value, and maxValue are sign independent. e.g.
// //    * value, maxValue = 2, 1 => clips to 1
// //    * value, maxValue = -2, -1 => clips to -1
// //    * value, maxValue = -2, 1 => clips to -1
// //    * value, maxValue = 2, -1 => clips to 1
// function clipValue(
//   value: number,
//   zeroThreshold: number,
//   maxValue: number = 0,
// ) {
//   let result = value;
//   let zero = zeroThreshold;
//   if (zero < 0) {
//     zero = -zero;
//   }
//   if (value > -zero && value < zero) {
//     return 0;
//   }
//   let max = maxValue;
//   if (max < 0) {
//     max = -max;
//   }
//   if (value > max) {
//     result = max;
//   }
//   if (value < -max) {
//     result = -max;
//   }
//   return result;
// }
// Clip a value to either max velocity, or 0 once under the minimum
// threashold.
//  * velocity: can be positive or negative
//  * maxVelocity will clip velocity to:
//      * |maxVelocity| if velocity > 0
//      * -|maxVelocity| if velcity < 0
//  * zeroThreshold will clip velocity to:
//       * 0 if velocity is larger than -|zeroThreshold| and smaller than
//         |zeroThreshold|.


function clipMag(value, zeroThreshold, maxValue) {
  var result = value;
  var zeroT = zeroThreshold;
  var maxV = maxValue;

  if (zeroT === null) {
    zeroT = 0;
  }

  if (zeroT < 0) {
    zeroT = -zeroT;
  }

  if (maxV === null) {
    return result;
  }

  if (maxV < 0) {
    maxV = -maxV;
  }

  if (value >= -zeroT && value <= zeroT) {
    result = 0;
  }

  if (value > maxV) {
    result = maxV;
  }

  if (value < -maxV) {
    result = -maxV;
  }

  return result;
}

function clipValue(value, minValue, maxValue) {
  var clipped = value;

  if (minValue !== null) {
    if (value < minValue) {
      clipped = minValue;
    }
  }

  if (maxValue !== null) {
    if (value > maxValue) {
      clipped = maxValue;
    }
  }

  return clipped;
}

var decelerate = function getPositionVelocityFromDecAndTime(position, velocity, magDeceleration, time, zeroThreshold) {
  var zeroT = 0;

  if (zeroThreshold !== null) {
    zeroT = zeroThreshold;
  }

  var decel = 0;

  if (magDeceleration !== null) {
    decel = magDeceleration;
  } // If the velocity is currently 0, then no further deceleration can occur, so
  // return the current velocity and position


  var v = clipMag(velocity, zeroT, velocity);

  if (v === 0) {
    return {
      p: position,
      v: 0
    };
  }

  var d = decel;

  if (decel < 0) {
    d = -d;
  } // If there is some initial velocity, then calc its sign and


  var sign = velocity / Math.abs(velocity);
  var newVelocity = velocity - sign * d * time; // if the new velocity changes sign, then it should go to 0. If it doesn't
  // change sign, then clip incase it should go to 0 because it is below
  // the zero velocity threshold.

  var newSign = newVelocity / Math.abs(newVelocity);

  if (newSign !== sign) {
    newVelocity = 0;
  } else {
    newVelocity = clipMag(newVelocity, zeroT, newVelocity);
  } // If the new velocity is clipped, then we need to use the time to where the
  // velocity crosses the clipping point.
  // v_new = v_init + a*t
  // Therefore, if v_new = zeroT: t = (zeroT - vi)/a


  var t = time;

  if (newVelocity === 0) {
    var z = zeroT;
    var zSign = z / Math.abs(z);

    if (zSign !== sign) {
      z = -z;
    }

    t = Math.abs((z - velocity) / d);
  } // Now can calculate the new position


  var newPosition = position + velocity * t - sign * 0.5 * d * t * t;
  return {
    p: newPosition,
    v: newVelocity
  };
};

var linear = function linear(percentTime) {
  var invert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (invert) {
    return percentTime;
  }

  return percentTime;
};

var easeinout = function easeinout(percentTime) {
  var invert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (invert) {
    var a = percentTime;
    return (2 * a - Math.sqrt(-4 * a * a + 4 * a)) / (4 * a - 2);
  }

  var x = percentTime;
  var percentDistance = Math.pow(x, 2) / (Math.pow(x, 2) + Math.pow(1 - x, 2));
  return percentDistance;
}; // TODO fix invert


function easeout(percentTime) {
  var invert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (invert) {
    var a = percentTime;
    var b = (2 * a - Math.sqrt(-4 * a * a + 4 * a)) / (4 * a - 2); // return (b - 0.5) * 2;

    return b;
  }

  var x = 0.5 + percentTime / 2;
  var power = 2;
  var percentDistance = Math.pow(x, power) / (Math.pow(x, power) + Math.pow(1 - x, power));
  return (percentDistance - 0.5) * 2;
} // TODO fix invert


function easein(percentTime) {
  var invert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (invert) {
    var a = percentTime;
    var b = (2 * a - Math.sqrt(-4 * a * a + 4 * a)) / (4 * a - 2); // return (b - 0.5) * 2;

    return b;
  }

  var x = percentTime / 2;
  var power = 2;
  var percentDistance = Math.pow(x, power) / (Math.pow(x, power) + Math.pow(1 - x, power));
  return percentDistance * 2;
}

function sinusoid() {
  var deltaTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
  var frequency = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var bias = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var mag = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
  var phaseOffset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
  return bias + mag * Math.sin(deltaTime * frequency * 2.0 * Math.PI + phaseOffset);
} // const animationPhase = (transform, time, rotDirection = 0, animationStyle = easeinout) => {
//     return {
//         transform: transform._dup(),
//         time: time,
//         rotDirection: rotDirection,
//         animationStyle: animationStyle,
//     }
// }

/**
 * Creates an array with a range of number
 * @method
 * @memberof tools
 * @param start - Range start
 * @param stop - Range stop
 * @param step - Range step
 * @returns {Array<number>} Range of numbers in an array
 */


function range(start, stop) {
  var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var out = [];

  for (var i = start; i <= stop + step * 0.5; i += step) {
    out.push(i);
  }

  return out;
}

function randSign() {
  return Math.random() > 0.5 ? 1 : -1;
}

function randInt(minOrMax) {
  var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var plusOrMinus = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var r = 0;

  if (max != null) {
    var min = minOrMax;
    r = Math.floor(Math.random() * Math.floor(max - min) + Math.floor(min));
  } else {
    r = Math.floor(Math.random() * Math.floor(minOrMax));
  }

  if (plusOrMinus) {
    r *= randSign();
  }

  return r;
}

function rand(minOrMax) {
  var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var plusOrMinus = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var r = 0;

  if (max != null) {
    var min = minOrMax;
    r = Math.random() * (max - min) + min;
  } else {
    r = Math.random() * minOrMax;
  }

  if (plusOrMinus) {
    r *= randSign();
  }

  return r;
}

function randElement(inputArray) {
  var index = randInt(inputArray.length);
  return inputArray[index];
}

function removeRandElement(inputArray) {
  var index = rand(inputArray.length);
  return inputArray.splice(index, 1)[0];
}

function randElements(num, inputArray) {
  var possibleIndeces = range(0, inputArray.length - 1, 1);
  var elements = [];

  for (var i = 0; i < num; i += 1) {
    var index = removeRandElement(possibleIndeces);
    elements.push(inputArray[index]);
  }

  return elements;
}

function rand2D(minX, minY, maxX, maxY) {
  return {
    x: rand(minX, maxX),
    y: rand(minY, maxY)
  };
}



/***/ }),

/***/ "./src/js/tools/styleSheets.js":
/*!*************************************!*\
  !*** ./src/js/tools/styleSheets.js ***!
  \*************************************/
/*! exports provided: getCSSVariables, getDefinedCSSVariables, searchObject, getCSSColors */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _getCssVariables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getCssVariables */ "./src/js/tools/getCssVariables.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getCSSVariables", function() { return _getCssVariables__WEBPACK_IMPORTED_MODULE_0__["getCSSVariables"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getDefinedCSSVariables", function() { return _getCssVariables__WEBPACK_IMPORTED_MODULE_0__["getDefinedCSSVariables"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "searchObject", function() { return _getCssVariables__WEBPACK_IMPORTED_MODULE_0__["searchObject"]; });

/* harmony import */ var _getCssColors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getCssColors */ "./src/js/tools/getCssColors.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getCSSColors", function() { return _getCssColors__WEBPACK_IMPORTED_MODULE_1__["default"]; });





/***/ }),

/***/ "./src/js/tools/tools.js":
/*!*******************************!*\
  !*** ./src/js/tools/tools.js ***!
  \*******************************/
/*! exports provided: divide, mulToString, add, Console, classify, extractFrom, ObjectKeyPointer, getElement, addToObject, duplicateFromTo, isTouchDevice, generateUniqueId, joinObjects, cleanUIDs, loadRemote, loadRemoteCSS, deleteKeys, copyKeysFromTo, generateRandomString, duplicate, assignObjectFromTo, joinObjectsWithOptions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divide", function() { return divide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mulToString", function() { return mulToString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Console", function() { return Console; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "classify", function() { return classify; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractFrom", function() { return extractFrom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObjectKeyPointer", function() { return ObjectKeyPointer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getElement", function() { return getElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addToObject", function() { return addToObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "duplicateFromTo", function() { return duplicateFromTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isTouchDevice", function() { return isTouchDevice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generateUniqueId", function() { return generateUniqueId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "joinObjects", function() { return joinObjects; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cleanUIDs", function() { return cleanUIDs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadRemote", function() { return loadRemote; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadRemoteCSS", function() { return loadRemoteCSS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deleteKeys", function() { return deleteKeys; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyKeysFromTo", function() { return copyKeysFromTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generateRandomString", function() { return generateRandomString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "duplicate", function() { return duplicate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assignObjectFromTo", function() { return assignObjectFromTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "joinObjectsWithOptions", function() { return joinObjectsWithOptions; });
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Console = function Console(text) {
  console.log(text); // eslint-disable-line no-console
};

function add(a, b) {
  return a + b;
}

function mulToString(a, b) {
  return (a * b).toString();
}

var divide = function divide(a, b) {
  return a / b;
};

var classify = function classify(key, value) {
  var nonEmpty = value || key;
  var withKey = nonEmpty[0] === '-' || nonEmpty.startsWith("".concat(key, "-")) ? "".concat(key, " ").concat(nonEmpty) : nonEmpty;
  var joinStr = " ".concat(key, "-");
  return "".concat(withKey.split(' -').join(joinStr));
};

var ObjectKeyPointer =
/*#__PURE__*/
function () {
  function ObjectKeyPointer(object, key) {
    _classCallCheck(this, ObjectKeyPointer);

    this.object = object;
    this.key = '';

    if (key in object) {
      this.key = key;
    }
  }

  _createClass(ObjectKeyPointer, [{
    key: "setValue",
    value: function setValue(value) {
      if (this.key) {
        this.object[this.key] = value;
      }
    }
  }, {
    key: "execute",
    value: function execute() {
      if (this.key) {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return this.object[this.key].apply(null, args);
      }

      return undefined;
    }
  }, {
    key: "value",
    value: function value() {
      if (this.key) {
        return this.object[this.key];
      }

      return undefined;
    }
  }]);

  return ObjectKeyPointer;
}(); //


function extractFrom(objectToExtractFrom, keyValues) {
  var keyPrefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  var out = [];

  if (typeof keyValues === 'string') {
    if (keyPrefix + keyValues in objectToExtractFrom) {
      return new ObjectKeyPointer(objectToExtractFrom, keyPrefix + keyValues);
    }

    var keyHeirarchy = keyValues.split('_');
    var keys = keyHeirarchy.filter(function (k) {
      return k.length > 0;
    });

    if (keys.length > 1) {
      if (keyPrefix + keys[0] in objectToExtractFrom) {
        return extractFrom(objectToExtractFrom[keyPrefix + keys[0]], keys.slice(1).join('_'), keyPrefix);
      }
    } else if (keys.length === 1) {
      if (keyPrefix + keys[0] in objectToExtractFrom) {
        return new ObjectKeyPointer(objectToExtractFrom, keyPrefix + keys[0]);
      }
    }

    return undefined;
  }

  if (Array.isArray(keyValues)) {
    keyValues.forEach(function (kv) {
      var result = extractFrom(objectToExtractFrom, kv, keyPrefix);

      if (result !== undefined) {
        out.push(result);
      }
    });
  } else {
    Object.keys(keyValues).forEach(function (key) {
      if (keyPrefix + key in objectToExtractFrom) {
        out.push({
          obj: new ObjectKeyPointer(objectToExtractFrom, keyPrefix + key),
          // $FlowFixMe
          value: keyValues[key]
        });
      }
    });
  }

  return out;
}

function getElement(collection, keyValues) {
  return extractFrom(collection, keyValues, '_');
}

function addToObject(obj, nameToAdd, valueToAdd) {
  var splitStr = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '-';
  var levels = nameToAdd.split(splitStr);
  var currentLevel = obj;
  levels.forEach(function (level, index) {
    if (index === levels.length - 1) {
      currentLevel[level] = valueToAdd;
      return;
    }

    if (!Object.prototype.hasOwnProperty.call(currentLevel, level)) {
      currentLevel[level] = {};
    }

    currentLevel = currentLevel[level];
  });
} // function duplicateFromTo(
//   fromObject: Object,
//   toObject: Object,
//   exceptKeys: Array<string> = [],
// ) {
//   const copyValue = (value) => {
//     if (typeof value === 'number'
//         || typeof value === 'boolean'
//         || typeof value === 'string'
//         || value == null
//         || typeof value === 'function') {
//       return value;
//     }
//     if (typeof value._dup === 'function') {
//       return value._dup();
//     }
//     if (Array.isArray(value)) {
//       const arrayCopy = [];
//       value.forEach(arrayElement => arrayCopy.push(copyValue(arrayElement)));
//       return arrayCopy;
//     }
//     if (typeof value === 'object') {
//       const objectCopy = {};
//       Object.keys(value).forEach((key) => {
//         const v = copyValue(value[key]);
//         objectCopy[key] = v;
//       });
//       return objectCopy;
//     }
//     return value;
//   };
//   Object.keys(fromObject).forEach((key) => {
//     if (exceptKeys.indexOf(key) === -1) {
//       // eslint-disable-next-line no-param-reassign
//       toObject[key] = copyValue(fromObject[key]);
//     }
//   });
// }


function duplicate(value) {
  if (typeof value === 'number' || typeof value === 'boolean' || typeof value === 'string' || value == null || typeof value === 'function') {
    return value;
  }

  if (typeof value._dup === 'function') {
    return value._dup();
  }

  if (Array.isArray(value)) {
    var arrayDup = [];
    value.forEach(function (arrayElement) {
      return arrayDup.push(duplicate(arrayElement));
    });
    return arrayDup;
  }

  if (_typeof(value) === 'object') {
    var objectDup = {};
    Object.keys(value).forEach(function (key) {
      var v = duplicate(value[key]);
      objectDup[key] = v;
    });
    return objectDup;
  }

  return value;
}

function assignObjectFromTo(fromObject, toObject) {
  var exceptIn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var duplicateValues = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var parentPath = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';
  var except = typeof exceptIn === 'string' ? [exceptIn] : exceptIn;
  Object.keys(fromObject).forEach(function (key) {
    var keyPath = parentPath !== '' ? "".concat(parentPath, ".").concat(key) : key;

    if (except.indexOf(keyPath) !== -1) {
      return;
    }

    var value = fromObject[key];

    if (typeof value === 'number' || typeof value === 'boolean' || typeof value === 'string' || value == null || typeof value === 'function' || typeof value._dup === 'function' || Array.isArray(value)) {
      // Only assign the value if:
      //    * Value is not undefined OR
      //    * Value is undefined and toObject[key] is undefined
      if (value !== undefined || toObject[key] === undefined) {
        if (duplicateValues) {
          // eslint-disable-next-line no-param-reassign
          toObject[key] = duplicate(value);
        } else {
          // eslint-disable-next-line no-param-reassign
          toObject[key] = value;
        }
      }
    } else {
      // If the fromObject[key] value is an object, but the toObject[key] value
      // is not an object, but then make toObject[key] an empty object
      var toValue = toObject[key];

      if (typeof toValue === 'number' || typeof toValue === 'boolean' || typeof toValue === 'string' || toValue == null || typeof toValue === 'function' || Array.isArray(toValue)) {
        // eslint-disable-next-line no-param-reassign
        toObject[key] = {};
      }

      assignObjectFromTo(value, toObject[key], except, duplicateValues, keyPath);
    }
  });
}

function joinObjectsWithOptions(options) {
  var except = options.except;
  var dup = options.duplicate;

  if (except == null) {
    except = [];
  }

  if (dup == null) {
    dup = false;
  }

  var num = arguments.length <= 1 ? 0 : arguments.length - 1;
  var out = arguments.length <= 1 ? undefined : arguments[1];

  for (var i = 1; i < num; i += 1) {
    var o = i + 1 < 1 || arguments.length <= i + 1 ? undefined : arguments[i + 1];

    if (o != null) {
      assignObjectFromTo(o, out, except, dup, '');
    }
  }

  return out;
} // joins objects like object.assign but goes as many levels deep as the object
// is. Objects later in the arrawy overwrite objects earlier.


function joinObjects() {
  for (var _len2 = arguments.length, objects = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    objects[_key2] = arguments[_key2];
  }

  // if (typeof objects === 'object') {
  //   return objects;
  // }
  // const assignObjectFromTo1 = (fromObject: Object, toObject: Object) => {
  //   Object.keys(fromObject).forEach((key) => {
  //     const value = fromObject[key];
  //     if (typeof value === 'number'
  //       || typeof value === 'boolean'
  //       || typeof value === 'string'
  //       || value == null
  //       || typeof value === 'function'
  //       || typeof value._dup === 'function'
  //       || Array.isArray(value)
  //     ) {
  //       // console.log(value, toObject[key])
  //       if (value !== undefined || toObject[key] === undefined) {
  //         // eslint-disable-next-line no-param-reassign
  //         toObject[key] = value;
  //       }
  //     } else {
  //       const toValue = toObject[key];
  //       if (typeof toValue === 'number'
  //         || typeof toValue === 'boolean'
  //         || typeof toValue === 'string'
  //         || toValue == null
  //         || typeof toValue === 'function'
  //         || Array.isArray(toValue)
  //       ) {
  //         // eslint-disable-next-line no-param-reassign
  //         toObject[key] = {};
  //       }
  //       assignObjectFromTo1(value, toObject[key]);
  //     }
  //   });
  // };
  // const num = objects.length;
  // const out = objects[0];
  // for (let i = 1; i < num; i += 1) {
  //   const o = objects[i];
  //   if (o != null) {
  //     assignObjectFromTo1(o, out);
  //   }
  // }
  // return out;
  return joinObjectsWithOptions.apply(void 0, [{}].concat(objects));
}

function duplicateFromTo(fromObject, toObject) {
  var exceptKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  joinObjectsWithOptions({
    except: exceptKeys,
    duplicate: true
  }, toObject, fromObject);
}

function generateUniqueId() {
  var seed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

  var randomString = function randomString(s) {
    return "".concat(s).concat(Math.floor(Math.random() * 1000000));
  };

  var seedToUse = seed;

  if (seedToUse.length === 0) {
    seedToUse = 'id_random_';
  }

  var idExists = true;
  var newId = randomString(seedToUse);

  while (idExists) {
    newId = randomString(seedToUse);
    var element = document.getElementById(newId);

    if (element == null) {
      idExists = false;
    }
  }

  return newId;
}

function isTouchDevice() {
  var prefixes = ' -webkit- -moz- -o- -ms- '.split(' ');

  var mq = function mq(query) {
    return window.matchMedia(query).matches;
  };
  /* eslint-disable no-undef, no-mixed-operators */
  // $FlowFixMe


  if ('ontouchstart' in window || window.DocumentTouch && document instanceof DocumentTouch) {
    return true;
  }
  /* eslint-enable no-undef, no-mixed-operators */
  // include the 'heartz' as a way to have a non matching MQ to help terminate the join
  // https://git.io/vznFH


  var query = ['(', prefixes.join('touch-enabled),('), 'heartz', ')'].join('');
  return mq(query);
}

function loadRemote(scriptId, url) {
  var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var existingScript = document.getElementById(scriptId);

  if (!existingScript) {
    var script = document.createElement('script');
    script.type = 'text/javascript';
    script.src = url;
    script.id = scriptId; // e.g., googleMaps or stripe

    if (document.body) {
      document.body.appendChild(script);
    }

    script.onload = function () {
      if (callback != null) {
        callback(scriptId, url);
      }
    };
  } else if (callback != null) {
    callback(scriptId, url);
  }
}

function loadRemoteCSS(id, url) {
  var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var existingScript = document.getElementById(id);

  if (!existingScript) {
    var link = document.createElement('link');
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = url;
    link.id = id; // e.g., googleMaps or stripe

    if (document.body) {
      document.body.appendChild(link);
    }

    link.onload = function () {
      if (callback != null) {
        callback(id, url);
      }
    };
  } else if (callback != null) {
    callback(id, url);
  }
} // function remoteLoadToObject(
//   scriptId: string,
//   url: string,
//   toObject: {},
//   callback: null | (string, string) => void = null,
// ) {
//   loadRemote(scriptId, url, callback);
// }


var cleanUIDs = function cleanUIDs(objectToClean) {
  var genericUID = '0000000000';

  if (objectToClean == null) {
    return;
  }

  if ('uid' in objectToClean) {
    if (objectToClean.uid === genericUID) {
      return;
    } // eslint-disable-next-line no-param-reassign


    objectToClean.uid = genericUID;
  }

  var keys = Object.keys(objectToClean);

  for (var i = 0; i < keys.length; i += 1) {
    var key = keys[i];
    var value = objectToClean[key];

    if (_typeof(value) === 'object' && !Array.isArray(value) && value != null && typeof value !== 'function' && typeof value !== 'number' && typeof value !== 'boolean' && typeof value !== 'string') {
      cleanUIDs(value);
    }
  }
};

function deleteKeys(obj, keys) {
  keys.forEach(function (key) {
    if (obj[key] !== undefined) {
      // eslint-disable-next-line no-param-reassign
      delete obj[key];
    }
  });
}

function copyKeysFromTo(source, destination, keys) {
  keys.forEach(function (key) {
    if (source[key] !== undefined) {
      // eslint-disable-next-line no-param-reassign
      destination[key] = source[key];
    }
  });
}

function generateRandomString() {
  return (Math.random() * 1e18).toString(36);
}



/***/ })

/******/ })["default"];
});
//# sourceMappingURL=index.js.map